% Einige zusätzliche Informationen für rubber
%  rubber erkennt nicht, dass die Datei weg kann, daher sagen wir es ihm
% rubber: clean $base.thm
%  rubber soll nach Änderungen an der Datei nochmal bauen
% rubber: watch $base.thm
% rubber: index.tool      xindy
% rubber: index.language  german-din
%
% scrreprt trifft am Besten die Bedürfnisse eines Skripts, das ganze wird
% zweiseitig (twoside), d.h. es wird zwischen linker und rechter Seite
% unterschieden, und wir verwenden zwischen den Absätzen einen Abstand
% von einer halben Zeile (halfparskip) und dafür keinen Absatzeinzug,
% wobei die letzte Zeile eines Absatzes zu min. 1/4 leer ist.

\RequirePackage[l2tabu,orthodox]{nag}  % nag überprüft den Text auf veraltete
                   % Befehle oder solche, die man nicht in LaTeX verwenden
                   % soll -- l2tabu-Checker in LaTeX

\documentclass[ngerman,draft,parskip=half*,twoside]{scrreprt}

\usepackage{ifthen}
\usepackage{index}
\usepackage[final]{graphicx}  % Für Grafiken
\usepackage{xcolor}
\usepackage[draft=false,colorlinks,bookmarksnumbered,linkcolor=blue,breaklinks]{hyperref}

\usepackage[latin1]{inputenc}
\usepackage{babel}
% \usepackage{nicefrac}
% \usepackage{tabularx}

\usepackage{lmodern}		% Latin Modern
% \usepackage{type1ec}           % cm-super
\usepackage[T1]{fontenc}        % T1-Schriften notwendig für PDFs
\usepackage{textcomp}           % wird benötigt, damit der \textbullet
                                % für itemize in lmodern gefunden wird.

\usepackage[intlimits,leqno]{amsmath}
\usepackage[all,warning]{onlyamsmath}  % warnt bei Verwendung von nicht
                                       % amsmath-Umgebungen z.\,B. $$...$$
\usepackage{amssymb}     % wird für \R, \C,... gebraucht
\usepackage{fixmath}     % ISO-konforme griech. Buchstaben
\usepackage[euro]{isonums} % definiert Komma als Dezimaltrennzeichen

\usepackage[amsmath,thmmarks,hyperref]{ntheorem} % für die Theorem-Umgebungen
                                                 % (satz, defini, bemerk)
\usepackage{xspace}      % wird weiter unten gebraucht
\usepackage{slashbox}    % für schräge Striche links oben in der
                         % Tabelle; s. texdoc slashbox

\usepackage{paralist}    % besseres enumerate und itemize und neue
                         % compactenum/compactitem; s. texdoc paralist

\usepackage{svn}         % Zum Auswerten und ordentlichen Darstellen der
                         % SVN-Schlüsselwörter (s. vor \begin{document})
                         % dafür muss in SVN noch das Flag svn:keywords
                         % auf "LastChangedRevision LastChangedDate"
                         % gesetzt werden
% \usepackage{ifpdf}       % Erkennung, ob PDF generiert wird; nützlich zur
                         % Unterscheidung bei Grafiken \input{XYZ.pdf_t}
\usepackage{ellipsis}    % Korrektur für \dots
\usepackage{fixltx2e}
\usepackage[final,babel]{microtype} % Verbesserung der Typographie
\usepackage{mathtools}   % Zur Definition von \abs und \norm
\usepackage[babel]{csquotes}

\usepackage[algochapter,linesnumbered]{algorithm2e}

% Damit auch die Zeichen im Mathemode in Überschriften fett sind
% <news:lzfyyvx3pt.fsf@tfkp12.physik.uni-erlangen.de>
\addtokomafont{sectioning}{\boldmath}

% nach dem Theoremkopf wird ein Zeilenumbruch eingefügt, die Schrift des
% Körpers ist normal und der Kopf wird fett gesetzt
\theoremstyle{break}
\theoremnumbering{arabic}
\theorembodyfont{\normalfont}
\theoremheaderfont{\normalfont\bfseries}

% Das Ende von Umgebungen, für die kein Beweis erbracht wurde, soll mit einer
% leeren Box gekennzeichnet werden. Wenn jedoch ein Beweis erbracht wurde,
% soll kein Zeichen ausgegeben werden (die ausgefüllte Box vom proof wird
% verwendet); man beachte die spezielle Definition von \theoremheaderfont für
% die Umgebung proof
% \newboolean{hasproof}
% \theoremheaderfont{\global\hasprooffalse\normalfont\bfseries}
% \theoremsymbol{\ifthenelse{\boolean{hasproof}}{}{\ensuremath{_\Box}}}

% Die folgenden Umgebungen werden einzeln nummeriert und am Ende jedes
% Kapitels zurückgesetzt
\newtheorem{satz}{Satz}[chapter]
\newtheorem{lemma}{Lemma}[chapter]
\newtheorem{thrm}{Theorem}[chapter]
\newtheorem{bemerk}{Bemerkung}[chapter]
\newtheorem{defini}{Definition}[chapter]
\newtheorem{bsp}{Beispiel}[chapter]
\newtheorem{festl}{Festlegung}[chapter]

% Die folgenden Theoremumgebungen bekommen keine Nummer
\theoremstyle{nonumberbreak}
\newtheorem{fakt}{Fakt}
\newtheorem{eigen}{Eigenschaften}
\newtheorem{folg}{Folgerung}
\newtheorem{beob}{Beobachtung}
\newtheorem{beha}{Behauptung}


% \theoremheaderfont{\global\hasprooftrue\scshape}
\theoremheaderfont{\scshape}
\theorembodyfont{\normalfont}
% Das Zeichen am Ende eines Beweises
\theoremsymbol{\ensuremath{_\blacksquare}}
% \theoremsymbol{q.\,e.\,d.}
\newtheorem{proof}{Beweis:}

% Hier die Definition, wie \autoref die Umgebungen nennen soll, die mit
% \newtheorem definiert wurden
\newcommand*{\satzautorefname}{Satz}
\newcommand*{\bemerkautorefname}{Bemerkung}
\newcommand*{\definiautorefname}{Definition}
\newcommand*{\bspautorefname}{Beispiel}
\newcommand*{\festlautorefname}{Festlegung}
% Zwischen Unter- und Unterunterabschnitten sollte nicht unterschieden
% werden.
\renewcommand*{\subsectionautorefname}{Abschnitt}
\renewcommand*{\subsubsectionautorefname}{Abschnitt}

\pagestyle{headings}

\newcommand*{\R}{\mathbb{R}}      % reelle Zahlen
\newcommand*{\C}{\mathbb{C}}      % komplexe Zahlen
\newcommand*{\N}{\mathbb{N}}      % natürliche Zahlen
\newcommand*{\Q}{\mathbb{Q}}      % gebrochene Zahlen
\newcommand*{\Z}{\mathbb{Z}}      % ganze Zahlen

% Wenn irgendwo Unklarheiten zum Inhalt im Skript auftreten, können sie
% einfach mit \help{Ich verstehe das nicht} hervorgehoben werden. Dies
% macht es leichter sie alle zu finden und auch ganz einfach
% auszublenden, indem man den Befehl einfach leer definiert
\newcommand*{\help}[1]{\textcolor{green}{help: #1}}

% \todo ist das gleiche wie \help nur für offene Aufgaben
\newcommand*{\todo}[1]{\textcolor{red}{todo: #1}}

% Um wichtige Begriffe im Text überall gleich vorzuheben (gleiches
% Markup), sollte dieser Befehl verwendet werden. Das Argument wird
% automatisch als Indexeintrag verwendet. Dieser kann aber auch als
% optionales Argument selbst bestimmt werden.
\newcommand*{\highl}[2][]{\textbf{\boldmath{#2}}%
  \ifthenelse{\equal{#1}{}}{\index{#2}}{\index{#1}}%
}

% Befehl für die Darstellung der Gliederungsüberschriften im Index
\newcommand*{\lettergroup}[1]{\minisec{#1}}

% Für Leute, die nicht gern o.\,B.\,d.\,A. jedesmal eintippen wollen
\newcommand*{\obda}{o.\,B.\,d.\,A.\xspace}

% Diese Befehle sind dafür gedacht, dass die Symbole für "genau dann wenn"
% im ganzen Dokument gleich aussehen. Außerdem erlaubt es eine schnelle
% Veränderung aller Stellen, falls der Prof. doch nicht mehr gdw nimmt,
% sondern \Leftrightarrow.
\newcommand*{\gdw}{\ifthenelse{\boolean{mmode}}%
			       {\mspace{8mu}gdw\mspace{8mu}}%
			       {$gdw$\xspace}}
\newcommand*{\gdwdef}{\ifthenelse{\boolean{mmode}}%
			       {\mspace{8mu}gdw_{def}\mspace{8mu}}%
			       {$gdw_{def}$\xspace}}

% Um sicherzustellen, dass jeder Betrag/jede Norm links und rechts die
% Striche bekommt, sind diese Befehle da. Damit kann man nicht die
% rechten Striche vergessen und es wird etwas übersichtlicher. Aus
% mathtools.pdf, z. B. \abs[\big]{\abs{a}-\abs{b}} \leq \abs{a+b}
\DeclarePairedDelimiter{\abs}{\lvert}{\rvert}
\DeclarePairedDelimiter{\norm}{\lVert}{\rVert}
\DeclarePairedDelimiter{\sprod}{\langle}{\rangle}

% Das original Epsilon sieht nicht so toll aus
\renewcommand*{\epsilon}{\varepsilon}
% ... und mancheinem gefällt auch das Phi nicht
\renewcommand*{\phi}{\varphi}

\DeclareMathOperator{\conv}{conv}      % konvexe Hülle

% Manchmal möchte man Begriffe erklären oder etwas aufzählen, das aber
% nicht fett gedruckt werden soll. Dazu diese Umdefinition einer
% description mit normaler Schrift
\newenvironment*{mdescription}%
                {\renewcommand*{\descriptionlabel}[1]%
 			       {\hspace\labelsep\normalfont ##1}%
		 \begin{description}}%
		{\end{description}}

\makeindex

\SVN $LastChangedRevision$
\SVN $LastChangedDate$

\begin{document}

\title{Algorithmische Geometrie}
\author{Joachim Giesen}
\date{Semester: WS 2008/09}
\maketitle

\clearpage
\chapter*{Vorwort}

{\itshape
  Dieses Dokument wurde als Skript für die auf der
  Titelseite genannte Vorlesung erstellt und wird jetzt im Rahmen des
  Projekts
  \enquote{\href{http://uni-skripte.lug-jena.de/}
  {Vorlesungsskripte der Fakultät für Mathematik}
  \href{http://uni-skripte.lug-jena.de/}{und Informatik}}
  weiter betreut. Das
  Dokument wurde nach bestem Wissen und Gewissen angefertigt. Dennoch
  garantiert weder der auf der Titelseite genannte Dozent, die Personen,
  die an dem Dokument mitgewirkt haben, noch die
  Mitglieder des Projekts für dessen Fehlerfreiheit. Für etwaige Fehler
  und dessen Folgen wird von keiner der genannten Personen eine Haftung
  übernommen. Es steht jeder Person frei, dieses Dokument zu lesen, zu
  verändern oder auf anderen Medien verfügbar zu machen, solange ein
  Verweis auf die Internetadresse des Projekts
  \url{http://uni-skripte.lug-jena.de/}
  enthalten ist.

  Diese Ausgabe trägt die Versionsnummer~\SVNLastChangedRevision{} und ist vom
  \SVNDate{}. Eine neue Ausgabe könnte auf der Webseite des Projekts verfügbar
  sein.

  Jeder ist dazu aufgerufen, Verbesserungen, Erweiterungen und
  Fehlerkorrekturen für das Skript einzureichen bzw. zu melden oder diese
  selbst einzupflegen -- einfach eine E-Mail an die
  \href{mailto:uni-skripte@lug-jena.de}{Mailingliste
  \nolinkurl{<uni-skripte@lug-jena.de>}} senden. Weitere Informationen
  sind unter der oben genannten Internetadresse verfügbar.

  Hiermit möchten wir allen Personen, die an diesem Skript mitgewirkt
  haben, vielmals danken:
  \begin{itemize}
   \item \href{mailto:sietschie@gmail.com}{Christoph Göring
    \nolinkurl{<sietschie@gmail.com>}} (Jahr)
  \end{itemize}
}

\clearpage
\pdfbookmark[0]{Inhaltsverzeichnis}{inhaltsverzeichnis}
\tableofcontents

\clearpage
\pdfbookmark[0]{Auflistung der Sätze}{theoremlist}
\chapter*{Auflistung der Theoreme}

\pdfbookmark[1]{Sätze}{satzlist}
\section*{Sätze}
\theoremlisttype{optname}
\listtheorems{satz}

\pdfbookmark[1]{Definitionen und Festlegungen}{definilist}
\section*{Definitionen und Festlegungen}
% \theoremlisttype{all}
\listtheorems{defini,festl}


%Inhalt:

%1. Grundlagen
%- Hyperebenen, Halbräume
%- Bälle
%- Konvexe Mengen

%2. Geometrische Prädikate
%- Floating point vs exakte arithmetik

%3. Konvexe Hüllen, Delaunay-Diagramme, Voronoi-Diagramme

%4. Flächenrekonstruktion im $R^3$ (selbst implementieren), Meshing

%5. Geometrische Datenanalyse
%- Alpha Shapes
%- Flow Shapes



\chapter{Grundlagen}

\section{Affine Geometrie}

Voraussetzung: Lineare Algebra im $\R^d$

\begin{defini}[Affiner Unterraum]
Eine Teilmenge nennt man affiner Unterraum, wenn entweder $A = \emptyset$ oder $A$ ist ein \enquote{verschobener} linearer Unterraum.
Das heißt $A = V + L$, wobei $L$ ein linearer Unterraum des $\R^d$ ist und $v \in \R^d$ ein Vektor.
\end{defini}

\begin{bsp}

\begin{itemize}
\item Gerade in der Ebene
\item Gerade im $\R^d$
\item Ebene im $\R^3$
\end{itemize}
\end{bsp}

\begin{defini}[Dimension]
$\operatorname{dim } A = - 1$ falls $A = \emptyset$ und $\operatorname{dim } L$ sonst (Dimension des linearen Unterraums).
\end{defini}

\begin{defini}[Affine Kombination von Punkten]
Seien $p_1, p_2, \dotsc, p_n \in \R^d, n \geq 1$ und 
$\lambda_1, \dotsc, \lambda_n \in \R$
mit $\sum_{i=1}^n \lambda_i = 1$
dann nennt man \[\lambda_1 p_1 + \lambda_2 p_2 + \dotsb + \lambda_n p_n\]
eine affine Kombination der Punkte $p_i$.
\end{defini}

\begin{defini}[Affine Hülle]
Sei $S \subseteq \R^d$.
Dann nennt man 
\[\operatorname{aff}(S) := \{  \lambda_1 p_1 + \lambda_2 p_2 + \dotsb + \lambda_n p_n \text{ mit } n \geq 1,
p1, \dotsc ,p_n \in S,
\lambda_1,\dotsc, \lambda_n \in \R
\sum_{i=1}^n \lambda_i = 1 \}\]
affine Hülle von S.
\end{defini}

\begin{eigen}
Die affine Hülle ist die kleinste affine Unterraum, der $S$ enthält.
\end{eigen}

\begin{bsp}
\begin{itemize}
\item affine Hülle von 2 Punkten $p_i \neq p_j \in \R^3$ ist die Gerade durch beide Punkte.
\item affine Hülle von 3 Punkten paarweise verschiedenen Punkten $p_1$, $p_2$ und $p_3 \in \R^3$ ist die Ebene durch alle drei Punkte
\end{itemize}
\end{bsp}

\section{Affine Abhängigkeiten/Unabhängigkeiten}

\begin{defini}[Affine Abhängigkeit]
Punkte $p_1,\dotsc, p_n \in \R^d$ heißen affin abhängig, wenn es $\alpha_1,\dotsc, \alpha_n \in \R$ gibt, so dass gilt:
\[\alpha_1 p_1 + \alpha_2 p_2 + \dotsb + \alpha_n p_n = 0 \text{ mit }
\sum_{i=1}^n \alpha_i = 0 \text{ und mind. ein } \alpha_i \neq \emptyset.\]
Ansonsten heißen die Punkte affin unabhängig.
\end{defini}


\begin{bsp} 
\begin{itemize}
\item Zwei Punkte $p_1$ und $p_2 \in \R^2$ affin unabhängig, wenn die Gerade durch beide Punkte nicht durch den Ursprung geht.
\item drei Punkte auf einer Gerade sind affin abhängig.
\end{itemize}
\end{bsp}

\begin{bemerk}
$p_1,\dotsc, p_n$ sind affin abhängig ($n \geq 3$) gdw. $p_2 - p_1, p_3 - p_1, \dotsc, p_n - p_1$ linear abhängig sind.
\end{bemerk}

\section{Affine Abbildung}

\begin{defini}[Affine Abbildung]
Eine affine Abbildung ist eine Abbildung $f \colon \R^d \rightarrow \R^k$, die als Kombination von linearer Abbildung und Translation ausgedrückt werden kann, d.\,h. in Koordinatenschreibweise kann $f$ als
\[f(x) = Ax + b \text{ mit } A \in \R^{k \times d} (k\times d-\text{Matrix}), b \in \R^k\]
aufgeschrieben werden.
\end{defini}


\section{Euklidische Räume}
$\R^d$

\begin{defini}{Skalarprodukt}
$v = (v_1, v_2, \dotsc, v_d) \in \R^d$ und $w = (w_1, w_2, \dotsc, w_n) \in \R^d$
\[\sprod{v,w} := v^Tw = \sum_i=1^d v_i w_i\]
\end{defini}

\begin{eigen}
\begin{itemize}
\item symmetrisch: $\sprod{v,w} = \sprod{w,v}$
\item bilinear: $\sprod{\alpha v + \beta u, w} = \alpha\sprod{v,w} + \beta \sprod{u,w}$ und $\sprod{v,\alpha w + \beta u} = \alpha\sprod{v,w} + \beta \sprod{v,u}$

\item nichtnegativ: $\sprod{v,v} \geq 0$, $\forall v \in R^d$
und $\sprod{v,v} = 0 $ gdw. $v = 0$
\end{itemize}
\end{eigen}

wegen dieser Eigenschaften induziert das Skalarprodukt eine Norm:
\begin{defini}[euklidische Norm]
\[\norm{v} := \sqrt{\sprod{v,v}}, v \in \R^d \]
\end{defini}

\begin{eigen}
\begin{itemize}
\item $\norm{v} \geq 0$ und $\norm{v} = 0 \gdw v = 0$
\item $\norm{\lambda v} = \abs{\lambda} \norm{v} \text{ für } \lambda \in R, v \in \R^d$
\item $\norm{v+w} \leq \norm{v} + \norm{w} \text{ mit} v,w \in \R^d$ (Dreiecksungleichung)
\end{itemize}
\end{eigen}

Cauchy-Schwarz-Ungleichung
\[\abs{\sprod{v,w}} \leq \norm{v} \cdot \norm{w}, \forall v,w \in R^d\]

Winkel zwischen zwei Vektoren (kleiner Winkel)
$v,w \in R^d$: 
\[\cos(\alpha) = \frac{\sprod{v,w}}{\norm{v} \cdot \norm{w}}\]

\begin{satz}[Kosinussatz]
$p,q,r \in \R^d$:
\[{\norm{q - r}}^2 = {\norm{q-p}}^2 + {\norm{r-p}}^2 - 2 \sprod{r-p, q-p}\]
\end{satz}

\begin{defini}[Hyperebenen]
Ein affiner Unterraum mit Codimension 1 im $\R^d$.
\[h := \{ x \in \R^d | a^Tx = \alpha  \text{ für } a \in \R^d, \alpha \in \R\}\]
\end{defini}

\begin{bsp}
\begin{itemize}
\item Ebene im $\R^3$ = Hyperebene
\item Gerade im $\R^2$ ist Hyperebene
\end{itemize}
\end{bsp}

\begin{eigen}
\begin{itemize}
\item Vektor $a$ heißt Normalenvektor. Er steht senkrecht auch Hyperebene, d.\,h. \[\forall p,q \in h\colon \sprod{a,p-q} = 0\]
\item Entfernung von $h$ zum Ursprung $ = \frac{\abs{\alpha}}{\norm{a}}$
\item $h$ ist invariant unter Skalierung der definierten Gleichung mit Skalar $\lambda \neq 0$
\end{itemize}
\end{eigen}

\section{Halbräume}

\begin{defini}[offener Halbraum]
Jede Hyperebene teilt den Raum $\R^d$ in drei Teile, die Hyperebene und die zwei offenen Halbräume:
\[ h^+ := \{x \in \R^d | a^Tx > a\} \text{ -- positiv offener Halbraum} \]
\[ h^- := \{x \in \R^d | a^Tx < a\} \text{ -- negativ offener Halbraum} \]
\end{defini}

\begin{bemerk}
positiver und negativer Halbraum sind durch die Orientierung der Hyperebene bestimmt.
\end{bemerk}

\begin{defini}[geschlossener Halbraum]
\[ \bar{ h^+} := \{x \in \R^d | a^Tx \geq a\} \text{ -- positiv offener Halbraum} \]
\[ \bar h^- := \{x \in \R^d | a^Tx \leq a\} \text{ -- negativ offener Halbraum} \]
\end{defini}

Konventionen: 
nicht-vertikale Hyperebene: Hyperebene mit $a_d \neq 0$ heißt nicht-vertikal (Die letzte Komponente ist nicht ungleich 0)

\begin{itemize}
\item $h^+$ -- Halbräume \enquote{über} der Hyperebene
\item $h^-$ -- Halbräume \enquote{unter} der Hyperebene
\end{itemize}

\begin{gather*} 
\begin{split}
h &= \{x \in \R^d | a^Tx = \alpha\} \\
&= \{x \in \R^d | (a_1, a_2, \dotsc, a_d)^Tx = \alpha\} (\text{mit } a_d \neq 0)\\
&= \{x \in \R^d | a_1 x_1 + a_2x_2 + \dotsb +a_d x_d = \alpha\}  \\
&= \{x \in \R^d | x_d = \frac{1}{a_d} (a_1x_1 + a_2x_2 + \dotsb + a_{d-1} x_{d-1} - \alpha)\}  \\
&= \{x \in \R^d | x_d = b_1x_1 + b_2x_2 + \dotsb + b_{d-1} x_{d-1} - \beta\}  \\
&= \text{ Graph einer affinen Abbildung } \R^{d-1} \rightarrow \R
\end{split}
\end{gather*}

\section{Dualität zwischen Punkten und Hyperebenen}
beliebiger Punkt aus $\R^d$ entspricht nicht-vertikale  Hyperebene im $\R^d$

\begin{defini}[Dualität]
Sei $p = (p_1, p_2, \dotsc, p_d) \in \R^d$, dann ist 
\[p^* = \{ x \in \R^d | x_d = \sum_{i=1}^{d-1} p_i x_i = p_d \}\] 
die duale Hyperebene zu $p$.

Sei $h = \{x \in \R^d | x_d = \sum_{i = 1}^{d-1}  b_i x_i = \beta\}$, dann ist 
\[h^* = (b_1, b_2, \dotsc, b_{d-1}, \beta)\] der duale Punkt zu $h$.
\end{defini}

\begin{eigen}
$(p^*)^* = p$, $(h^*)^* = h$
\end{eigen}

\begin{bsp}
$p = (1,2), q = (2,3), r = (3,4)$
\begin{figure}[htbp]
\begin{center}
\includegraphics{grafiken/grafik1}
%\caption{default}
\label{grafik1}
\end{center}
\end{figure}

\begin{gather*}
\begin{split}
p^* &= \{x \in R^2 | x_2 = 1 x_1 - 2\} \\
q^* &= \{x \in R^2 | x_2 = 2 x_1 - 3\} \\
r^* &= \{x \in R^2 | x_2 = 3 x_1 - 4\}
\end{split}
\end{gather*}

\begin{figure}[htbp]
\begin{center}
\includegraphics{grafiken/grafik2}
%\caption{default}
\label{grafik2}
\end{center}
\end{figure}

Die drei gerade schneiden sich bei Punkt $(1, -1)$. Dessen duale Ebene ist genau die, die durch die drei Punkte geht. 
\end{bsp}

\begin{lemma}
Es gilt für alle $p$ und alle nicht-vertikalen Hyperebenen $h$:
\[
p \in \begin{cases} 
h^+ \\ 
h^- \\ 
h 
\end{cases} 
\text{ gdw } h^* = \begin{cases} (p^*)^+ \\ (p^*)^- \\ p* \end{cases}
\]
\end{lemma}

\begin{lemma}
Seien $p,q$ und $r \in \R^2$, dann sind folgende Aussagen äquivalent:
\begin{itemize}
\item Die Punkte $p$,$q$ und $r$ sind colinear, d.\,h. liegen auf einer Gerade $l$
\item Die Geraden $p^*, q^*$ und $r^*$ schneiden sich in einem gemeinsamen Punkt $l^*$ oder sie sind alle parallel zueinander, falls $l$ vertikal war.
\end{itemize}
\end{lemma}

\section{Eigenschaften konvexer Mengen}

\begin{defini}
Konvexe Menge: Eine Menge $K \subseteq \R^d$ heißt konvex, falls für alle $p,q \in K$ und alle $\lambda \in [0,1]$ gilt: \[ \lambda p + (1 - \lambda) q \in K \]
\end{defini}

Geometrische Interpretation: Wenn zwei Punkte in der Menge liegen, dann muss auch das verbindende Geradensegment in der Menge liegen.

\begin{bsp}
Kreis ist konvex, Banane nicht
\end{bsp}

\begin{fakt}
Der Durchschnitt konvexer Mengen ist wieder Konvex.
\end{fakt}

\begin{defini}
Sei $X \subseteq \R^d$ eine Teilmenge. Die konvexe Hülle~$\conv(X)$ von $X$ ist
  definiert als der Durchschnitt aller konvexer Mengen, die $X$ enthalten, d.\,h.
\[
  \conv(X) := \bigcap_{\substack{C \supset X\\C\text{ konvex}}} C
\]
\end{defini}

\begin{bsp}
Das kleinste konvexe Objekt, dass $X$ enthält.
\end{bsp}

\begin{defini}[Konvexkombination]
 Sei $p_{1},\dotsc, p_{n} \in \R^d$, dann heißt 
\[\lambda_{1} p_{1} + \lambda_{2}p_{2} + \dotsb + \lambda_{d}p_{d}\text{ mit } \lambda_{i} \geq 0, \sum_{i=1}^n \lambda_i = 1\] 
eine Konvexkombination von $p_{1}, \dotsc, p_{d}$. 
\end{defini}

\begin{bsp}
Jede Kombination liegt innerhalb der von den Punkten aufgespannten konvexen Hülle.
\end{bsp}  

\begin{lemma}
Sei $X \subseteq \R^d$. Die konvexe Hülle stimmt mit der Menge aller endlichen Konvexkombinationen von Punkten von $X$ überein, d.\,h. 
\[
\conv(x) = \{ \sum_{p \in S} \lambda_{p} p | S \subseteq X\text{ ist endlich und } \sum_{p \in S} \lambda_{p} = 1, \lambda_{p} \geq 0 \forall p \in S\}
\]
\end{lemma}

\section{Konvexe Hüllen von Punktmengen}

\begin{lemma}
Sei $X \in R^d$ endlich. Dann gilt: \[
\conv(x) = \bigcap_{H\text{, so dass }X \subseteq H, H\text{ Halbraum}} H
\]
\end{lemma}

\begin{thrm}[Separationstheorem]
Seien $C$ und $D \in \R^d$ zwei konvexe Mengen, mit $C \cap D = \emptyset$. Dann existiert eine Hyperebene $h = \{ x \in \R^d | a^Tx = \alpha \}$, die beide Mengen schwach separiert, d.\,h. $C \subseteq \bar h^+$ und $D \subseteq \bar h^-$
\end{thrm}

\begin{fakt}
  Wenn $C$ und $D$ abgeschlossen sind und wenigstens eine Menge beschränkt ist,
  so können beide Mengen stark separiert werden, d.\,h. $C
\subseteq h^+$ und $D \subseteq h^-$.
\end{fakt}

\begin{lemma}[Radon]
Sei $S\subseteq \R^d$ mit $\abs{S} \geq d+2$. Dann existieren zwei disjunkte Teilmengen $A$ und $B \subseteq S$, so dass: \[
\conv(A) \cap \conv(B) \neq \emptyset
\]
\end{lemma}

\begin{bsp}
Wenn im $\R^2$ 4 Punkte gegeben sind, so können diese so in zwei Teilmengen unterteilt werden, dass der Schnitt der konvexen Hüllen nicht leer ist.
\end{bsp}

\begin{thrm}[Caratheodory]
Falls $S \subseteq \R^d, p \in \conv(S)$ gilt, so existiert eine Teilmenge $A \subseteq S$ mit $\abs{A} \leq d+1$, so dass $p \in \conv(A)$.
\end{thrm}

\begin{thrm}[Helly] 
Seien $C_{1}, \dotsc, C_{n} \in \R^d$ konvexe Teilmengen und $n \geq d + 1$.
Wenn sich alle $d+1$-Tupel dieser konvexen Mengen einen nichtleeren Durchschnitt haben, so ist der Durchschnitt aller dieser Mengen nichtleer, d.\,h. \[
\bigcap_{i=1}^n C_{i} \neq \emptyset
\]
\end{thrm}

\section{Bälle im \texorpdfstring{$\R^d$}{|R hoch d}}

\begin{defini}[Bälle]
Sei $c \in \R^d$, $r \in R_{\geq 0}$. 

Dann heißt die Menge \[
B_{d}(c,r) := \{x \in \R^d | \norm{x - c} \leq r\}
\]
\end{defini}



\chapter{Voronoi Diagramme \& Delaunay Triangulierung}

$P \subset \R^d$ ist endlich

\begin{defini}[Nicht-degeneriert]
\begin{itemize}
\item  Die affine Hülle von Punkten aus $P$ ist homeomorph zu, $\R^{k-1}$. 
%(Bei 2 Punkten auf Linie - > degeneriert)
\item Keine $d+2$ Punkte liegen auf gemeinsamer Sphäre
\end{itemize}
\end{defini}

%Warum degenieriert: degenerierte Fälle sind sehr instabil. %Wir betrachten zuerst Algorithmen ohne degenerierte Fälle.

\begin{bemerk}
Degenerierte Fälle sind sehr instabil.
Im Augenblich nehmen wir immer an, dass $P$ nicht-degeneriert ist. Später wird die Degeneriertheit explizit behandelt.
\end{bemerk}

\begin{defini}[Voronoi-Zelle]
$p \in P$
\[  V_p = \{ x \in \R^d | \norm{x-p} \leq \norm{x-q} \quad \forall q \in P \}\]
\end{defini}

\begin{figure}
\begin{center}
 \includegraphics[width = 0.5\textwidth]{grafiken/voronoi}
\end{center}
\caption{Voronoi-Diagramm}
\end{figure} 


\begin{defini}[Bisektor] 
$p,q \in P$		
\[B_{p,q} = \{x \in \R^d | \norm{y-p} = \norm{x-q} \}\]
\end{defini}

\begin{folg}
 

\begin{gather*}
\begin{split}
x \in B_{p,q}& \Leftrightarrow  \norm{y-p} = \norm{x-q} \\
& \Leftrightarrow \norm{y-p}^2 = \norm{x-q}^2 \\
& \Leftrightarrow \norm{x}^2 - 2x^tp + \norm{p}^2 = \norm{x}^2 - 2x^Tq + \norm{q}^2 \\
& \Leftrightarrow (q-p)^Tx + \frac{1}{2} (\norm{p}^2 - \norm{q}^2) = 0 
\end{split}
\end{gather*}

Falls $p \neq q$: Ursprungsvermeidende Hyperebene
\end{folg}

\begin{fakt}
\begin{itemize}
\item  $V_p$ ist der Schnitt von Halbräumen mit Rand $B_{p,q}$.
\item $V_p$ ist konvex.
\end{itemize}
\end{fakt}

\begin{defini}[Voronoi-Face]
Ein $k$-dimensionales Voronoi-Face ist der Schnitt von $d+1-k$ Voronoi-Zellen, falls dieser Schnitt nicht leer ist. 
\end{defini}

\begin{folg}
Alle Punkte in einem $k$-dimensionalen Voronoi-Face (Voronoi $k$-Face) sind gleich abständig zu $d+1-k$ Punkten in $p$.
\end{folg}

\begin{defini}[Voronoi-Diagramm] 
Zellkomplex, der von den Voronoi-Faces gebildet wird.
\end{defini}

\begin{figure}
\begin{center}
 \includegraphics[width = 0.6\textwidth]{grafiken/delaunay-triangulierung}
\end{center}
\caption{Delaunay-Triangulierung und ihr duales Voronoi-Diagramm}
\end{figure} 

\begin{defini}[Delaunay-Triangulierung]
\[D(P) = \{ \sigma = \operatorname{conv}(T) | \bigcap_{p \in T \subseteq P} V_p \neq \emptyset \}\]
%\todo{Rausfinden, was da fehlt. Das stimmt doch so nicht. }
\end{defini}



\begin{defini}[Voronoi-Delauny-Dualität]
Wenn $k+1$ Voronoi Zellen einen nicht-leeren gemeinsamem Schnitt haben, definieren sie 
\begin{itemize}
\item k-dimensionalen Delaunay-Simplex
\item $(d-k)$-dimensionales Voronoi-Face.
\end{itemize}
Delaunay-Simplex und Voronoi-Face sind dual zueinander.
\end{defini}

In der Ebene $\R^2$:

\begin{tabular}{|l|l|}
\hline
Delaunay & Voronoi \\ 
\hline
Vertex & Zelle \\ 
Kante & Kante \\
Dreieck & Voronoi-Knoten/Vertex \\
\hline
\end{tabular}


\begin{defini}[Power-Diagramme]
$(p,wp) \in P \subseteq \R^d \times \R$
\[\pi_p \colon \R^d \rightarrow	\R, x \mapsto  \norm{x-p}^2 - wp\]
$p$ ist Punkt und $w_p$ sein Gewicht. Verallgemeinerung von Voronoi-Diagrammen.
\end{defini}


Falls $w_p > 0$ folgende Interpretation:
\todo{Bild}

\begin{defini}[Power-Zelle]
$(p,w_p) \in P$
\[V_p = \{ x \in \R^d | \pi_p(x) \leq \pi_q(x)	\qquad	\forall(q,w_q) \in P \}\]
\end{defini}

\begin{defini}[Power-Bisektor]
$(p,w_p), (q,w_q) \in P$
\[B_{p,q} = \{ x \in R^d | \pi_p(x) = \pi_q(x) \} \]
\end{defini}



\begin{folg}
\begin{gather*}
\begin{split}
x \in B_(p,q)& \Leftrightarrow \pi_p(x) = \pi_q(x) \\
& \Leftrightarrow \norm{x-p}^2 - w_p = \norm{x-q}^2 - w_q \\
& \Leftrightarrow	\norm{x}^2 - 2x^Tp + p^2 - w_p = \norm{x}^2 - 2x^Tq + \norm{q}^2 - w_q \\
& \Leftrightarrow (q-p)^Tx + \frac{1}{2} (\norm{p}^2 - \norm{q}^2 - w_p + w_q) = 0 
\end{split}
\end{gather*}
Das ist für $p \neq q$ eine Ursprungsvermeidende Hyperebene.
\end{folg}

\begin{bemerk}
Mögliche Anwendung von Power Diagrammen:
$P = \{(p,w_p)\}$ Menge von Atomen mit Zentrum $p$ und Van der Waals-Radius $w_p$.
\end{bemerk}

\begin{defini}[Power-Faces]
Genauso wie Voronoi-Faces
\end{defini}

\begin{defini}[Power-Diagramm] 
Komplex der von den Power Faces gebildet wird.
\end{defini}

Gewichtete Delaunay Triaungulierung dual zum Power Diagramm (genauso wie Delaunay dual zu Voronoi)
 

\section{Berechnung von Delaunay Triangulierungen in der Ebene}
 
\begin{defini}[Umschreibender Ball eines Simplex]
Ball der alle Knoten des Simplex auf seinem Rand hat.
\end{defini}

\begin{beob}
Der umschreibende Ball für einen $d$-Simplex im $\R^d$ ist eindeutig.
\end{beob}
 

\begin{defini}[lokale Delaunay-Eigenschaft]
Sei $T$ eine Triangulierung von $P$, wobei $P$ eine ungewichtete Punktemenge im $\R^2$ sei.
$T$ hat die lokale Delaunay-Eigenschaft falls jede Kante der Triangulierung entweder
\begin{enumerate}
\item eine inzidentes Dreieck hat. (D.\,h. Kante ist auf dem Rand der komplexen Hülle von $T$)
\item Kante hat 2 inzidente Dreiecke $abc$ und $bcd$ hat, so dass der umschreibende Ball von $abc$ den Punkt $d$ nicht enthält.
\end{enumerate}
\end{defini}

\begin{figure}
\begin{center}
 \includegraphics[width = 0.8\textwidth]{grafiken/delaunayeigenschaft}
\end{center}
\caption{lokale Delaunay-Eigenschaft}
\end{figure} 


\begin{satz}
Wenn in einer Triangulierung $T$ von $P$ jede Kante die lokale Delaunay-Eigenschaft hat, dann ist $T$ eine Delaunay-Triangulierung.
\end{satz}

\begin{folg}
Algorithmus der versucht, die lokale Delaunay-Eigenschaft herzustellen, indem er verletzende Kanten flipt.
\end{folg}

\begin{proof}
Idee:
Für jedes Dreieck $abc$ in der Triangulierung gilt: Die umschließende Kreisscheibe enthält keinen Punkt von $P$ im Innern.

Voronoi-Vertex:
\begin{enumerate}
 \item Schnitt der Voronoi-Zellen von $a,b,c$ nichtleer
 \item $abc$ (Konvexe Hülle von $a,b$ und $c$) ist Delaunay
\end{enumerate}

Sei $p \in P \setminus \{a,b,c\}$ und
$q$ beliebig in Umkreisscheibe.
Das Liniensegment $qp$ schneidet Dreiecke $t_1, t_2, \dotsc, t_k$ der Triangulierung.
Dazu folge von gewichteten Punkten $S_1, S_2, \dotsc, S_k$ mit Gewichten $w_1, w_2, \dotsc, w_k$
$w_i = \text{Radius der Umkreisscheibe von} t_i$
Damit ergeben sich eine Folge von Power-Abständen $\Pi_1(p), \dotsc, \Pi_k()$

\todo{wo kommen die Sks her?}

\begin{beob}
\begin{enumerate}
\item Der Power-Abstand ist
\begin{itemize}
 \item 	negativ, falls innerhalb der Kreisscheibe
 \item 	$0$, falls auf Rand der Kreisscheibe
 \item 	positiv, falls außerhalb der Kreisscheibe
\end{itemize}

\item auf der geraden der gemeinsamen Kante von $t_i$ und $t_{i+1}$ gilt $\Pi_i = \Pi_{i+1}$. (Wegen $\Pi_i(x) = \Pi_{i+1}(x) = \Pi_i(y) = \Pi_{i+1}(y) = 0$)
Außerdem gilt $\Pi_i < \Pi_{i+1}$ links vom Power-Bisektor bzw. $\Pi_i < \Pi_{i+1}$ rechts vom Power-Bisektor.

\includegraphics[width=0.3\textwidth]{grafiken/power-bisektor}

\item $p$ ist Knoten von $t_k$. Daraus folgt $\Pi_k(p) = 0 \rightarrow \Pi_{k+1}(p) > 0 \rightarrow \Pi_{1}(p) > 0$.
Das bedeutet $p \notin \text{ Umkreisscheibe von } t_1 = abc$ 
\todo{wieso folgt das?}
\end{enumerate}
\end{beob}
Aus Punkt 3 der Beobachtung folgt also die Behauptung.
\end{proof}

Lawson-Flip
Wann immer $bc$ nicht die lokale Delaunay-Eigenschft hat, dann ``flippen'' der Kante zu $ad$.
d.\,h. in Triangulierung tauschen wir die Dreiecke $abc$ und $bcd$ aus durch $abd$ und $adc$.

\includegraphics[width=0.3\textwidth]{grafiken/flip}


Der Lawson-Flip-Algorithmus muss entscheiden, ob $bc$ die lokale Delaunay-Eigenschaft hat, d.\,h. ob $d$ in der Umkreisscheibe von $abc$ enthalten ist. Dazu benötigt man den IN\_CIRCLE\_TEST.


\begin{satz}[Lifted Circle Claim]
Dazu Hochhebungsabbildung:
\begin{gather*}
h \colon \R^2 \rightarrow \R^3 \\
(x,y) \mapsto (x,y,x^2 + y^2) 
\end{gather*}


Seien $p,q,r \in \R^2$. 

$s\in \R^2$ ist
\begin{enumerate}
 \item  auf dem Rand der umschließenden Kreisscheibe genau dann, wenn $h(s) \in \operatorname{aff}(h(p), h(q), h(r))$ gilt
 \item Innerhalb der Kreisscheibe, falls $h(s)$ Vertikal unterhalb von $\operatorname{aff}(h(p), h(q), h(r))$ liegt.
 \item Außerhalb der Kreisscheibe sonst
\end{enumerate}
\end{satz}

\begin{proof}
Spezialfall:
Der Mittelpunkt der Kreisscheibe von $p,q$ und $r$ ist Ursprung.

\begin{beob}
\begin{enumerate}
 \item dritte Komponente des gelifteten Punktes ist der quadratische Abstand des Punktes vom Ursprung
 \item $p$, $q$ und $r$ haben alle den gleichen Abstand zum Ursprung
$\rightarrow$ $\operatorname{aff}(h(p), h(q), h(r))$ ist Ebene parallel zur $x,y$-Ebene, die das Parabol in einem Kreis schneidet
\end{enumerate}
\end{beob}

Sei $s$ Punkt auf dem Rand der umschließenden Kreisscheibe von $p$, $q$ und $r$
\[
\begin{pmatrix}
 s_x \\ s_y \\ s_x^2 + s_y^2 \\ 1
\end{pmatrix}
= \lambda 
\begin{pmatrix}
 p_x \\ p_y \\ p_x^2 + p_y^2 \\ 1
\end{pmatrix}
+
\mu 
\begin{pmatrix}
 q_x \\ q_y \\ q_x^2 + q_y^2 \\ 1
\end{pmatrix}
+\rho 
\begin{pmatrix}
 r_x \\ r_y \\ r_x^2 + r_y^2 \\ 1
\end{pmatrix}
\]
$\lambda, \mu, \rho \in \R$
Verwendung von Homogenen Koordinaten um die Bedingung $\lambda + \mu + \rho = 1$ sicherzustellen.

Allgemeiner Fall:
Der mittelpunkt der Kreisscheibe von $p$,$q$ und $r$ ist $t \neq 0$.
Translation der Konfiguration mit $t$.
%\todo{bild einfügen}

\begin{gather*}
\begin{split}
\begin{pmatrix}
 s_x + t_x \\ s_y + t_y \\ (s_x + t_x)^2 + (s_y + t_y)^2 \\ 1
\end{pmatrix}
= & \lambda 
\begin{pmatrix}
 p_x + t_x \\ p_y + t_y \\ (p_x + t_x)^2 + (p_y + t_y)^2 \\ 1
\end{pmatrix} 
+ \mu 
\begin{pmatrix}
 q_x + t_x \\ q_y + t_y \\ (q_x + t_x)^2 + (q_y + t_y)^2 \\ 1
\end{pmatrix}\\
 + & \rho 
\begin{pmatrix}
 r_x + t_x \\ r_y + t_y \\ (r_x + t_x)^2 + (r_y + t_y)^2 \\ 1
\end{pmatrix}
\end{split}
\end{gather*}

Nachrechnen der dritten Komponente:
\begin{gather*}
\begin{split}
2s_xt_x + t_x^2 + 2s_yt_y + t_y^2 = & \lambda(2p_xt_x + t_x^2 + 2p_yt_y + t_y^2) + \mu(2q_xt_x + t_x^2 + 2q_yt_y + t_y^2) + \\ 
& \rho(2r_xt_x + t_x^2 + 2r_yt_y + t_y^2)
\end{split}
\end{gather*}
daraus folgt
\begin{gather*}
\begin{split}
s_xt_x + s_yt_y = & \lambda(p_xt_x + p_yt_y) + \mu(q_xt_x + q_yt_y) + \rho(r_xt_x + r_yt_y) \\
 = & t_x(\lambda p_x + \mu q_x + \rho r_x) +  t_y(\lambda p_y + \mu q_y + \rho r_y) \\
= & t_xs_x + t_ys_y
\end{split}
\end{gather*}

\[
h(s+t) \in \operatorname{aff}(h(p+t), h(q+t), h(r+t))
\]
Daraus folgt die Behauptung, da $s$ beliebig auf Rand gewählt war.
\end{proof}

Berechnung des IN\_CIRCLE-Prädikats durch die Determinante:
\[ \Gamma = \begin{vmatrix} 
1 & p_x & p_y & p_x^2 + p_y^2 \\ 
1 & q_x & q_y & q_x^2 + q_y^2 \\ 
1 & r_x & r_y & r_x^2 + r_y^2 \\ 
1 & s_x & s_y & s_x^2 + s_y^2  
\end{vmatrix}
\]

Determinante verschwindet genau dann, wenn $s$ im Rand der umschließenden Kreisscheibe von $p$,$q$ und $r$ ist. (Die Determinante ist $0$, wenn die Punkte affin abhängig sind.)

\[ \Delta = \begin{vmatrix} 
1 & p_x & p_y \\ 
1 & q_x & q_y \\ 
1 & r_x & r_y 
\end{vmatrix}
\]
Mit der Matrix $\Delta$ heben sich Vorzeichenwechsel der Determinante bei Permutation gegenseitig auf.

\begin{lemma}
Ein Punkt $s \in R^2$ liegt im Inneren der umschließenden Kreisscheibe von $p$, $q$ und $r$ genau dann, wenn das Produkt aus $\Delta$ und $\Gamma$ negativ ist. ($\Delta \Gamma < 0$)
\end{lemma}

\begin{proof}
 Spezialfall:
$p = (0,0)$, $q = (1,0)$, $r = (0,1)$ und $s = (\frac{1}{4},\frac{1}{4})$ 
Damit ist $\Delta = 1$ und $\Gamma < 0$

Idee der stetige Bewegung:

Führe $p$, $q$, $s$ und $r$ stetig von Situation in Spezialfall über, wobei degenerierte Situationen vermieden werden müssen. Dies funktioniert wegen der Stetigkeit der Determinante.
\end{proof}


\subsection{Lawsons-Flip-Algorithmus}

Idee: Wenn immer eine Kante $bc$ nicht die lokale Delaunay-Eigenschaft hat, dann \enquote{Flip} zu ab

\begin{algorithm}
    \dontprintsemicolon
    \caption{Der Lawson-Flip-Algorithmus}
    \KwIn{$T$ Triangulierung}
    \KwOut{Delaunay-Triangulierung}
	\ForEach{Kante $e \in T$}{
		Markiere $e$\;
		PUSH $e$ auf den Stack s\;
	}
	\While{$S \neq \emptyset$}{
		$(b,c)$ = S.pop()\;
		entferne Markierung von $(b,c)$\;
		\If{$(b,c)$ hat nicht die lokale Delaunay-Eigenschaft}{
			FLIP $(b,c)$ zu $(a,d)$\;
			\For{ $(x,y) \in \{ac,cd,db,ba\}$}{
				\If{ $(x,y)$ nicht markiert ist}{
					markiere $(x,y)$\;
					S.push(x,y)\;
				}
			}
		}
	}
  \end{algorithm}

%Algorithmus:

%Lawsons Flip (T Triangulierung)
%FOR EACH e KANTE IN T DO
% 	MARKIERE c
% 	PUSH e AUF DEN STACK S
% END FOR
% 
% WHILE $S \neq \emptyset$ DO
% 	$(b,c)$ = S.pop()
% 	ENTFERNE MARKIERUNG VON $(b,c)$
% 	IF $(b,c)$ hat nicht die lokale Delaunay-Eigenschaft THEN
% 		FLIP $(b,c)$ zu $(a,d)$
% 		FOR $(x,y) \in \{ac,cd,db,ba\}$ DO
% 			IF $(x,y)$ NICHT MARKIERT IST DO
% 				MARKIERE $(x,y)$
% 				S.push(x,y)
% 			END IF
% 		END FOR
% 	END IF
% END WHILE


\begin{satz}
Der Lawson-Flip-Algorithmus terminiert
\end{satz}

\begin{proof}

\begin{beob}
Bei jedem Flip bleibt die Anzahl der Dreiecke in der Triangulierung die gleiche.
\end{beob}

\begin{defini}
Gewicht von Triangulierung $T$ ($= w(T)$) ist der Vektor aller Winkel, die in $T$ auftreten, aufsteigend geordnet.
\end{defini}
	
$T < T'$ falls $w(T) < w(T')$ (Lexikographischer Vergleich), $w(T)$ der Winkelvector	

\begin{beha}
 $w(t) < w(T')$ falls $T'$ aus $T$ durch einen Flip entsteht.
\end{beha}

\todo{Skizze davon einfügen: abc-Dreieck, d ist Punkt im Kreis}

\begin{gather*}
w(T) = \alpha_1 + \alpha_2, \beta_1, \beta_2, \gamma_1 + \gamma_2, \delta_1, \delta_2 \\
w(T') = \alpha_1,\alpha_2, \beta_1 +  \beta_2, \gamma_1, \gamma_2, \delta_1 +  \delta_2
\end{gather*}

Um zu zeigen $w(T) < w(T')$ benutzen wir den  Satz von Thales.

\includegraphics[width=0.3\textwidth]{grafiken/thales}

$\alpha_e > \alpha_d = \alpha_c > \alpha_f$

\todo{versteh das nicht.. evtl. Fehler beim abschreiben?}

Kante:
$qc: \beta_1 < \delta_2$
$bc: \gamma_2 < \delta_1$
$dc: \beta_2 < \alpha_1$
$bd: \gamma_1 < \alpha_2$

=>
$\beta_1, \beta_2 < \beta_1 + \beta_2$
$\gamma_2 < \delta_1$
$\beta_1 < \delta_2$
$\gamma_1, \gamma_2 < \gamma_1 + \gamma_2$
$\gamma_1 < \alpha_2$
$\beta_2 < \alpha_1$

D.\,h. für jeden Winkel aus $w(T)$ gibt es einen größeren n $w(T')$. Da die Anzahl der Triangulierungen endlich und das Maß immer ansteigend ist folgt daraus, dass der Algorithmus terminiert.
\end{proof}

\begin{satz}[Thales]
 Der Mittelpunktswinkel ist doppelt so groß wie der Umfangswinkel.
\end{satz}

\begin{proof}
Zuerst der einfache Basisfall bei dem der Mittelpunkt auf der Linie liegt:
Da die Dreiecke gleichschenklig sind, gilt für das Dreieck $amc$: $2x + \Pi - 2\alpha = \Pi$. Daraus folgt $x = \alpha$.

\includegraphics[width=0.3\textwidth]{grafiken/thales-einfach}

Der Fall, dass der Mittelpunkt im Dreieck enthalten ist: $\gamma + \beta = \alpha$

\includegraphics[width=0.3\textwidth]{grafiken/thales-mpenthalten}

Der Fall, das der Mittelpunkt nicht enthalten ist: $\beta + x = 2\beta + 2\gamma$. Daraus folgt wieder $x = \gamma$.

\includegraphics[width=0.3\textwidth]{grafiken/thales-nichtmpenthalten}

Der Trick in beiden Fällen: Betrachte Diagonale durch Punkt $m$ und argumentiere danach mit dem Basisfall.
\end{proof}


%Was fehlt noch: Eingabe des Lawson Flip Algorithmus. Die initiale Triangulierung.
%Jetzt kommt Algorithmus für konvexe Hülle. Dieser hat als Nebenprodukt eine Triangulierung.
\section{Konvexe Hülle in der Ebene \texorpdfstring{$\R^2$}{R hoch 2}}

$P \subset \R^2$:
Konvexe Hülle ist der Schnitt aller konvexen Mengen, die $P$ enthalten.

%$= \{ x = \sum \delta_i p_i | p_i \in P, \delta_i \geq 0, \sum \delta_i = 1\}$

\begin{defini}
 Extrempunkte sind Punkte aus P auf dem Rand der konvexen Hülle. %Also Punkte bei denen nur ein einziger Koeffizient 1 ist.
\end{defini}

Das algorithmische Ziel ist das Aufzählen der Extrempunkte entlang des Randes der Konvexen Hülle von P.
%im Uhrzeigersinn. ?
Dazu benötigen wir das Prädikat $\operatorname{IS\_LEFT\_OF}(p,q,r)$ das uns sagt, ob $r$ links von (auf, rechts) der geraden durch $p$ und $q$ liegt.

\begin{figure}
\begin{center}
 \includegraphics[width = 0.5\textwidth]{grafiken/isleftof}
\end{center}
\caption{IS\_LEFT\_OF-Prädikat}
\end{figure} 


%Algorithmus Jarvis Wrap:
%1. Ordne Punkte in P Lexikographisch nach (x,y) Koordinaten.
%....
\begin{algorithm}
    \dontprintsemicolon
    \caption{Der Jarvis-Wrap-Algorithmus}
    \KwIn{$P \subset \R^2$}
    \KwOut{Extrempunkte auf dem Rand der konvexen Hülle}
	$p :=$ Lexikographisch kleinster Punk in $P$\;
	$p' := p$\;
	\Repeat{$p = p'$}{
		q := beliebiger Punkt in $P\setminus \{p\}$\;
		\ForAll{$ r \in P\setminus\{p,q\}$}{
			\If{$\operatorname{IS\_LEFT\_OF}(p,q,r)$}{
				$q := r$\;
			}
		}
		Ausgabe von $q$\;
		$p:=q$\;
	}
\end{algorithm}

% PSEUDOCODE:
% p := Lexikographisch kleinster Punk in P
% p' := p
% DO
% 	q := beliebiger Punkt in $P\setminus \{p\}$
% 	FOR ALL$ r \in P\setminus\{p,q\}$
% 		IF $IS_LEFT_OF(p,q,r)$ THEN
% 			q := r
% 		END IF
% 	END FOR
% 	AUSGABE VON q
% 	p:=q
% WHILE ($p \neq p'$)


Kurze Kostenanalyse: 
\[
\text{Finden des lexik. kleinsten Elements} + h * (n-2) * \text{IS\_LEFT\_OF}
\]
$h$ ist die Anzahl der Extrempunkte.
Das bedeutet der Jarvis-Wrap-Algorithmus ist Output-Sensitiv, d.\,h. Laufzeit hängt von Anzahl der Extrempunkte ab.

\subsubsection{Implementierung des IS\_LEFT\_OF-Prädikats}
Falls $r \in \operatorname{aff}(p,q)$:
\[
\begin{pmatrix}
r_x\\
r_y\\
1
\end{pmatrix}
= \lambda
\begin{pmatrix}
p_x\\
p_y\\
1
\end{pmatrix}
+ \mu
\begin{pmatrix}
q_x\\
q_y\\
1
\end{pmatrix}
%				p_x			q_x
%	= \lambda		p_y	+ \mu	q_y	
%				1			1
\]

daraus folgt: $p$,$q$ und $r$ sind linear abhängig. Das bedeutet, die folgende Determinante ist $0$.
\[
\Delta = 
\begin{vmatrix}
1 & p_x & p_y \\
1 & q_x & q_y \\
1 & r_x & r_y
\end{vmatrix}
= 0
%		1	p_x	p_y
%\Delta = 	1	q_x	q_y	= 0
%		1	r_x	r_y
\]

Aus dem stetigen Bewegungs-Argument (z.\,B. mit Punkten $p = (1,0)$, $q = (0,1)$ und $r = (0,0)$) folgt:
$r$ ist links von der affinen Hülle, falls $\Delta > 0$. Argument folgt aus der Stetigkeit der Determinante. 

%Der Jarvis-Wrap algorithmus ist numerisch unstabil. Die Auswertung des Prädikats schlägt bei float-Werten relativ oft fehl, so dass die Gefahr einer endlosschleife besteht.

\subsection{Graham Scan Algorithmus}

Halbkanten-Datenstruktur:

Kante zwischen $p$ und $q$ wird gespeichert als zwei Halbkanten.

\begin{figure}
\begin{center}
 \includegraphics[width = 0.5\textwidth]{grafiken/halbkanten}
\end{center}
\caption{Halbkanten-Datenstruktur}
\end{figure} 


1. Sortiere Punkte in P lexikographisch. Verpointere die Punkte.

Starten beim kleinsten Punkte. Gehen zum übernächsten Punkt. (zweimal Next)
....
erst Untere und dann die Obere Konvexe Hülle.
Ergebnis ist insbesondere auch eine Triangulierung.


Halbkanten-Datenstruktur:
Jede Kante besteht aus zwei Einzelkanten. Jede Einzelkante erhält previous und next.

für planare Graphen.

\begin{algorithm}
    \dontprintsemicolon
    \caption{Der Graham-Scan-Algorithmus}
    \KwIn{$P \subset \R^2, P = \{p_1, p_2, \dotsc, p_k \}$}
    \KwOut{Triangulierung und konvexen Hülle}
	Sortiere $\{p_1, \dotsc, p_k\} lexikographisch$\;
	verbinde alle $p_i p_{i+1}$ mit Kanten\;
	berechne untere konvexe Hülle LowerHull(p)\;
	berechne obere konvexe Hülle UpperHull(p)\;
\end{algorithm}

\begin{algorithm}
    \dontprintsemicolon
    \caption{LowerHull($P$)}
%    \KwIn{$P \subset \R^2, P = \{p_1, p_2, \dotsc, p_k \}$}
%    \KwOut{Triangulierung und konvexen Hülle}
	$p:=p_1, q = p_3, r = p_2$\;
	$i := 3$\;
	\While{$i \leq n$}{
		\eIf{$\operatorname{IsLeftOf}(p,q,r)$}{
			fügen Kante $(p,q)$ ein\;
			$i++$\;
			$r:=q$\;
			$q:=p_i$\;
		}
		{
			$i++$\;
			$p:=r$\;
			$r:=q$\;		
			$q:=p_i$\;
		}		
	}
\end{algorithm}

\begin{algorithm}
    \dontprintsemicolon
    \caption{UpperHull($P$)}
%    \KwIn{$P \subset \R^2, P = \{p_1, p_2, \dotsc, p_k \}$}
%    \KwOut{Triangulierung und konvexen Hülle}
	drehe Reihenfolge von $p_1, \dotsc, p_k$ um\;
	LowerHull(p)\;
\end{algorithm}

Die Laufzeit ist $O(n \log n)$, da am Anfang die Punkte sortiert werden müssen. 

Untere Schranke:
\begin{algorithm}
    \dontprintsemicolon
    \caption{Sortieren mit konvexen Hüllen}
    \KwIn{$a_1, \dotsc, a_n \in \R \geq 0;  a \geq 0$}
    \KwOut{Zahlen in sortierter Reihenfolge -> $\Omega(n \log n)$}
	konstruiere Punkte $p_i := (a_i, a_i^2)$\;
	berechne die Konvexe Hülle\;
\end{algorithm}

%gegeben: $a_1, \dotsc, a_n \in \R \geq 0;  a \geq 0$
%ausgabe: Zahlen in sortierter Reihenfolge -> $\Omega(n \log n)$
%konstruiere Punkte $p_i := (a_i, a_i^2)$
Konvexe Hülle würde die Zahlen $a_1, \dotsc, a_n$ sortieren. Damit ist die untere Schranke $\Omega(n \log n)$ wenn $n$ Punkte auf der konvexen Hülle liegen.

\section{Berechnung von Voronoi-Diagrammen in der Ebene}

Komplexität eines Voronoi-Diagramms in der Ebene:

\begin{lemma}
Wenn $\norm{p} = n \geq 3$ ist, so gibt es höchstens $2n -5$ Voronoiknoten und $3n-6$ Voronoikanten. (in der Ebene)
\end{lemma}

\begin{proof}
Eulers Formel für planare Graphen:
\[m_{kn} - m_{ka} + m_F = 2\]

hier (unendlichen Knoten einfügen und alle Knoten auf der konvexen Hülle damit verbinden.): 
\[(n_{Kn} + 1) - n_{Ka} + n = 2\]

Summe aller Knotengrade:
\[2 \cdot n_{Ka} \geq 3 (n_{Kn} + 1)\], da jeder Knoten mindestens Grad 3 hat.

daraus folgt:
\begin{gather*}
\begin{split}
(n_{Kn} + 1) + n = 2 + n_{Ka} &\geq 2 + \frac{3}{2} (n_{Kn} + 1) \\
n &\geq 2 + \frac{1}{2} (n_{Kn} + 1) \\
2n -5 &\geq n_{Kn} 
\end{split}
\end{gather*}

Analog folgt $3n - 6 \geq n_{Ka}$
\end{proof}


\subsection{Sweep Line Paradigma}
\begin{figure}
\begin{center}
 \includegraphics[width = 0.7\textwidth]{grafiken/sweepline}
\end{center}
\caption{sweep line}
\end{figure} 

\begin{figure}
\begin{center}
 \includegraphics[width = 0.5\textwidth]{grafiken/beachline}
\end{center}
\caption{beach line}
     \end{figure} 


\begin{enumerate}
 \item Punkt-Event:
Sweepline trifft auf einen Punkt aus $P$.

\begin{enumerate}
 \item Ein neuer Parabelbogen kommt zur beach line hinzu
 \item Neue Voronoikanten werden in ihrem Verlauf beschrieben
\end{enumerate}

\begin{figure}
\begin{center}
 \includegraphics[width = \textwidth]{grafiken/punktevent}
\end{center}
\caption{Punkt-Event}
\end{figure} 


Daraus folgt: Es gibt maximal $2n - 1$ Parabelbogen auf  beachline.


 \item Kreis-Event:
In dem Moment, in dem $a'$ verschwindet, gehen alle drei Parabelbögen $a', a''$ und $a'''$ durch einen gemeinsamen Punkt $q$. Dieser ist ein neuer Knoten im Voronoi-Diagramm, da der offene Kreis $K$ mit Mittelpunkt $q$ leer ist.
\end{enumerate}

\begin{lemma}
Ein neuer Parabelpunkt kann auf der beach line nur durch ein Punkt-Event entstehen.
\end{lemma}


\begin{lemma}
Ein Parabelbogen kann von der beach line nur durch ein Kreis-Event verschwinden.
\end{lemma}

\begin{enumerate}
 

 \item Datenstrukturen für das schon konstruierte Voronoi-Diagramm
\begin{itemize}
 \item Halbkantendatenstruktur
\end{itemize}

 \item Datenstruktur für die beach line
\begin{itemize}
 \item ausbalancierten Binärbaum, wobei die Blätter die Parabelbögen darstellen
 \item Schnittpunkte benachbarter Parabelbögen können durch interne Knoten dargestellt werden
\end{itemize}

 \item Datenstruktur für die Events 
\begin{itemize}
 \item Prioritätswarteschlange
 \item füge am Anfang alle Punktevents ein. 
 \item füge Kreis-Events hinzu, sobald klar ist, wann sie stattfinden (ist Berechenbar bei Punkt-Event)
\end{itemize}
\end{enumerate}

\begin{bemerk}
Laufzeit pro Punktevent: $\log n$

Laufzeit pro Kreisevent: konstante Zeit
\end{bemerk}

Insgesamt: $O(n \log n)$


\section{Inkrementeller Algorithmus zur Berechnung der Delaunay-Triangulierung von \texorpdfstring{$P \subset \R^2$}{P ist Teilmenge von R hoch 2}} 

$P = \{p_1, \dotsc, p_n\}, S_1 = \{p_1\}, S_n = \{p1, \dotsc, p_n\} = P, P_i = \{1, \dotsc, p_i\}$

Seien $D_i = D(S_i)$ die Delaunay-Triangulierung von $S_i$

Annahme:
$x,y,z \in \R^2$ mit 
$\{x,y,z\} \cap P = \emptyset$
, so dass  
$P \subset \operatorname{CONV}\{x,y,z\}$ 
und Radius der umschließenden Kreisscheibe von 
$xyz >> \max\{ \norm{ p_i - p_j } | p_i, p_j \in P \} \forall i = 1, \dotsc, n$.

$D_0 = D(x,y,z)$ Delaunay-Triangulierung von x,y,z.
\begin{enumerate}
\item Einfügen in Dreieck, dass $p_2$ enthält
\item \enquote{Splitten} des Dreiecks
\item Herstellen der lokalen Delaunay-Eigenschaft für alle Kanten  
\end{enumerate}

\begin{algorithm}
    \dontprintsemicolon
    \caption{Inkremententeller Algorithmus für Delaunay-Triangulierung}
    \KwIn{$P \subset \R^2$}
    \KwOut{Delaunay-Triangulierung}
\For{i=1 TO n}
{
	FIND $\sigma_{i-1}$ IN $D_{i-1}$ WITH $p_i \in \sigma_{i-1}$\; %\sigma_{i-1} Dreieck in Delaunay-Triangulierung D_{i-1}, dass ist das Punktlokalisierungsproblem
	ADD $p_i$ by splitting $\sigma_{i-1}$\;  % <-- Update
	\While{$\exists$ Edge $bc$ WITHOUT \enquote{lokale Delaunay-Eigenschaft}}
	{
		Flip $bc$ to $ad$\;
	}	
}
\end{algorithm}

\begin{figure}
\begin{center}
 \includegraphics[width = \textwidth]{grafiken/D1-3}
\end{center}
\caption{$D_0$, $D_1$ und $D_2$}
\end{figure} 


Der Algorithmus ist in 2 Teilprobleme unterteilt: Das Lokalisierungsproblem in Zeile 2 und das Update-Problem in Zeile 3-6. Das Update besteht aus einer Split-Operation (genannt \enquote{1-3-Flip})
und mehreren Flip-Operationen (genannt \enquote{2-2-Flip}).
	
	
\subsubsection{Anzahl von Flips im Verlauf des Algorithmus}

\begin{lemma}
Sei $\sigma \in D_i \notin D_{i-1}$, dann hat $\sigma$ den Punkt $p_i$ als einen seiner Knoten.
\end{lemma}
\begin{proof}
Da $\sigma$ Delaunay-Dreieck enthält die Umkreisscheibe keinen Punkt von $S_i$ im Innern. Da $S_{i-1} \subset S_i$ gilt das gleiche für $S_{i-1}$, d.\,h. falls $p_i$ kein Knoten von $\sigma$ ist, dann $\sigma \in D_{i-1}$. Daraus folgt: $p_i$ Knoten von $\sigma$.
\end{proof}


\begin{defini}
\begin{itemize}
\item Sei $p$ Knoten von Triangulierung $T$. Der Stern (Star) von $p$ sind alle Dreiecke in $T$, die inzidient sind zu $p$.

\item Der Link von $P$ sind alle Kanten im Stern von $p$, die nicht zu $p$ inzident sind.
\end{itemize}
\end{defini}

\begin{enumerate}
\item Nur die Dreiecke im Stern von $p_i$ können durch Flip-Operationen beim einfügen von $p_i$ in $D_{i-1}$ entstanden sein. Die Anzahl der Flip-Operationen ist $\leq \frac{1}{2} \operatorname{GRAD}(p_i)$, wobei $\operatorname{GRAD}(p_i) =$ die Anzahl der Kanten inzident zu $p_i$ in $D_i$ ist.
Jeder Flip erzeugt ein neues Dreieck inzident zu $p_i$

\item Nach jeder Operation müssen wir immer nur die noch nicht geprüften Kanten im Link von $p_i$ auf die lokale Delaunay-Eigenschaft prüfen.
\end{enumerate}

Beispiel: Kaskadierender Flip, d.\,h. es reicht nicht nur die Kanten des Dreiecks in das $p_i$ eingefügt wurde auf die lokale Delaunay-Eigenschaft zu prüfen.

\begin{figure}
\begin{center}
 \includegraphics[width = \textwidth]{grafiken/kaskadierenderflip}
\end{center}
\caption{kaskadierender Flip}
\end{figure} 


$\operatorname{GRAD}(p_i) \leq i-1$, d.\,h. höchstens $\frac{i-1}{2}$ Flips beim Einfügen von $p_i$.

Faustregel und Trick: Wenn immer die Auswahl in einem Algorithmus beliebig ist, dann treffe die Entscheidung zufällig.
In diesem Fall bedeutet das, dass wir die Reihenfolge der Punkte $p_1, \dotsc, p_n$ zufällig wählen.

Jetzt müssen nur noch die erwartete Anzahl von Flip-Operationen beim Einfügen von $p_i$ bestimmt werden.

\begin{beob}
\begin{enumerate}
 \item Bei zufälliger (gleichverteilt) Einfügereihenfolge hat jeder Punkt die gleiche Wahrscheinlichkeit als letzter eingefügt zu werden.
 \item Gesamtanzahl von Flips über alle Einfügereihenfolgen von $i$ Punkten: \[ \sum_{j = 1}^{i} \operatorname{GRAD}_i (p_j)\] 
Wobei $\operatorname{GRAD}_i (p_j)$ der Knotengrad von $p_j$ in $D_i$ ist.
 \item  $\sum_{j = 1}^{i} \operatorname{GRAD}_i (p_j) = 2$ \# Kanten in $D_i$
 \item  Für die Anzahl der Kanten in $D_i$ gilt die Eulerformel: 
\[\text{Anzahl der Knoten }v - \text{Anzahl der Kanten } e + \text{Anzahl der Dreiecke } f = 2\]
Für Delaunay-Triangulierungen gilt außerdem folgendes: 
\[3f = 2(e-h) + h = 2e - h\text{, h ist die Anzahl der Kanten auf Rand von $D_i$}\] 
Daraus folgt: \[f = \frac{2}{3} e - \frac{1}{3} h \]
Durch einsetzen in die Euler-Formel erhält man nun 
\[v - e + \frac{2}{3} e - \frac{1}{3} h = 2\] 
Daraus folgt: \[e = 3v - h - 6\]
\end{enumerate}
\end{beob}

Aus 1-4 folgt: 
\[ \text{Gesamtanzahl von Flips} \leq \frac{1}{2}(2 \cdot 3i - 9 ) \leq 3i\]
% h >= 3.
Daraus folgt die durchschnittliche Anzahl von Flips $\leq 3$.


\subsubsection{Aufwand für das Punktlokalisierungsproblem}

Datenstruktur für die Punktlokalisierung ist der Delaunay-Graph: 
Gerichteter, azyklischer Graph. Abgeleitet aus Split und Flip.
Knoten des Graphen sind alle Dreiecke, die im Verlauf des inkrementellen Algorithmus auftauchen.

\begin{figure}
\begin{center}
 \includegraphics[width = 0.5\textwidth]{grafiken/dg-flip}
\end{center}
\caption{Delaunay-Graph beim Flip}
\end{figure} 

\begin{figure}
\begin{center}
 \includegraphics[width = 0.5\textwidth]{grafiken/dg-split}
\end{center}
\caption{Delaunay-Graph beim Split}
\end{figure} 


\begin{bemerk}
Beweis der Eulerformel: $v -e + f = 2$

\begin{enumerate}
 \item 1-Skelett der Delaunay-Triangulierung. (D.\,h. der planare Graph der Delaunay-Kanten und Vertices.)
\item 1-Skelett enthält minimalen Spannbaum von $P$.
\end{enumerate}

Für den Spannbaum gilt: 
\[v = \abs{p} = n\]
\[e = n-1\]
\[f = 1\]

Das bedeutet für diesen Fall gilt die Eulerformel.

Induktion: Durch Einfügen von Delaunay-Kanten in den Spannbaum gilt:
\[v \rightarrow v + 1\]
\[f \rightarrow f + 1\text{ , weil jede neue Kante ein Gebiet teilt}\]
\[v \rightarrow v\]

Damit gilt die Eulerformel.
 \end{bemerk}

%\section{Inkrementeller Algorithmus zur Berechnung der Delaunay-Triangulierung}

Lower Hull(P), $\abs{P}= n, P \subset \R^2$

\begin{algorithm}
    \dontprintsemicolon
	\caption{LowerHull($P$), $ |P| = n, P \subset \R^2$}
%    \caption{LowerHull($P$), $\abs{P}= n, P \subset \R^2$}
%    \KwIn{$P \subset \R^2, P = \{p_1, p_2, ... , p_k \}$}
%    \KwOut{Triangulierung und konvexen Hülle}
	a:a[0,....,n] Array mit $n+1$ Elementen\;
	$a[0] := p_1$\;
	\For{$i = 1TO n$}{
		$a[i]:=p_i$\;	
	}
	$i:=1$\;
	\While{$i < LENGTH(q) - 1$}{
		\eIf{$IS_LEFT_OF(a[i], a[i+2], a[i+1])$}{
			Remove(a,i+1)\; %//Entferne das i+1te Element aus q
			$i := i -1$\;
		}
		{
			$i:=i +1$\;
		}	
	}
	\For{$i=1 TO Length(a)$}{
		Output a[i]	\;
	}
\end{algorithm}

Randomisierte Analyse:

Sei $p_1, ...., p_n$ zufälige Reihenfolge der Punke in $P$.
$D_0, ..., D_n$ folge von Delaunay-Triangulierungen.

$D_0 = {xyz}$ Großes Dreieck, das alle Punkte in $P$ enthält.

$D_i$ entsteht durch $D_{i-1}$ durch
\begin{enumerate}
\item split-Operation: $\sigma \in D_{i-1}$ das Dreieck in Delaunay-Triangulierung von $p_1, ..., p_{i-1}$, das $P$ enthält. -> 1-3-Flip
\item Flip-Operationen: -> 2-2-Flip
\end{enumerate}

\begin{figure}[htbp]
\begin{center}
\includegraphics[width = 0.5\textwidth]{grafiken/22flip}
\caption{2-2-Flip}
\label{default}
\end{center}
\end{figure}

\begin{figure}[htbp]
\begin{center}
\includegraphics[width = 0.5\textwidth]{grafiken/13flip}
\caption{1-3-Flip}
\label{default}
\end{center}
\end{figure}


Punktlokalisation durch gerichtete, nicht-zyklische Graphen
....

\begin{enumerate}
\item Erwartete Größe, des Graphen.
\[\underbrace{1}_{\text{Dreieck}} 		+	\underbrace{3n}_{\parbox{0.3\textwidth}{Einfügen von n Punkten, also n Split-Operationen, jeder Split erzeugt 3 neue Dreiecke}} 											+ 	\underbrace{3 * 2n}_{\parbox{0.3\textwidth}{Jeder Flip erzeugt 2 neue Dreiecke, Pro Runde erwartet drei Flips, $n$ Punkte}}\]
%Dreieck	Einfügen von n Punkten, also n Split-Operationen, jeder Split erzeugt 3 neue Dreiecke
%		Jeder Flip erzeugt 2 neue Dreiecke, Pro Runde erwartet drei Flips, n Punkte
		
D.\,h. Punktlokalisierungsdatenstruktur braucht Speicher $O(n)$

\item Erwartete Laufzeit

Im Schritt $i$ einfügen von $p_i$. D.\,h. wir suchen $\sigma \in D_{i-1}$ mit $p_i \in \sigma_i$. Für Suche starten wir in $xyz$ und gehen dann zu Kind, das $p_i$ enthält.
\end{enumerate}

IN\_TRIANGLE Prädikat:

$p_i \in abc$ falls $p_i$ auf gleicher Seite von 
$\operatorname{aff}(a,b)$ wie $c$,
von $\operatorname{aff}(b,c)$ wie $a$,
von $\operatorname{aff}(c,a)$ wie $b$.

Azyklische Graph zerfällt in Schichten. Eine Schicht für jede Runde.
Betrachte $j$te Schicht $0<j<i-2$. Auf dieser Schicht sind Dreiecke von $D_j$ gespeichert.

Seien $G_j$ die Dreiecke in $D_j$, die beim Einfügen von $p_{j+1}$ zerstört werden.

Seien $H_j$ die Dreiecke in $D_j$, die beim Einfügen von $p_i$ in $D_j$ zerstört werden.

\begin{beob}
Falls $G_j \cap H_j = \emptyset$, dann ist $\sigma_{j+1} = \sigma_j$, wobei $\sigma_j \in D_j$, $\sigma_{j+1} \in D_{j+1}$ die Dreiecke sind, die $p_i$ enthalten.
\end{beob}

Sei $X_j = G_j \cap H_j$, der Aufwand von $\sigma_j$ nach $\sigma_{j+1}$ zu gehen ist höchstens proportional zu $\abs{X_j}$. (Durchlaufen von Dreiecken, die durch Flip-Operationen erzeugt werden.)

Wir müssen $\abs{X_j}$ abschätzen.

Sei $\hat{D}_j$ die Delaunay-Triangulierung von $p_1, p_2, ...., p_j, p_i$.
Seien $Z_j$ die Dreiecke in $\hat{D}_j$, die durch Einfügen von $p_{j+1}$ zerstört werden.

Symbolische Darstellung:

Seien $Y_j$ die Dreiecke inzident zu $p_i$, die beim Einfügen von $p_{j+1}$ in $\hat{D}_j$ zerstört werden

\[ X_j = H_j \ (Z_j \ Y_j)\]
\[ \abs{X_j} = \abs{H_j} - (\abs{Z_j} - \abs{Y_j})\]

\begin{figure}[htbp]
\begin{center}
\includegraphics[width = 0.7\textwidth]{grafiken/symbolischedarstellung}
\caption{Symbolische Darstellung der Variablen}
\label{default}
\end{center}
\end{figure}

Beachte: $Y_j \subseteq Z_j$ und $Z_j \ Y_j \subseteq H_j$

Erwarteter Suchaufwand ist:
\[E[\sum_{j=1}^{i-2} \abs{X_j}] =  \sum_{j=1}^{i-2} E[\abs{X_j}]  = \sum_{j=1}^{i-2} E[\abs{H_j}] - \sum_{j=1}^{i-2} E[\abs{Z_j}] + \sum_{j=1}^{i-2} E[\abs{Y_j}]\]


$H_j$: Anzahl der zerstörten Dreiecke beim Einfügen von zufälligen Punkt in die Delaunay-Triangulierung von $j$ Punkten.

$Z_j$: Anzahl der zerstörten Dreiecke beim Einfügen eines zufälligen Punktes in die Delaunay-Triangulierung von $j+1$ Punkten.


%=> 
\[E[\abs{H_{j+1}}] = E[\abs{Z_j}]\]
%=> 
\[E[\sum_{j=1}^{i-2} \abs{X_j}] = E[\abs{H_0}] - E[\abs{H_{i-1}}] + \sum_{j=1}^{i-2} E[\abs{Y_j}]\]

\[E[\abs{H_0}] = 3, E[\abs{H_{i-1}}] = 4 => E[\sum_{j=1}^{i-2} \abs{X_j}]  \leq \sum_{j=1}^{i-2} E[\abs{Y_j}]\]

Es bleibt $E[\abs{Y_j}]$ zu bestimmen.
Dazu: Erwartete Anzahl zerstörter Dreiecke beim Einfügen von $p_{j+1}$ in $\hat{D}_j$:
\[1 \text{ (Split)} + 3 \text{ (Flips)} = 4\]
 
In $Y_j$ interessieren uns nur Dreiecke in $\hat{D}_j$, die inzident zu $p_i$ sind.
Die Wahrscheinlichkeit für ein Dreieck in $\hat{D}_j$ inzident zu $p_i$ zu sein ist $\leq \frac{3}{j+1}$.

Daraus folgt:
\[E[\abs{Y_j}] \leq \frac{12}{j+1} = \frac{3}{j+1} 4\]

\begin{gather*}
\begin{split}
E[\sum_{j=1}^{i-2} \abs{X_j}] &\leq 12 \sum_{j=1}^{i-1} \frac{1}{j+1} \\
&\leq 12 H_i \leq 12 \log(i+1) \\
&\leq \sum_{i=1}^n 12 \log(i+1) \\ 
&\leq 12n \log{n+1} \in O(n \log n) \text{ (Gesamte Suchzeit)}
\end{split}
\end{gather*}

\section{(Unendliche) Gleitkommazahlsysteme}

$G_{\beta, t}$ mit $\beta, t > 1$ natürliche Zahl ist Gleitkommezahlsystem.
\[
G_{\beta, t} = \{ y = \sigma m \beta^{e-t} | \sigma in \{  -1, +1 \}, \beta^{t-1} \leq m < \beta^t-1, e \in \Z \} \cup \{0\}
\]  

$\beta$: Basis des Systems
$t$: Genauigkeit (Precision)

$\sigma$: Vorzeichen

$m$: Mantisse

$e$: Exponent

Gleitkommazahl Approximation: $x \in \R: Fl(x) = \arg\min_{y\in G_{\beta, t}} \abs{x-y}$. 
Falls $\abs{Fl(x)} = 2$, d.\,h. zwei nächste Gleitkommezahlen, dann immer diejenige näher an Null als approximation.

\begin{lemma}
Sei $n = \frac{1}{2} \beta^{1-t}$ Dann gilt:
\begin{enumerate}
\item $Fl(x) = x(1+\delta)$, mit $\abs{\delta} < u$
\item $\lambda = Fl(x)(1+\delta')$, mit $\abs{\delta'} < u$
\end{enumerate}
 (Der relative approximationsfehler ist immer beschränkt durch $\mu$)
\end{lemma}

\begin{proof}
Annahme $x>0$. Dann können wir schreiben $x = \mu \beta^{e-t}$ mit $\beta^{t-1} \leq \mu < \beta^t-1$, wobei $\mu \in \R$.

Dann $y_1= \lfloor \mu \rfloor \beta^{e-t}, y_2 = \lceil \mu \rceil \beta^{e-t} \in G_{\beta, t}$

\[\abs{Fl(x) - x} \leq min\{ x-y_1, x-y_2 \}
\leq (y_2-y_1)/2
= \frac{1}{ 2}(\lfloor \mu \rfloor - \lceil \mu \rceil)
\leq \frac{1}{2} \beta^{e-t}
\]
Daraus: 
\[
\abs{\frac{Fl(x)-x}{x}} \leq \frac{\frac{1}{2} \beta^{e-t} }{\mu \beta^{e-t}} 
\leq \frac{1}{2} \frac{1}{\beta^{t-1}} = \frac{1}{2} \beta^{1-t} = u
\]

Die Ungleichung ist nur dann eine Gleichung, wenn $\mu = \beta^{t-1}$, aber dann $\abs{Fl(x) - x} = 0$, d.\,h. wir haben immer 
\[
\frac{Fl(x) - x}{x} < u
\]
Daraus folgt für $Fl(x) = x(1+\delta)$
\[
\abs{\delta} = \abs{\frac{x(1-\delta) - x}{x}} < u
\]
Die Zweite Behauptung folgt analog.

\end{proof}

Es gibt 2 Arten von Approximationsfehlern: 
\begin{enumerate}
\item relativ: $\abs{\frac{Fl(x) - x}{x}}$
\item absolut: $\abs{Fl(x) - x}$
\end{enumerate}

Notation: 
\begin{enumerate}
\item $a = b\pm c$ heisst  $a \in [b - \abs{c} , b + \abs{c}]$
\item $a \pm b = c \pm d$ falls $[a - \abs{b}, a + \abs{b}] \in [c - {d}, c + {d}]$
\end{enumerate}

Gleitkommazahlenoperationen: $\oplus, \ominus, \otimes$

$x,y \in F_{\beta, t}$, dann ist
\[
x \circledast y = Fl(x * y), * \in {+,-,\times}
\]

\begin{bemerk} 
Das ist Definition, die von fast aller moderner Hardware befolgt wird.
\end{bemerk}

Korollar zu Lemma: 
\begin{enumerate}
\item $x \oplus y = x+y \pm u\abs{x+y}$
\item $x \ominus y = x+y \pm u\abs{x-y} = x-y \pm \abs{\abs{x} + \abs{y}}$
\item $x \otimes y = xy \pm \abs{xy}$
\end{enumerate}


\section{Gleitkommazahlapproximation von Geometrischen Prädikaten}

Beispiel: IS\_LEFT\_OF(p,q,r)

Implementiert als
$\begin{vmatrix}
1 & p_x & p_y \\
1 & q_x & q_y \\
1 & r_x & r_y
\end{vmatrix}
>0$

$\begin{vmatrix}
1 & p_x & p_y \\
1 & q_x & q_y \\
1 & r_x & r_y
\end{vmatrix} = (r_x - p_x)(r_y - q_y) + (p_y - r_y)(r_x - q_x)$

Annahme: $p_x, p_y, q_x, q_y, r_x, r_y \in G_{\beta, t}$
(In der Praxis: Koordinaten sind ganze Zahlen in $G_{\beta, t}$)

Audrücke: 
\begin{center}
\begin{tabular}{|c|c|}
\hline
reelle Ausdrücke		&	Gleitkommazahl-Ausdrücke \\
\hline
$w_1 = r_x - p_x$		&	$a_1 = r_x \ominus p_x$	\\
$w_2 = r_y - q_y$		&	$a_2 = r_y \ominus q_y$	\\
$w_3 = p_y - r_y$		&	$a_3 = p_y \ominus r_y$	\\
$w_4 = r_x - q_x$		&	$a_4 = r_x \ominus q_x$	\\
$w_5 = w_1 w_2$		&	$a_5 = a_1 \otimes a_2$	\\
$w_6 = w_3 w_4$		&	$a_6 = a_3 \otimes a_4$	\\
$w_7 = w_5 + w_6$		&	$a_7 = a_5 \oplus a_6$	\\
\hline
\end{tabular}
\end{center}


\begin{enumerate}
\item 
\begin{gather*}
a_i = w_i \pm u \abs{w_i}
\end{gather*}
aus obigem Lemma.

\item 
\begin{gather*}
\begin{split}
a_1a_2 &= (w_1 \pm u \abs{w_1}) \cdot (w_2 \pm u \abs{w_2}) \\
&= w_1 w_2 \pm u w_1 \abs{w_2} \pm u w_2 \abs{w_1} \pm u^2 \abs{w_1 w_2}\\
&= w_1 w_2 \pm (2u + u^2)\abs{w_1 w_2}
\end{split}
\end{gather*}
Genauso für $a_3a_4$.

\item 
\begin{gather*}
\begin{split}
a_5 &= a_1 \otimes a_2 = a_1 a_2 \pm u \abs{a_1 a_2} \text{ (Lemma und def. der Gleitkommazahlen)} \\ 
&= w_5 \pm (2u + u^2)\abs{w_5} \pm u\abs{w_5 \pm (2u + u^2)\abs{w_5}} \\
&= w_5 \pm (3u + 3u^2 + u^3)\abs{w_5}
\end{split}
\end{gather*}

Genauso für $a_6$

\item 
\begin{gather*}
\begin{split}
a_7 &= a_5 \oplus a_6 \\
&= a_5 + a_6 \pm u \abs{a_5 + a_6}\\
&= w_5 \pm (3u + 3u^2 + u^3)\abs{w_5} + w_6 \pm (3u + 3u^2 + u^3)\abs{w_6} \pm ((3u + 3u^2 + u^3)(\abs{w_5} + \abs{w_6}) )\\
&= w_5 + w_6 \pm (3u + 3u^2 + u^3)(\abs{w_5}+ \abs{w_6}) \pm (3u^2 + 3u^3 + u^4)(\abs{w_5} + \abs{w_6}) \pm u(\abs{w_5} + \abs{w_6})\\
&= w_5 + w_6 \pm (4u + 6u^2 + 4u^3 + u^4)(\abs{w_5} + \abs{w_6})\\
&= w_7 \pm (4u + 6u^2 + 4u^3 + u^4)(\abs{w_5} + \abs{w_6}) = \phi 
\end{split}
\end{gather*}
Das Ergebnis ist ein reeler Ausdruck plus die Abschätzung für den Fehler.
\end{enumerate}

Sei $a$ Wert von Gleitkommazahlausdruck, dann falls $a > \phi \rightarrow w > 0$, falls $a < -\phi \rightarrow w < 0$

\begin{bemerk}
Sei $B = max\{ p_x, p_y, q_x, q_y, r_x, r_y \}$. Dann gilt $\abs{\phi} \leq (4u + 6u^2 + 4u^3 + u^4) 8 B^2$. 
Das kann vorberechnet werden.
\end{bemerk}

\begin{beob}
\begin{enumerate}
\item Wenn $x \in \Z$, dann ist $Fl(x) \in \Z$
\item Falls $\abs{\phi}$ < 1, dann $a \in (-\abs{phi}, \abs{phi})$. Daraus folgt $w = 0$, da $w \in \Z$ angenommen und Eingabekoordinaten aus $\Z$ angenommen und alle Operationen $+,-,x$ abgeschlossen in $\Z$.
\end{enumerate}
\end{beob}


\section{Degeneriertheit - Symbolische Pertubierung}

Bei theoretischer Analyse der Algorithmen immer Annahme von allgemeiner Lage, d.\,h. in der Ebene
\begin{enumerate}
\item keine drei Punkte auf gemeinsamer Geraden
\item keine vier Punkte auf gemeinsamen Kreisrand.
\end{enumerate}

Vier Punkte auf Kreisrand führt zu Vierecken im Delaunay-Komplex. Es ist also keine Triangulierung mehr.
Vielecke können wir immer Triangulieren, aber wie?


Degeneriertheit kann mit zufälligem Verwackeln (= Verrauschen, Pertubieren) der Eingabe aufgehoben werden. Da man die Eingabe aber nur ungern verändern will, werden wir mit symbolischen Pertubieren arbeiten.



Eingabe: 
Punktmenge $P = \{p_1, ... , p_n\} \in \R^2$ bzw. $(X_1, ... , X_n) \in \R^{2n}$

Mit $P_{ix} = X_{2i-1}$ und $P_{iy} = X_{2i}$.

Für $\{i,j,k\} \in \binom {[n]} 3$, d.\,h. dreielementige Teilmengen von $\{1, ..., n\}$.

Folgende Funktion:
$t_{i,j,k} \colon \R^{2n} \rightarrow \R$

\todo{hier fehlt einiges}

Frage: Wie $\epsilon > 0$ wählen?
Antwort: Gar nicht, sondern symbolisch pertubieren.

\begin{algorithm}
    \dontprintsemicolon
    \caption{IS\_LEFT\_OF mit symbolisch pertubiert}
    \KwIn{$p,q,r$}
		$d:= \delta = \begin{vmatrix} 1 & p_x & p_y \\ 1 & q_x & q_y \\ 1 & r_x & r_y \end{vmatrix}$\;
		\If{$d > 0$}{
			\Return{true}\;
		}
		\If{$d < 0$}{
			\Return{false}\;
		}
		$d:= \delta_1 = \begin{vmatrix} 1 & q_y \\ 1 & r_y \end{vmatrix}$\;
		\If{$d < 0$}{
			\Return{true}\;
		}
		\If{$d > 0$}{
			\Return{false}\;
		}
		$d:= \delta_2 = \begin{vmatrix} 1 & r_x \\ 1 & q_x \end{vmatrix}$\;
		\If{$d > 0$}{
			\Return{true}\;
		}
		\If{$d < 0$}{
			\Return{false}\;
		}
		$d:= \delta_3 = \begin{vmatrix} 1 & p_y \\ 1 & r_y \end{vmatrix}$\;
		\If{$d > 0$}{
			\Return{true}\;
		}
		\If{$d < 0$}{
			\Return{false}\;
		}		
		\Return{false}\;
\end{algorithm}

\begin{enumerate}
\item Im Vergleich zum nicht pertubierten Prädikat müssen wir jetzt im schlimmsten Fall vier Determinanten berechnen.
\item Falls Eingabe nicht degeneriert, ergibt pertubiertes Prädikat genau das gleiche Ergebnis wie das Unpertubierte.
\end{enumerate}

In welche Richtung die Entscheidung aufgelöst wird, hängt von der Reihenfolge der Punkte ab.

\section{3D Delaunay-Triangulierung für gewichtete Punkte}

Gewichteter Punkt: $(p, w_p) \in \R^3 \times \R$

Powerabstand zum gewichteten Punkt: $\pi_p (x) = \norm{x-p}^2 - w_p$

\begin{figure}[htbp]
\begin{center}
\includegraphics[width = 0.5\textwidth]{grafiken/graphenabstandsfunktion-normal}
\caption{Graph der Abstandsfunktion}
\label{default}
\end{center}
\end{figure}


\begin{figure}[htbp]
\begin{center}
\includegraphics[width = 0.5\textwidth]{grafiken/graphenabstandsfunktion-quadratisch}
\caption{Graph der quadratischen Abstandsfunktion}
\label{default}
\end{center}
\end{figure}


\begin{figure}[htbp]
\begin{center}
\includegraphics[width = 0.5\textwidth]{grafiken/graphenabstandsfunktion-power}
\caption{Graph der quadratischen Powerabstände}
\label{default}
\end{center}
\end{figure}


\begin{beob}
Nicht alle Eingabepunkte sind Knoten in der Delaunay-Triangulierung. Das tritt genau dann auf, wenn die zugehörige Powerzelle leer ist.
\begin{figure}[htbp]
\begin{center}
\includegraphics[width = 0.5\textwidth]{grafiken/leerepowerzelle}
\caption{Die Powerzelle von $p_2$ ist leer}
\label{default}
\end{center}
\end{figure}

Ein gewichteter Punkt ist relevant genau dann, wenn seine Powerzelle nicht leer ist.
\end{beob}

\begin{beob}
Ein gewichteter Punkt muss nicht in der eigenen Powerzelle enthalten sein.
\begin{figure}[htbp]
\begin{center}
\includegraphics[width = 0.5\textwidth]{grafiken/punktnichtinseinerpowerzelle}
\caption{$p_2$ ist nicht in seiner Powerzelle enthalten}
\label{default}
\end{center}
\end{figure}
\end{beob}

Erinnerung: 
Ein Dreieck (in der Ebene) gehört zur Delaunay-Triangulierung wenn seine offene Umkreisscheibe keinen Punkt von $P$ im innern enthält.

Jetzt: 
Ein Tetraeder (im $\R^3$ bei Eingabe gewichteter Punkte) gehört zur gewichteten Delaunay-Tetraedisierung (im Folgenden immer kurz Triangulierung genannt), wenn seine Orthosphäre weiter \todo{weiter?} oder orthogonal zu allen Eingabepunkten ist.

\begin{defini}[Orthogonalität]
$(p, w_p), (q, w_q)$ gewichtete Punkte sind orthogonal zueinander, falls $\pi_{p,q} := \norm{p-q}^2 - w_p - w_q = 0$ gilt.
\end{defini}

\begin{bemerk}
Gewichteter Punkte mit positivem Gewicht kann als Ball aufgefasst werden.

\begin{figure}[htbp]
\begin{center}
\includegraphics[width = 0.5\textwidth]{grafiken/gewichteterpunktalsball}
\caption{Darstellung eines gewichteten Punkts als Ball im $\R^2$}
\label{default}
\end{center}
\end{figure}
\todo{bild}
\end{bemerk}

\begin{defini}[Orthogonalität zweier Sphären] 
2 Sphären heißen Orthogonal zueinander, wenn sie sich in einer Sphäre eine Dimension niedriger schneiden.

Die Tangenten in den Schnittpunkten sind orthogonal.

\begin{figure}[htbp]
\begin{center}
\includegraphics[width = 0.5\textwidth]{grafiken/orthogonaletangenten}
\caption{2 Sphären mit orthogonalen Tangenten}
\label{default}
\end{center}
\end{figure}

\end{defini}
\todo{überprüfen, ob die beiden Definitionen von Orthogonalität stimmen. Kommt mir irgendwie widersprüchlich vor.}

\begin{defini}[Orthosphäre]
Eindeutige Sphäre, die orthogonal zu den 4 gewichteten Knoten des Tetraeders ist.
\end{defini}




\clearpage
\appendix
\begin{thebibliography}{99}
% \bibitem{mathmode} Math mode von Herbert Voss,\\
% \url{http://www.dante.de/CTAN//info/math/voss/mathmode/Mathmode.pdf}

% \bibitem{shmathguide} Short Math Guide for \LaTeX{},\\
%  \url{ftp://ftp.ams.org/pub/tex/doc/amsmath/short-math-guide.pdf}
\end{thebibliography}

\clearpage
\pdfbookmark[0]{Index}{index}
\printindex

\end{document}
