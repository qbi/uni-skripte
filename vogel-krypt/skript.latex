% ToDo:
%   + Es sollte Befehle für Klartext und Chiffretext geben, damit die Texte im
%     gesamten Dokument gleich aussehen. z.\,B. \klartext=\texttt\uppercase
%     und \chiffretext=\texttt\lowercase; \MakeUppercase \MakeLowercase
%     \bstv = Buchstabe verschlüsselt
%     \bstu = Buchstabe unverschlüsselt
%     \textv = Text verschlüsselt
%     \textu = Text unverschlüsselt
%     \schlsl = Schlüssel

% Einige zusätzliche Informationen für rubber
%  rubber erkennt nicht, dass die Datei weg kann, daher sagen wir es ihm
% rubber: clean $base.thm
%  rubber soll nach Änderungen an der Datei nochmal bauen
% rubber: watch $base.thm
% rubber: makeidx.tool      xindy
% rubber: makeidx.language  german-din
% rubber: makeidx.modules   indexstyle.xdy
%
% scrreprt trifft am Besten die Bedürfnisse eines Skripts, das ganze wird
% zweiseitig (twoside), d.h. es wird zwischen linker und rechter Seite
% unterschieden, und wir verwenden zwischen den Absätzen einen Abstand
% von einer halben Zeile (halfparskip) und dafür keinen Absatzeinzug,
% wobei die letzte Zeile eines Absatzes zu min. 1/4 leer ist.

\documentclass[german,draft,twoside]{scrreprt}

\usepackage[l2tabu]{nag}  % nag überprüft den Text auf verältete Befehle
                          % oder solche, die man nicht in LaTeX verwenden
                          % soll -- l2tabu-Checker in LaTeX
\usepackage{ifthen}
\usepackage{makeidx}
\usepackage[final]{graphicx}  % Für Grafiken
\usepackage{color}
\usepackage[draft=false,colorlinks,bookmarksnumbered,linkcolor=blue,breaklinks]{hyperref}

\usepackage[latin1]{inputenc}
\usepackage{ngerman}

\usepackage{lmodern}		% Latin Modern
\usepackage[T1]{fontenc}        % T1-Schriften notwendig für PDFs
\usepackage{textcomp}           % wird benötigt, damit der \textbullet
                                % für itemize in lmodern gefunden wird.

\usepackage[intlimits,leqno]{amsmath}
\usepackage[all,warning]{onlyamsmath}  % warnt bei Verwendung von nicht
                                       % amsmath-Umgebungen z.\,B. $$...$$
\usepackage{amssymb}     % wird für \R, \C,... gebraucht
\usepackage{fixmath}     % ISO-konforme griech. Buchstaben

\usepackage[amsmath,thmmarks,hyperref]{ntheorem} % für die Theorem-Umgebungen
                                                 % (satz, defini, bemerk)
\usepackage{paralist}    % besseres enumerate und itemize und neue
                         % compactenum/compactitem; s. texdoc paralist

\usepackage{svn}         % Zum Auswerten und ordentlichen Darstellen der
                         % SVN-Schlüsselwörter (s. vor \begin{document})
                         % dafür muss in SVN noch das Flag svn:keywords
                         % auf "LastChangedRevision LastChangedDate"
                         % gesetzt werden
\usepackage{ifpdf}       % Erkennung, ob PDF generiert wird; nützlich zur
                         % Unterscheidung bei Grafiken \input{XYZ.pdf_t}
\usepackage{ellipsis}    % Korrektur für \dots
\usepackage{fixltx2e}
\usepackage[final]{microtype} % Verbesserung der Typographie
\usepackage{nicefrac}
\usepackage{gauss}
\usepackage{fancyvrb}
\usepackage{tabularx}

% Damit auch die Zeichen im Mathemode in Überschriften fett sind
% <news:lzfyyvx3pt.fsf@tfkp12.physik.uni-erlangen.de>
\addtokomafont{sectioning}{\boldmath}

% nach dem Theoremkopf wird ein Zeilenumbruch eingefügt, die Schrift des
% Körpers ist normal und der Kopf wird fett gesetzt
\theoremstyle{break}
\theorembodyfont{\normalfont}
\theoremheaderfont{\normalfont\bfseries}
\theoremnumbering{arabic}

% Die folgenden Umgebungen werden einzeln nummeriert und am Ende jedes
% Kapitels zurückgesetzt
\newtheorem{bemerk}{Bemerkung}[chapter]
\newtheorem{defini}{Definition}[chapter]
\newtheorem{bsp}{Beispiel}[chapter]
\newtheorem{satz}{Satz}[chapter]
\newtheorem{lemma}{Lemma}[chapter]

% Die folgenden Theoremumgebungen bekommen keine Nummer
\theoremstyle{nonumberbreak}

\newtheorem{dogma}{Dogma}[chapter]
\newtheorem{fakt}{Fakt}[chapter]

\theoremheaderfont{\scshape}
\theorembodyfont{\normalfont}
% Das Zeichen am Ende eines Beweises
\theoremsymbol{\ensuremath{_\blacksquare}}
% \theoremsymbol{q.\,e.\,d.}
\newtheorem{proof}{Beweis:}

% Hier die Definition, wie \autoref die Umgebungen nennen soll, die mit
% \newtheorem definiert wurden
\newcommand*{\bemerkautorefname}{Bemerkung}
\newcommand*{\definiautorefname}{Definition}
\newcommand*{\bspautorefname}{Beispiel}
\newcommand*{\satzautorefname}{Satz}
\newcommand*{\lemmaautorefname}{Lemma}
\newcommand*{\faktautorefname}{Fakt}
% Zwischen Unter- und Unterunterabschnitten sollte nicht unterschieden
% werden.
\renewcommand*{\subsectionautorefname}{Abschnitt}
\renewcommand*{\subsubsectionautorefname}{Abschnitt}

\pagestyle{headings}

\newcommand*{\N}{\mathbb{N}}      % natürliche Zahlen
\newcommand*{\Z}{\mathbb{Z}}      % ganze Zahlen
\newcommand*{\R}{\mathbb{R}}      % reellen Zahlen
\newcommand*{\F}{\mathbb{F}}      % endliche Ringe
\newcommand*{\FP}{\mathrm{FP}}    % Funktionen, die in Polynomialzeit
                                  % berechnet werden können

% Wenn irgendwo Unklarheiten zum Inhalt im Skript auftreten, können sie
% einfach mit \help{Ich verstehe das nicht} hervorgehoben werden. Dies
% macht es leichter sie alle zu finden und auch ganz einfach
% auszublenden, indem man den Befehl einfach leer definiert
\newcommand*{\help}[1]{\textcolor{green}{help: #1}}

% \todo ist das gleiche wie \help nur für offene Aufgaben
\newcommand*{\todo}[1]{\textcolor{red}{todo: #1}}

% Um wichtige Begriffe im Text überall gleich vorzuheben (gleiches
% Markup), sollte dieser Befehl verwendet werden. Das Argument wird
% automatisch als Indexeintrag verwendet. Dieser kann aber auch als
% optionales Argument selbst bestimmt werden.
\newcommand*{\highl}[2][]{\textbf{\boldmath{#2}}%
  \ifthenelse{\equal{#1}{}}{\index{#2}}{\index{#1}}%
}

% Definition für Xindy für die Trennung der einzelnen Abschnitte im
% Index. siehe auch die Datei indexstyle.xdy
\newcommand*{\indexsection}{\minisec}

% Um sicherzustellen, dass jeder Betrag-/jede Norm links und rechts die
% Striche bekommt, sind diese Befehle da. Damit kann man nicht die
% rechten Striche vergessen und es wird etwas übersichtlicher. (Vorschlag
% ist aus amsldoc) \abs[\big]{\abs{a}-\abs{b}} \leq \abs{a+b}
\newcommand*{\abs}[2][]{#1\lvert#2#1\rvert}
\newcommand*{\floor}[2][]{#1\lfloor#2#1\rfloor}

% Diese Befehle sind dafür gedacht, dass die Symbole für "genau dann wenn"
% im ganzen Dokument gleich aussehen. Außerdem erlaubt es eine schnelle
% Veränderung aller Stellen, falls der Prof. doch nicht mehr gdw nimmt,
% sondern \Leftrightarrow.
\newcommand*{\gdw}{\ifthenelse{\boolean{mmode}}%
			       {\mspace{8mu}gdw\mspace{8mu}}%
			       {$gdw$\xspace}}
\newcommand*{\gdwdef}{\ifthenelse{\boolean{mmode}}%
			       {\mspace{8mu}gdw_{def}\mspace{8mu}}%
			       {$gdw_{def}$\xspace}}

% Das original Epsilon sieht nicht so toll aus
\renewcommand*{\epsilon}{\varepsilon}
% ... und mancheinem gefällt auch das Phi nicht
\renewcommand*{\phi}{\varphi}
\renewcommand*{\tilde}{\widetilde}

% rubber: depend fmc.mp
\iffalse\includegraphics{fmc.1}\fi
% rubber: clean fmc.1 fmc.2 fmc.3 fmc.4 fmc.5 fmc.6 fmc.7 fmc.8 fmc.9 fmc.10
% rubber: clean fmc.11 fmc.12 fmc.13 fmc.14 fmc.15 fmc.16 fmc.17 fmc.18 fmc.19
% rubber: clean fmc.20 fmc.21 fmc.22 fmc.23 fmc.24 fmc.25 fmc.26 fmc.log
\newcommand*{\fmc}[1]{\startfmc#1\Endfmc}
\newcounter{Zeichen}
\newcommand*{\Endfmc}{}
\makeatletter
\newcommand*{\startfmc}[1]{%
  \ifx#1\Endfmc%
  \else%
    \setcounter{Zeichen}{\the\lccode`#1}%
    \ifthenelse{\theZeichen < 97 \OR \theZeichen>122}{#1}%
               {\addtocounter{Zeichen}{-96}%
                 \includegraphics{fmc.\theZeichen}%
               }%
    \expandafter\startfmc%
  \fi%
}
\makeatother

% Dr. Vogel gebraucht gern das Zeichen |->> für bijektive Abbildungen.
% <news:ehom5s$bk9$1@news.BelWue.DE> <news:ehqi2q$bb4$02$1@news.t-online.com>
\makeatletter
\newcommand*{\mapstoto}{%
  \mathrel{%
    \ifpdf
      \pdfliteral direct{%
        /Span<</ActualText<FEFF2905>>>BDC%
      }%
    \fi
    \mathrel{\mapstochar\twoheadrightarrow}%
    \ifpdf
      \pdfliteral direct{EMC}%
    \fi
  }%
}
\makeatother

\makeindex

\SVN $LastChangedRevision$
\SVN $LastChangedDate$

\newcounter{cnt}
\setcounter{cnt}{1}
\whiledo{\thecnt < 27}{%
  \DeclareGraphicsRule{.\thecnt}{\ifpdf mps\else eps\fi}{*}{}%
  \stepcounter{cnt}%
}

\DeclareMathOperator{\sgn}{sgn}          % Signum/Vorzeichen
\DeclareMathOperator{\ggT}{ggT}          % größter gemeinsamer Teiler
\DeclareMathOperator{\kgV}{kgV}          % kleinstes gemeinsames Vielfaches
\DeclareMathOperator{\card}{card}        % Kardinalität

\begin{document}

\begin{center}
  \textbf{\huge Deine Stimme für Kryptologie~2!}\\[2cm]

  \begin{minipage}{.7\linewidth}
    Am 12.\,Februar soll es in Vorbereitung auf die beiden Prüfungstermine
    nochmal eine zusätzliche Stunde geben, in der Fragen zum Stoff gestellt
    werden können. Treffpunkt ist der Raum von Herrn Vogel um 10~Uhr.

    Es gibt dann auch eine Abstimmung, ob es eine Fortsetzung der Vorlesung im
    nächsten Semester geben soll. Mögliche Themen wären
    \begin{itemize}
     \item Verschlüsselungen auf elliptischen Kurven oder Gittern
     \item Die Themen Hashfunktionen und Zero-Knowledge nochmal ausführlich;
      Wie funktioniert MD5, was wurde daran gebrochen?
     \item Kryptographisch sichere Zufallszahlen
     \item Quantenkryptographie
    \end{itemize}
  \end{minipage}
\end{center}

\title{Kryptologie -- von einer Geheimwissenschaft zu einer Wissenschaft
  von den Geheimnissen}
\author{Dr.\, Jörg Vogel}
\date{WS 2006/07}
\maketitle

\clearpage
\chapter*{Vorwort}

\begin{itshape}
  Dieses Dokument wurde als Skript für die auf der
  Titelseite genannte Vorlesung erstellt und wird jetzt im Rahmen des
  Projekts
  "`\href{http://www.minet.uni-jena.de/~joergs/skripte/}
  {Vorlesungsskripte der Fakultät für Mathematik}
  \href{http://www.minet.uni-jena.de/~joergs/skripte/}{und Informatik}"'
  weiter betreut. Das
  Dokument wurde nach bestem Wissen und Gewissen angefertigt. Denoch
  garantiert weder der auf der Titelseite genannte Dozent, die Personen,
  die an dem Dokument mitgewirkt haben, noch die
  Mitglieder des Projekts für dessen Fehlerfreiheit. Für etwaige Fehler
  und dessen Folgen wird von keiner der genannten Personen eine Haftung
  übernommen. Es steht jeder Person frei, dieses Dokument zu lesen, zu
  verändern oder auf anderen Medien verfügbar zu machen, solange ein
  Verweis auf die Internetadresse des Projekts
  \url{http://www.minet.uni-jena.de/~joergs/skripte/}
  enthalten ist.

  Diese Ausgabe trägt die Versionsnummer~\SVNLastChangedRevision{} und ist vom
  \SVNDate{}. Eine neue Ausgabe könnte auf der Webseite des Projekts verfügbar
  sein.

  Jeder ist dazu aufgerufen Verbesserungen, Erweiterungen und
  Fehlerkorrekturen für das Skript einzureichen bzw. zu melden oder diese
  selbst einzupflegen -- einfach eine E-Mail an die
  \href{mailto:skripte@listserv.uni-jena.de}{Mailingliste
  \texttt{<skripte@listserv.uni-jena.de>}} senden. Weitere Informationen
  sind unter der oben genannten Internetadresse verfügbar.

  Hiermit möchten wir allen Personen, die an diesem Skript mitgewirkt
  haben, vielmals danken:
  \begin{itemize}
   \item \href{mailto:joerg@alea.gnuu.de}{Jörg Sommer
    \texttt{<joerg@alea.gnuu.de>}} (2006/07)
   \item \href{mailto:jens@kubieziel.de}{Jens Kubieziel
    \texttt{<jens@kubieziel.de>}} (2006)
   \item Michael Preis (2006)
   \item Christine List (2007)
  \end{itemize}
\end{itshape}

\clearpage
\pdfbookmark[0]{Inhaltsverzeichnis}{inhaltsverzeichnis}
\tableofcontents

\clearpage
\pdfbookmark[0]{Auflistung der Sätze}{theoremlist}
\chapter*{Auflistung der Theoreme}

\pdfbookmark[1]{Sätze}{satzlist}
\section*{Sätze}
\theoremlisttype{optname}
\listtheorems{satz}

\pdfbookmark[1]{Definitionen und Festlegungen}{definilist}
\section*{Definitionen und Festlegungen}
% \theoremlisttype{all}
\listtheorems{defini,festl}

\chapter{Einführung in die Kryptologie}

\begin{defini}[Kryptologie]
  \highl{Kryptologie} ist die Wissenschaft von der sicheren Übertragung
  (und Speicherung) von Nachrichten.

  Dabei unterscheidet man zwei Teilgebiete:
  \begin{itemize}
   \item die \highl{Kryptographie} als die Kunst des Verschlüsselns und
   \item die \highl{Kryptoanalyse} als die Kunst des Codebrechens.
  \end{itemize}
\end{defini}

Die Übertragung der Nachricht erfolgt über \highl{Kanäle}, wie z.\,B. Boten,
Kupferleitungen, Glasfasern oder drahtlose Verbindungen. Dabei kann es zu
verschiedenen Beeinträchtigungen kommen:
\begin{itemize}
 \item zufällige Störungen -- der Boote stürzt in eine Felsspalte
 \item systematische (physikalisch bedingte) Störungen --
 \item passive Beeinträchtigungen -- Abhören von Telefongesprächen,
  Auslesen von Speichermedien
 \item aktive Beeinträchtigungen -- fälschen von Nachrichten und Daten
\end{itemize}
Mit den ersten beiden Punkten beschäftigt sich die \highl{Kodierungstheorie}. Die
passiven und aktiven Beeinträchtigungen sind Gegenstand der Kryptologie.

Aus diesen Beeinträchtigungen ergeben sich Anforderungen an kryptologische
Verfahren:
\begin{itemize}
 \item \highl{Geheimhaltung} -- Lesen der Nachricht für Unbefugte möglichst
  schwierig zu machen
 \item \highl{Authentifizierung} -- Identitätsnachweis des Senders; Empfänger
  weiß, dass die Nachricht nicht von einem Unbefugten stammt
 \item \highl{Integrität} -- Nachricht wurde während der Übertragung nicht
  verändert
 \item \highl{Verbindlichkeit} -- Sender kann nicht leugnen, dass die Nachricht
  von ihm stammt
\end{itemize}

Im Laufe der Zeit hat sich das Anwendungsgebiet für Kryptologie gewandelt.
Früher wurde sie vorwiegend zur Geheimhaltung z.\,B. militärischer Anwendungen
eingesetzt, wärend heute durch den enormen Zuwachs der Kommunikation in
offenen Netzwerken Kryptologie auch verstärkt im zivilen Bereich eingesetzt
wird.

\section{Grundbegriffe}

Der \highl{Sender} --~in der Kryptologie wird dieser mit \highl{Alice}
bezeichnet~-- verschlüsselt seine \highl{Nachricht}\footnote{Nachricht: auch
\highl{Klartext} oder \highl{plain text} genannt} mit Hilfe eines
\highl[Schlüssel]{Schlüssels} unter Verwendung eines
\highl[Verschlüsselungsverfahren]{Verschlüsselungsverfahrens}%
\footnote{Verschlüsselungsverfahren: auch als \highl{Chiffrierung} oder
  \highl{encryption} bezeichnet} und erhält so einen \highl{Geheimtext}%
\footnote{Geheimtext: auch \highl{Chiffretext} oder \highl{Kryptogramm}
  genannt} für die Nachricht. Diesen sendet er dem Empfänger --~in der
Kryptologie wird dieser mit \highl{Bob} bezeichnet~--, der durch Anwendung
eines \highl[Entschlüsselungsverfahren]{Entschlüsselungsverfahrens}%
\footnote{Entschlüsselungsverfahren: auch als \highl{Dechiffrierung} oder
  \highl{decryption} bezeichnet} wieder die Nachricht rekonstruieren kann.
Die Übertragung des Geheimtexts und die damit verbundenen Probleme wie
Fehlererkennung und -korrektur sind nicht Gegenstand der Kryptologie. Mit
dieser Thematik beschäftigt sich die Codierungstheorie.

\begin{defini}[Kryptosystem]
  Ein \highl{Kryptosystem}~$\mathcal{S}$ ist ein Fünftupel
  $\mathcal{S}=(\mathcal{M}, \mathcal{C}, \mathcal{K}, E, D)$ bestehend aus:
  \begin{itemize}
   \item einer Menge von Nachrichten, die als \highl{Klartextraum}~$\mathcal{M}$
    ($\subseteq\Sigma^{\ast}$) bezeichnet wird; ein Element dieser Menge ist
    eine \highl{Nachricht}~$m\in\mathcal{M}$.

   \item dem \highl{Geheimtextraum}~$\mathcal{C}$ ($\subseteq\Gamma^{\ast}$),
    der Menge aller der verschlüsselten Botschaften~$c\in\mathcal{C}$,

   \item dem \highl{Schlüsselraum} $\mathcal{K}$, wobei jeder
    \highl{Schlüssel} $k\in\mathcal{K}$ ein Paar $k=(k_{e}, k_{d})$ ist, von
    dem $k_{e}$ zur Verschlüsselung und $k_{d}$ zur Entschlüsselung verwendet
    wird.

   \item einem \highl{Verschlüsselungsalgorithmus} $E\colon\mathcal{M}\times
    \mathcal{K}\rightarrow\mathcal{C}$ für den gilt $E(m, k_{e}) = c$,
    wobei für zwei unterschiedliche Nachrichten $m_{1}$ und $m_{2}$ gilt:
    $E(m_{1}, k_{e}) \ne E(m_{2}, k_{e})$ und

   \item einem \highl{Entschlüsselungsalgorithmus} $D\colon \mathcal{C}\times
    \mathcal{K}\rightarrow\mathcal{M}$ mit $D(c, k_{d}) = m$.
  \end{itemize}
\end{defini}

\begin{defini}
  Ein Kryptosystem $\mathcal{S}$ heißt \highl{symmetrisch}, falls $k_{e}=
  k_{d}$ (bzw. $k_{d}$ sich "`leicht"' (polynomiell) aus $k_{e}$ berechnen lässt).

  Ein Kryptosystem $\mathcal{S}$ heißt \highl{asymmetrisch}, falls die
  Kenntnis von $k_{e}$ praktisch nichts über $k_{d}$ aussagt.
\end{defini}

Aus diesen Festlegungen ergeben sich folgende Konsequenzen für die
Kommunikation zwischen Alice und Bob:
\begin{enumerate}
 \item Vor der Übertragung müssen sich beide über das
  Verfahren einigen.
 \item Viele Schlüssel sind eine notwendige Vorraussetzung (großer Schlüsselraum) für die
  Sicherheit eines Verfahrens.
 \item Vor der Übertragung müssen sie sich auf ein
  Schlüsselpaar $k=(k_{e},k_{d})$ einigen.
 \item Der Schlüssel $k_{d}$ muss geheim gehalten werden.
\end{enumerate}

Da für den Austausch des Schlüssels zwischen Alice und Bob eine sichere
Übertragung --~sozusagen eine verschlüsselte Verbindung~-- notwendig ist,
stellt sich die Frage, warum die beiden nicht gleich die Nachricht über diese
sichere Verbindung übertragen.
\begin{itemize}
 \item Im Allgemeinen ist die Nachricht wesentlich länger als der Schlüssel,
  d.\,h. der Schlüsselaustausch kann über andere (langsamere, aber sicherere)
  Kanäle als der Nachrichtenaustausch erfolgen. Alice lässt Bob das Kennwort
  durch einen Boten zukommen und der Austausch der Nachricht geschieht dann
  per E-Mail.

 \item Der Zeitpunkt der Schlüsselübergabe ist frei wählbar. Es können also bei
  einem persönlichen Treffen mehrere Schlüssel für späterere Verbindungen
  vereinbart werden.

 \item Mit demselben Schlüssel lassen sich mehrere Nachrichten verschlüsseln.
\end{itemize}

\begin{defini}[Kerkhoff'sche Prinzip]
  Das \highl{Kerkhoff'sche Prinzip} besagt, dass die \highl{Sicherheit} eines
  Kryptosystems nur von der Geheimhaltung des Schlüssels jedoch nicht von der
  Geheimhaltung des Algorithmus' abhängt.
\end{defini}

% 18.10.2006

\begin{bsp}[praktische Kryptographie]
  Der
  \href{http://de.wikipedia.org/wiki/Freimaurer-Alphabet}{\highl{Freimaurercode}}
  (zweite Zeile) arbeitet ohne Schlüssel. Jeder Buchstabe des Alphabets wird durch
  ein bestimmtes Geheimzeichen ersetzt. Damit ist der Freimaurercode kein
  Kryptosystem, da das Kerkhoff'sche Pinzip verletzt ist: Die Sicherheit
  des Kryptosystems hängt von der Geheimhaltung des Algorithmus' ab.
  \begin{center}\ttfamily\large
    dieser satz ist geheim\\
    \fmc{dieser~satz~ist~geheim}\\
    UZVJVI JRKQ ZJK XVYVZD\\
    TFZZGR EDFY ABX IFFHXY
  \end{center}

  Beim \highl{Caesarcode} (dritte Zeile) wird jeder Buchstabe des Alphabets für sich
  durch den Buchstaben, der $x$ Positionen weiter hinten steht.
  $x\in\{1,2,\dotsc,25\} = \mathcal{K}$ ist der Schlüsel dieses
  Kryptosystems -- im obigen Beispiel ist $x=17$. Jedoch ist diese Art der
  Verschlüsselung nicht sicher. Dazu später mehr.

  Beim \highl{One-Time-Pad} (vierte Zeile) ist ähnlich dem Caesarcode, jedoch
  wird hierbei (unabhängig und gleichverteilt) für jedes einzelne Zeichen der
  Nachricht eine Position $x\in\{0,1,\dotsc,25\}$ gewählt, um die dieses
  verschoben wird. Der Schlüssel für eine Nachricht $m=(m_{1},m_{2},\dotsc,
  m_{n})$ ist also ein Tupel $c=(x_{1},x_{2},\dotsc, x_{n})$ der Länge~$n$.
  Dieses Kryptosystem schützt sich nicht nur durch den großen Schlüsselraum
  $26^{n}$, sondern auch dadurch, dass jeder beliebige Text mit dem geeigneten
  Schlüssel erzeugt werden kann.
\end{bsp}

Zur Einstufung einer \highl{Kryptoanalyse} trifft man die folgende qualitative
Unterscheidungen:
\begin{itemize}
  \item \highl{vollständiges Aufbrechen}\footnote{engl. total break} heißt, dass der Schlüssel $k_{d}$
  entdeckt wird, woraufhin jede Nachricht~$m$, die mit $k_{e}$ verschlüsselt
  wird, entschlüsselt werden kann.

 \item \highl[Deduktion!global]{globale Deduktion}\footnote{engl. global
   deduction} bedeutet, dass ohne
  Kenntniss von $k_{d}$ eine zu $D(\_, k_{d})$ äquivalente Übersetzung
  gefunden wird.

 \item Als \highl[Deduktion!lokal]{lokale Deduktion}\footnote{engl. instance or
   local deduction} bezeichnet man das Finden
  eines Klartextes für einen einzelnen Chiffretext.
\item \highl{Informationsdeduktion}\footnote{information deduction} bedeutet,
  dass einige Informationen über den Schlüssel oder den Klartext gewonnen werden
  können.
\end{itemize}

Ebenso gibt es eine Unterscheidung der verschiedenen Arten eines
\highl[Angriff]{Angriffs} auf ein Kryptosystem:
\begin{description}
 \item[Cyphertext-Only-Attack:] Der Kryptoanalytiker verfügt über eine
  gewisse Menge von Geheimtexten.

 \item[Known-Plaintext-Attack:] Für einen gewissen Chiffretext ist der
  Klartext bekannt.

 \item[Chosen-Plaintext-Attack:] Für einen beliebigen Klartext ist es
  möglich, sich den zugehörigen Chiffretext zu besorgen. (Typisch für
  Public-Key-Verfahren)

  \item[Adaptive-chosen-plaintext-Attack] Spezialfall der obigen
  Attacke. Hier wählt der Kryptoanalytiker einen Klartext basierend
  auf dem Ergebnis der vorigen Verschlüsselung.

  \item[Chosen-Ciphertext-Attack] Verschiedene Chiffrate können
  entschlüsselt werden und es besteht Zugriff zum entschlüsselten Text.

  \item[Chosen-Key-Attack] Man hat Wissen über die Beziehungen
  verschiedener Schlüssel untereinander (i.\,d.\,R. nicht praktisch
  relevant)

 \item[Rubber-Hose-Cryptanalysis] Angriff durch Gewalt/Erpressung/Entführung

 \item[Brute-Force-Attack:] Alle möglichen Schlüssel austesten. Dieses
  Verfahren sollte das effektivste sein.
\end{description}

Ebenso wie Sender und Empfänger durch spezielle Namen in der Krypologie
gekennzeichnet werden, verwendet man auch für einen \highl{Angreifer} einen
speziellen Namen: \highl{Eve} heißt der Angreifer, der jedwede KOmmunikation
mitlesen kann und mit \highl{Mallory} bezeichnet man den Angreifer, der auch
Daten verändern kann.

Abhängig von der \highl{Sicherheit} des Ver-/Entschlüsselungsverfahrens kann
man Kryptosysteme in die Kategorien "`uneingeschränkt sicher"' (z.\,B.
One-Time-Pad), "`praktisch sicher"' (in praktikabler Zeit keine Lösung; die
Tageszeitung von Morgen erst nächste Woche entschlüsseln) und "`unsicher"'
(z.\,B. Caesarcode) einteilen.

Derzeit ist das One-Time-Pad das einzige bekannte, uneingeschränkt sichere
Kryptoverfahren. In der Praxis findet es hauptsächlich im militärischen Bereich
und in hochsicheren Umgebungen Anwendung.

Alle weiteren Kryptosysteme sind mit einer Ciphertext-Only-Attacke angreifbar.
Man probiert einfach jeden möglichen Schlüssel und prüft, ob der resultierende
Klartext eine Bedeutung hat. Eine derartige Attacke nennt man \highl{Brute
Force}, da diese nur mit roher Gewalt (Durchtesten aller Kombinationen)
funktioniert.

\subsection{Beispiel einer praktischen Kryptoanalyse}
Bedeuten "`viele"' Schlüssel "`hohe"' Sicherheit? \textit{Ansatz}:
Anstelle der Verschiebung der Buchstaben (beim Caesarcode) betrachten wir
eine Permutation der Buchstaben. -- Diese Zuordnung nennt man
\highl{monoalphabetisch}: Jedem Buchstaben des Klartexts wird ein
Zeichen des Chiffretexts zugeordnet.

Die Klartextbuchstaben: a b c d \dots x y z\\
Permutation (der Schlüssel): V J C E \dots A H D

Wieviele Schlüssel gibt es? $26! = 403\,291\,461\,126\,605\,635\,584\,000\,000$

Trotz dieses großen Schlüsselraums ist es möglich die Verschlüsselung zu
brechen.

\highl{Häufigkeitsanalyse:}
\begin{enumerate}[1.\,{Schritt:}]
 \item Buchstaben zählen:
  \texttt{C}: 62-mal, \texttt{Z}: 31-mal, \texttt{T}: 29-mal, \texttt{A}:
  27-mal, \texttt{F}: 22-mal, \texttt{L}: 20-mal, \texttt{J}: 19-mal, \dots

  \begin{table}
    \centering
    \begin{tabular}{cc*{3}{||cc}}
      Bst. & Wsk. & Bst. & Wsk. & Bst. & Wsk. & Bst. & Wsk.\\
      \hline
      E & 17,40\,\% & D & 5,08\,\% & O & 2,51\,\% & V & 0,67\,\%\\
      N & 9,78\,\%  & H & 4,76\,\% & B & 1,89\,\% & ß & 0,31\,\%\\
      I & 7,55\,\%  & U & 4,35\,\% & W & 1,89\,\% & J & 0,27\,\%\\
      S & 7,27\,\%  & L & 3,44\,\% & F & 1,66\,\% & Y & 0,04\,\%\\
      R & 7,00\,\%  & C & 3,06\,\% & K & 1,21\,\% & X & 0,03\,\%\\
      A & 6,51\,\%  & G & 3,01\,\% & Z & 1,13\,\% & Q & 0,02\,\%\\
      T & 6,15\,\%  & M & 2,53\,\% & P & 0,79\,\% & \\
    \end{tabular}
    \parbox{12cm}{
      \caption{Häufigkeitsverteilung der Buchstaben der deutschen
        Sprache. Die Buchstaben ä, ö, ü wurden wie ae, oe, ue gezählt.
        \textit{Quelle:
        \href{http://de.wikipedia.org/wiki/Buchstabenh\%C3\%A4ufigkeit}%
             {Wikipedia}}}}
    \label{tab:buchswsk}
  \end{table}

 \item Häufige Buchstaben ersetzen: \texttt{C} entspricht
  \texttt{e}.

  Da die Zeichenfolge \texttt{ZZ} vorkommt, ist eine weiterer Ansatz,
  dass das \texttt{Z} dem \texttt{n} entspricht

  Aus den Teilen \texttt{CHZ} (\texttt{eHn}) und \texttt{CHZCZ}
  (\texttt{eHnen}) kann man schließen, dass das \texttt{H} dem \texttt{i}
  entspricht.

  Auffällig ist die Häufung des Wortes \texttt{CT} (\texttt{eT}). Dies
  könnte \texttt{er} oder \texttt{es} sein.

  Ebenso fällt das Wort \texttt{LCT} auf. Möglich: \texttt{der} oder
  \texttt{des}. Da "`der"' häufiger in deutschen Texten vorkommt,
  verwenden wir \texttt{r} für \texttt{T} und \texttt{d} für \texttt{L}.

 \item Lücken schließen:
  \begin{itemize}
   \item \texttt{iUn} ist sehr wahrscheinlich \texttt{ihn}; \texttt{U}
    entspricht \texttt{h}.

   \item \texttt{eJ} ist nicht \texttt{er} oder \texttt{ei} (da
    \texttt{r} und \texttt{i} schon vergeben), also \texttt{es};
    \texttt{J} entspricht \texttt{s}

   \item \texttt{dAJJ} ist \texttt{dass}; \texttt{A} ist \texttt{a}

   \item \texttt{UAFFe} ist \texttt{haFFe}, also \texttt{hatte};
    \texttt{F} ist \texttt{t}

   \item Erster Teilsatz: "`es hatte ein Wann einen eseN,"'; Aus dem
    Kontext folgt: \texttt{W} entspricht \texttt{m} und \texttt{N} ist
    \texttt{e}.

   \item weiter: "`der sDhOn LauGe Sahre die saeDVe"'; \texttt{D}
    entspricht \texttt{c}, \texttt{O} ist \texttt{o}, \texttt{G} ist
    \texttt{g} und \texttt{S} ist \texttt{j} und \texttt{V} ist \texttt{k}.
  \end{itemize}
\end{enumerate}

% 23. Okt. 2006

\section{Klassische symmetrische Verfahren}

symbolisch: Zwei identische (daher symmetrisch) Schlüssel -- einer beim
Empfänger, einer beim Sender --, die beide eine Schatzkiste öffnen.

2 Unterscheidungsmerkmale:
\begin{enumerate}
 \item \highl{Substitution} vs. \highl{Translation}
  \begin{description}
   \item[Substitution]
    \begin{itemize}
     \item jeder Buchstabe wird durch ein Geheimtextalphabet
      verschlüsselt.
     \item jeder Buchstabe an seinem Platz
    \end{itemize}

   \item[Translation]
    \begin{itemize}
     \item jeder Buchstabe seine Gestalt
     \item die Buchstaben ändern ihre Position
    \end{itemize}
  \end{description}

  heute: Verallgemeinerung durch Kombination beider "`Urformen"'.

 \item \highl{Stromchiffre} vs. \highl{Blockchiffre}
  \begin{description}
   \item[Stromchiffren]
    \begin{itemize}
     \item jeder Buchstabe wird einzeln für sich verschlüsselt

     \item häufig wird für eine Nachricht $m=m_{1}m_{2}\dotso m_{n}$ und
      einen Anfangsschlüssel $k$ ein "`Strom von Schlüsseln"'
      $k_{1},k_{2},\dotsc, k_{n}$ erzeugt.
    \end{itemize}

   \item[Blockchiffren]
    \begin{itemize}
     \item Aufteilung des Klartextes in (längere) Blöcke, die
      verschlüsselt werden
    \end{itemize}
  \end{description}
\end{enumerate}

\chapter{Substitionen}

Substitutionen werden unterschieden als:
\begin{enumerate}
 \item \highl{monoalphabetisch}: jeder Buchstabe des Klartextalphabets
  wird stets durch denselben Buchstaben des Geheimtextalphabets ersetzt

 \item \highl{polyalphabetisch} sonst
\end{enumerate}

\section{Monoalphabetische Substitutionen}

O.\,B.\,d.\,A. entspricht das Klartextalphabet $\Sigma$ dem Geheimtextalphabet $\Gamma$.
Wir legen uns weiter auf das Beispielalphabet $\{a,b,c,\dotsc,x,y,z\}$ fest
und schreiben es in der Form $X=\{0,1,2,\dotsc,\linebreak[1] 23,24,25\}$. Dann gilt:
$\abs{X} = 26$. Für $\abs{X}=n$ denken wir uns $X=\{0,1,2,\dotsc, n-2,\linebreak[1] n-1\}$.

\subsection{Verschlüsselungsverfahren}

Eine \highl{Verschlüssung} in diesem Rahmen ist eine Permution $\pi\colon X
\mapstoto X$ (Schlüssel). Aus einer Nachricht $m=m_{1}m_{2}\dotso m_{k}$ wird
der Geheimtext $c=\pi(m_{1})\pi(m_{2})\dotso \pi(m_{k})$. Es gibt hier $n!$
verschiedene Schlüssel, aber wir wissen bereits, dass dieses Verfahren
krypographisch auf Grund der \highl{Häufigkeitsverteilung} auch bei
\highl{Ciphertext-Only-Attakten} unsicher ist.

\subsection{Verschiebechiffre (Caesar)}

Die \highl{Verschiebechiffren} --~auch \highl{Caesar-Chiffre} genannt~-- sind
die einfachste Form der monoalphabetischen Substitution. Jeder Buchstabe wird
durch seinen $i$.~Nachfolger ersetzt, wobei man wieder bei A beginnt, wenn man
Z überschreitet.

Anschaulich kann man sich eine Verschlüsselungsvorschrift so vorstellen, dass
unter die Buchstaben~A bis~Z die Buchstaben beginnend mit dem $i$.~Buchstaben
bis~Z und weiter von A bis zum $(i-1)$.~Buchstaben stehen. Jeder Buchstabe des
Klartextes wird durch den Buchstaben, der unter ihm in der zweiten Zeile
steht, ersetzt.

Mathematisch ausgedrück, kodiert man die Buchstaben~A bis~Z mit den Zahlen~0
bis~25 und ordnet jedem Buchstaben den durch die Abbildung $x\mapsto
x+i\pmod{26}$ beschriebenen Buchstaben zu.

Der Schlüssel für die Verschlüsselung ist dabei $i\in\{0,1,\dotsc,25\}$, die
Anzahl der Positionen, um die der Buchstabe verschoben wird.

Das Verfahren hat den Nachteil, das nur wenige ($n$) Schlüssel verfügbar sind
und das die Verschlüsselung gebrochen ist, wenn \textit{ein} Buchstabe übersetzt
ist.

\subsection{Tauschchiffren}
\label{sec:tausch}

\highl{Tauschchiffren} sind eine Verallgemeinerung der Verschiebechiffren. Die
Buchstaben werden ebenfalls durch
Zahlen kodiert, mit denen dann gerechnet wird. Jedes Zeichen~$x\in
\{0,\dotsc,n-1\}$ wird durch die affinlineare Abbildung $x\mapsto x\cdot
a+b\pmod{n}$ in das Geheimzeichen überführt. Der Schlüssel ist dabei das Paar
$(a,b)\in \{0,\dotsc,n-1\}^{2}$.
Bei den Verschiebechiffren ist $b=0$.

Damit die Entschlüsselung möglich ist, muss die Abbildung bijektiv sein. Dazu
müssen $a$ und $n$ teilerfremd sein. Es gibt also $\phi(n)$\footnote{Eulersche
$\phi$-Funktion; siehe \autoref{sec:restklassen}} Möglichkeiten $a$ zu wählen
und insgesamt $\phi(n)\cdot n$ Schlüssel $(a,b)$.

Ein kurzes Gegenbeispiel, um das Problem zu verdeutlichen: Wählt man $n=26,
a=13$ und $b=0$, so wird das Zeichen~2 als $E(2) = 2\cdot 13+0 \pmod{26} = 0$
als auch das Zeichen~0 als $E(0) = 0 \cdot 13 +0 \pmod{26}$ verschlüsselt.
Eine Entschlüsselung des Zeichens~0 ist also nicht möglich.

\begin{bsp}
  Der Klartext "`text"' wird mit dem Schlüssel~$(5,13)$ auf den Geheimtext
  "`EHYE"' abgebildet.
  \begin{center}
    \begin{tabular}{c|cc|c}
      Buchstabe& Codierung~$x$& $x\cdot 5+13$& Decodierung\\
      \hline
      t& 19& 4& E\\
      e& 4& 7& H\\
      x& 23& 24& Y\\
      t& 19& 4& E
    \end{tabular}
  \end{center}
\end{bsp}

Die Nachteile der Tauschchiffren sind:
\begin{itemize}
 \item Verschlüsselung ist gekackt, wenn \textit{zwei} Buchstaben übersetzt
  sind und
 \item Häufigkeitsverteilung der natürlichen Sprache bleibt erhalten.
\end{itemize}

Die \highl{Tauschchiffren} werden in einer allgemeineren Form nochmal im
\autoref{sec:afflin} besprochen.

\section{Homophone Substitutionen}

\highl{Homophone Substitutionen} versuchen die strukturelle Schwäche der
monoalphabetischen Verschlüsselung, die durch die Häufigkeitsverteilung
der Buchstaben bei natürlichen Sprachen gegeben ist, aufzuheben.

Dazu führt man ein \textit{neues} und \textit{größeres} Geheimtextalphabet $Y$
und eine Abbildung $f\colon X\mapsto \mathfrak{P}(Y)$ ein, wobei verschiedene
Buchstaben disjunkten Teilmengen entsprechen. Für eine Nachricht
$m=m_{1}m_{2}\dotso m_{k}$ ist der Geheimtext $c=c_{1}c_{2}\dotso c_{k}$,
wobei $c_{i}$ zufällig aus $f(m_{i})$ gewäht wird. (Italien um 1400).

\begin{bsp}
  Für das Klartextalphabet $X=\{a,b,c\}$, wobei die Buchstaben mit den
  Wahrscheinlichkeiten 0,5\,\%, 0,35\,\% und 0,15\,\% vorkommen, verwenden wir das
  Geheimalphabet $Y=\{0,1,\dotsc,7\}$. Dazu definieren wir die Abbildung $f$
  wie folgt
  \begin{gather*}
    f(x) =
       \begin{cases}
         \{0, 3, 4, 7\} &\colon x= a\\
         \{1, 5, 6\} &\colon x=b\\
         \{2\} &\colon x=c
       \end{cases}
  \end{gather*}

  Der Buchstabe $b$ wird also durch die drei Zeichen 1, 5 und 6 codiert. Das
  Wort cbba könnte z.\,B. als 2514 oder 2663 verschlüsselt werden.
\end{bsp}

Der Vorteil einer solchen homophonen Substitution besteht darin, dass die
Häufigkeitsverteilung der Klartextbuchstaben zerstört wird, wenn für alle
$x\in X$, wobei $p(x)$ die relative Häufigkeit ist, mit der der Buchstabe $x$
in Texten auftritt, $f(x)$ so gewählt wird, dass $\frac{p(x)}{\abs{f(x)}}$ für
alle $x$ annähernd gleich ist!

Der Effekt des Ganzen ist, dass im Geheimtext alle Buchstaben des
Geheimtextalphabets~$Y$ etwa gleichwahrscheinlich auftreten!

\begin{bemerk}
  Es gibt ein homophones Verschlüsselungsverfahren mit folgender Eigenschaft:
  Für jeden Geheimtext~$c$ gibt es mindestens zwei verschiedene Schlüssel, die
  $c$ in zwei verschiedene, sinnvolle Klartexte überführen.
\end{bemerk}

\begin{table}
  \centering
  \begin{tabular}{c|*{6}{c}}
     & $x_{1}$ & $x_{2}$ & \dots & $x_{i}$ & \dots & $x_{n}$\\
    \hline
    $x_{1}$ & $y_{\frac{n^{2}}{9}}$ & $y_{\frac{7n^{2}}{8}}$ &
       \dots & $y_{\frac{n^{2}}{4}}$ & \dots & $y_{\frac{n^{2}}{2}}$\\
    $x_{2}$ & $y_{n^{2}}$ & $\ddots$\\
    \vdots &\\
    $x_{j}$ &\\
    \vdots & & & & & $\ddots$ & \vdots\\
    $x_{n}$ & & & & & \dots & $y_{\frac{n^{2}}{12}}$
  \end{tabular}
  \caption{Zuordnung von $n$ Zeichen des Klartextalph. auf $n^{2}$
    Zeichen des Geheimalph.}
  \label{tab:1}
\end{table}

Wie funktioniert dies? Das Klartextalphabet sei $X$ (mit $\abs{X}=n$) und
$Y$ (mit $\abs{Y}=n^{2}$) das Geheimtextalphabet. Der Schlüsselraum wird
beschrieben durch eine $n\times n$-Matrix. Die Zeilen und Spalten werden mit
den Buchstaben aus $X$ indiziert und die Eintragungen sind die (zufällig
angeordneten) Buchstaben von $Y$. Siehe \autoref{tab:1}. Wir definieren zwei
Abbildungen:
\begin{align*}
  f_{1}(x_{j}) &= \{ y\in Y\colon y \text{~steht in der $j$. Zeile} \}\\
  f_{2}(x_{i}) &= \{ y\in Y\colon y \text{~steht in der $i$. Spalte} \}
\end{align*}

Es sei $m=m_{1}m_{2}\dotso m_{k}$ der zu verschlüsselnde Klartext und
$l'=l_{1}'l_{2}'\dotso l_{k}'$ ein weiterer sinnvoller Klartext gleicher Länge.

Als Verschlüsselung für $m_{i}$ verwenden wir den Eintrag in der Matrix, der
im Schnittpunkt von $m_{i}=x_{r}$ und $l_{i}=x_{s}$ ($r$-ter Zeile und $s$-ter
Spalte) liegt.
\begin{gather*}
  m_{i}\mapsto c_{i}\in f_{1}(m_{i}) \cap f_{2}(l_{i})
\end{gather*}

Ein \highl{Brute-force-Angriff} bleibt bei solch einer Verschlüsselung
prinzipell wirkungslos, weil jeder Geheimtext in zwei verschiedene,
\textit{sinnvolle} Klartexte übersetzt werden kann!

Jedoch bleibt weiterhin der Nachteil bestehen, dass für alle $x\in X$ ist
$\abs{f(x)}$ gleich groß ist. Damit die Forderung, dass $\frac{p(x)}%
{\abs{f(x)}}$ für alle $x$ annähernd gleich ist, verletzt. Aber die Idee ist,
dass der Angreifer nicht sagen kann, welcher der beiden konkurrierenden
Klartexte der richtige ist.

% 25. 10. 2006

\begin{bsp}
  Das Klartextalphabet $X$ sei das deutsche Alphabet und wir wählen als
  Geheimtextalphabet $Y=\{00, 01, \dotsc, 10,11,\dotsc,99\}$
  ($\abs{Y}=100$). Die Zuordnung $f\colon X\rightarrow
  \mathfrak{P}(Y)$ wählen wir so, dass gilt: Für alle Buchstaben $x\in X$ ist $\abs{f(x)}\approx
  p(x)\cdot 100$.

  In der Tabelle mit Häufigkeiten der Buchstaben \autoref{tab:buchswsk} sehen
  wir, dass z.\,B. \texttt{c} mit der Wahrscheinlichkeit 3,06\,\% auftritt.
  Also wählen wir zufällig für \texttt{c} drei Zeichen aus $Y$, z.\,B. $07, 23, 42$.
\end{bsp}

\subsection{Ansatz zur Kryptoanalyse einer homophonen Verschlüsselung}

Eine weitere Idee für einen Angriff ist andere Unregelmäßigkeiten --~neben der
Häufigkeitsverteileung der Buchstaben~-- in der deutschen Sprache zu finden.
Dazu betrachten wir sogenannte \highl{Digramme} (Zweierfolgen von Buchstaben)
in Texten. Dafür gibt es insgesamt $2^{26}$ mögliche Paarungen. Beispiele für
Digramme sind \textit{en} und \textit{er}, die mit einer Wahrscheinlichkeit
von ca.~4\,\% in deutschen Texten auftreten. Das Digramm \textit{ch} tritt mit
einer Wahrscheinlichkeit von ca.~2,75\,\% und die Digramme \textit{de},
\textit{te}, \textit{nd}, \textit{ei}, \textit{ie}, \textit{es}, \textit{in}
treten mit der Wahrscheinlichkeit von ca.~2\,\% auf.

Damit haben wir bereits eine Anomalie gefunden. Wärend die Buchstaben
\textit{e} und \textit{n} häufig auftreten und auch das Digramm aus beiden
\textit{en} häufig auftritt, ist es im Fall von \textit{c}, \textit{h} und
\textit{ch} nicht so. Die einzelnen Buchstaben sind recht selten (siehe
\autoref{tab:buchswsk}), das Digramm jedoch tritt sehr häufig auf.

Ausgangspunkt: Verschlüsselung von \glq{}c\grq{}. Es $\abs{f(c)} =k$
(z.\,B. $k=3$) Dann müssen (etwa) folgende Relationen erfüllt sein:
$\abs{f(\mathtt{e})}\approx 6k, \abs{f(\mathtt{n})} \approx 3k,
\abs{f(\mathrm{i})} \approx 2\mathord{,}5k, \abs{f(\mathrm{r})} \approx
2\mathord{,}5k$

"`en"' wird auf $6k\cdot 3k = 18k^{2}$ verschiedene Weisen verschlüsselt.
"`ch"' wird auf $k\cdot 1\mathord{,}5k = 1\mathord{,}5k^{2}$ verschiedene Weisen verschlüsselt.

Ein Digramm, dass "`en"' verschlüsselt, tritt mit einer Häufigkeit von
$\frac{4\,\%}{18}\approx 0\mathord{,}25\,\%$ auf. Für "`ch"' ist die Häufigkeit
$\frac{2\mathord{,}5\,\%}{1\mathord{,}5\,\%}\approx 1\mathord{,}6\,\%$.

Dies ist ein Ansatz zunächst die Verschlüsselung für \textit{c} und
\textit{h} zu knacken. Vorraussetzung für einen solchen Angriff ist aber
ein wirklich langer Geheimtext!

\section{Polyalphabetische Verschlüssung}

Polyalphabetische Verschlüssung hat ebenfalls das Ziel, die Häufigkeit
der Buchstaben zu verwischen. Ein prominentes Beispiel ist
\highl{Vigenère-Chiffre} von dem franz. Diplomat Blaise Vigenère (16.\,Jh.),
die erst im 19.\,Jahrhundert gebrochen wurde.

\begin{table}
  \centering
  \begin{minipage}{13.5cm}
    \ttfamily\footnotesize
    ~~~%
    \setcounter{cnt}{1}%
    \whiledo{\thecnt < 27}{%
      \alph{cnt}~~%
      \stepcounter{cnt}%
    }\\
    \newcounter{cntline}\setcounter{cntline}{1}%
    \newcounter{cntcol}%
    \setcounter{cnt}{1}%
    \whiledo{\thecntline < 27}{%
      \ifthenelse{\thecnt > 26}{\addtocounter{cnt}{-26}}{}%
      \alph{cnt}~~%
      \setcounter{cntcol}{1}%
      \whiledo{\thecntcol < 27}{%
        \ifthenelse{\thecnt > 26}{\addtocounter{cnt}{-26}}{}%
        \Alph{cnt}~~%
        \stepcounter{cnt}%
        \stepcounter{cntcol}%
      }\\
      \stepcounter{cnt}%
      \stepcounter{cntline}%
    }
  \end{minipage}
  \caption{Das Vigenère-Quadrat.}
  \label{tab:vig}
\end{table}

Die Idee der Vigenère-Chiffre ist, dass jeder Buchstabe mit einer anderen
Caesar-Chiffre verschlüsselt wird, aber nicht zufällig, sondern strukturiert.
Mit Hilfe eines Schlüsselworts.

\begin{bsp}
  Als Schlüsselwort nehmen wir "`ALLGAEU"' und als Klartext "`emmentaler"'.

  \texttt{emmentaler}\\
  \texttt{ALLGAEUALLGAEU}\\
  \texttt{EXXKNXULPC}

  Verschlüsselung ist einfach.
\end{bsp}

\begin{bemerk}
  Wir sehen folgendes in dem Beispiel: "`e"' wird zu "`E"', "`K"' und
  "`P"'. Umgekehrt entsteht "`X"' aus "`m"' und "`t"'.

  Das ist eine neue Situation.
\end{bemerk}

\subsection{Formale Beschreibung}

zunächst allgemein: ein Klartextalphabet $X$ mit $\abs{X}=n$ (z.\,B.
$n=26$) und $d$ Geheimtextalphabete $Y_{0}, Y_{1}, \dotsc, Y_{d-1}$. Dazu
$d$ bijektive Abbildungen $f_{i}\colon X \mapstoto Y_{i}$
($i=0,\dotsc,d-1$) und eine surjektive Abbildung $h\colon\N\mapsto
\{0,1,\dotsc,d-1\}$ ($h(x)=x\pmod{d}$).

Klartext: $m=m_{1}m_{2}\dotso m_{t}$ ($m_{j}\in X$)\\
Geheimtext: $c= f_{h(1)}(m_{1}) f_{h(2)}(m_{2}) \dotso f_{h(t)}(m_{t}) =
c_{1} c_{2}\dotso c_{t}$\\
Schlüssel: ist bestimmt durch $h$ und $f_{0}, f_{1}, \dotsc, f_{d-1}$. Es
wird der "`Schlüsselstrom"' $f_{h(1)}, f_{h(2)}, \dotsc, f_{h(t)}$
erzeugt. Daher \highl{Stromchiffre}.

jetzt für Vigenère: $X=\{0,1,\dotsc,n-1\}$ und $n=26$
$Y_{0}=Y_{1}=\dotsb= Y_{d} = X$. Dabei ist $d$ die Länge des
Schlüsselworts. $h(x) = x\pmod{d}$ (für jede Position $x\in\N$).
$f_{i}(a) = a+ j_{i}\pmod{n}$ (für $a\in X$) für festes $j_{i}\in X$.
Der Schlüssel ist dabei $j_{0},j_{1},j_{2},\dotsc$.

Effekt: Unterschiedliche Buchstabenhäufigkeiten werden ausgeglichen!

Und weil's so schön war, noch ein
\begin{bsp}
  Statt dem Alphabet $\{a, b, c, \dotsc, x,y,z\}$ verwenden wir
  $X=\{0,1,\dotsc,25\}$. Als Schlüsselwort nehmen wir "`KRYPTO"' ($d=6$
  mit sechs verschiedenen Buchstaben) als $10,17,24,15,19,14 =
  j_{0},j_{1}, j_{2}, j_{3}, j_{4}, j_{5}$. Klartext:
  "`kommemorgennicht"' = $10,14,12,12,04,12,14,17,06,04,13,13,08,02,07,19$

  Wir machen uns eine Tabelle.
  \begin{tabular}{l*{6}{|c}|}
    Schlüsselwort & 10 & 17 & 24 & 15 & 19 & 14\\
    \hline
    1.\,Zeile     & 10 & 14 & 12 & 12 & 04 & 12\\
                  & 20 & 05 & 10 & 01 & 23 & 00\\
    \hline\hline
    3.\, Zeile    & 14 & 17 & 06 & 04 & 13 & 13\\
                  & 24 & 08 & 04 & 19 & 06 & 01\\
    \hline\hline
    5.\,Zeile     & 08 & 02 & 07 & 19\\
                  & 18 & 19 & 05 & 08
  \end{tabular}

  Geheimtext: UFKBXAYIETGBSTFI
\end{bsp}

% 2006-10-30

\subsection{Analyse der polyalphabetischen Verschlüsselung}

Der Angriffspunkt bei der polyalphabetischen Verschlüsselung ist die
Periodizität. Bei einer Periodenlänge~$d$ bezeichnet man als einen
\highl{Teiltext} die Buchstabenfolge an den Positionen $k+nd$ für
$1\leq k \leq d$ und $n\in\N_{0}$. Wenn man den Text in Form einer Tabelle mit
der Breite der Schlüsselwortlänge aufschreibt, dann ist jede Spalte von oben
nach unten gelesen ein Teiltext.

Obwohl die Teiltexte keine sinnvollen Texte sind, stellt sich bei "`langen"'
Teiltexten die gleiche Häufigkeitsverteilung der Buchstaben wie bei einem
richtigen Text ein. Innerhalb der Spalten findet man also eine
Buchstabenhäuigkeit wie bei einem natürlichen Text.

Die einzelnen Teiltexte sind also monoalphabetisch verschlüsselt. Man kann
also im ersten Schritt die Schlüssellänge bestimmen und im zweiten Schritt die
monoalphabetischen Teiltexte mit Hilfe der Häufigkeitsanalyse entschlüsseln.

\subsubsection{Brute-force-Angriff auf polyalphabetische Verschlüsselung}

Aus Erfahrung weiß man, wenn ein Geheimtext, der durch polyalphabetische
Verschlüsselung entstanden ist, mit einem Schlüssel der falschen Länge
entschlüsselt wird, ist die Häufigkeitsverteilung nivelliert. Man kann also
systematisch $d=1,2,3,\dotsc$ durchprobieren bis man für den entschlüsselten
Text eine natürliche Verteilung der Buchstaben gefunden hat.

Dies funktioniert nur für kleine $d$!

\subsubsection{Kasiski-Test}\index{Kasiski-Test}

Charles Babbage entdeckte 1854 die Möglichkeit, die Länge des
Schlüsselworts für einen polyalphabetisch verschlüsselten Text zu
bestimmen. Es wurde aber nach Kasiski benannt, der sie das erste Mal
veröffentlichte.

Wenn man die polyalphabetische Verschlüsselung betrachtet, fällt auf, dass
Buchstabenfolgen, die sich im Abstand eines Vielfachen der Periodenlänge
wiederholen, auf das gleiche Muster im Geheimtext abgebildet werden. Häufig
auftretenden Buchstabenkombinationen werden also an mehreren Stellen im Text
auf die gleiche Weise verschlüsselt.

Beispiele für solche Muster können die Artikel der, die, das, ein oder eine
sein, die häufig in einem Text vorkommen und somit auch wiederholt in der
gleichen Spalte bei der Verschlüsselung beginnen.

Findet man also in einem Geheimtext Muster, die länger als zwei Zeichen sind
und mehrfach auftreten, so können dies Buchstabenfolgen sein, die auf die
gleiche Weise verschlüsselt wurden. Die Länge des Schlüsselworts muss also ein
Teiler des Abstands der Wiederholungen des Musters sein.

Man kann mit mehreren Mustern und anhand ihrer Struktur (längere Muster sind
eher das Ergebnis eines Musters im Klartext als eine zufällige Wiederholung im
Geheimtext) eine (oder ein paar) Vermutungen über die Schlüssellänge finden.

\subsubsection{Friedman-Test}\index{Friedman-Test}

Von William Friedman (1891--1969) stammt die Idee, die Periodenlänge mit Hilfe
statistischen Methoden zu bestimmen. Die entscheidende statistische
Größe ist der Koinzidenzindex~$I(t)$ für einen Text~$t$.

Für ein Alphabet $A=\{a_{1},\dotsc, a_{n}\}$ mit $\abs{A}=n$ und einen
Text~$t$ der Länge~$l$ ist der \highl{Koinzidenzindex}~$I(t)$ die
Wahrscheinlichkeit dafür, dass an zwei zufällig gewählten Positionen in dem
Text der selbe Buchstabe steht.

Es sei $l_{i}$ die absolute Häufigkeit (Anzahl der Vorkommen) des
Buchstabens~$a_{i}$ im Text, d.\,h. $l=\sum_{i=1}^{n} l_{i}$. Für einen Text
der Länge~$l$ gibt es $\binom{l}{2}$ zufällig gewählte Zweiermengen von
Positionen. Die Anzahl der Mengen von zwei zufällig gewählten Positionen mit
gleichen Buchstaben beträgt
\begin{gather*}
  \sum_{i=1}^{n} \binom{l_{i}}{2} = \sum_{i=1}^{n} \frac{l_{i}(l_{i}-1)}{2}
\end{gather*}

Damit ergibt sich die Wahrscheinlichkeit, dass an zwei zufällig gewählten
Positionen zwei gleiche Buchstaben im Text~$t$ stehen:
\begin{align}
  I(t) &= \sum_{i=1}^{n} \frac{\binom{l_{i}}{2}}{\binom{l}{2}}
     = \sum_{i=1}^{n} \frac{l_{i}(l_{i}-1)}{l(l-1)}
     = \sum_{i=1}^{n} \frac{l_{i}^{2}}{l(l-1)}
     - \sum_{i=1}^{n} \frac{l_{i}}{l(l-1)} \notag\\
  &= \frac{l}{l-1} \sum_{i=1}^{n} \Bigl(\frac{l_{i}}{l}\Bigr)^{2} -
     \frac{1}{l-1} \label{eq:koinzi}
\end{align}

Für einen hinreichend großen Text, d.\,h. $l\rightarrow\infty$, in deutscher
Sprache~$t_{d}$ mit den Buchstabenhäufigkeiten aus \autoref{tab:buchswsk}
ergibt sich ein \highl{Koinzidenzindex}~$I_{d} := I(t_{d}) \approx 0\mathord{,}0762$.

Der Koinzidenzindex für einen hinreichend großen Zufallstext~$t_{z}$ der
Länge~$l$, bei dem alle Buchstaben gleichhäufig auftreten $l_{1}=l_{2}=\dotsb=
l_{n}$, ist
\begin{gather*}
  I(t_{z}) = \frac{l}{l-1} \sum_{i=1}^{n} \Bigl(\frac{1}{n}\Bigr)^{2} - \frac{1}{l-1}
     = \frac{l}{l-1} \frac{1}{n} - \frac{1}{l-1}
     \xrightarrow{l\rightarrow\infty} \frac{1}{n}
\end{gather*}
Legt man ein Alphabet mit 26~Buchstaben zugrunde, ergibt sich so ein
\highl{Koinzidenzindex}~$I_{z} := \frac{1}{26} \approx 0\mathord{,}0385$.

\begin{bemerk}
  Der entscheidende Fakt für den Friedman-Test, der einen Angriff auf die
  Verschlüsselung ermöglicht, ist, dass die Wahrscheinlichkeit an zwei
  zufällig gewählten Positionen denselben Buchstaben zu finden, in deutschen
  Texten (und Texten anderer natürlicher Sprachen) etwa doppelt so groß wie in
  Zufallstexten ist.
\end{bemerk}

In einem Geheimtext~$c$ der Länge~$l$, der das Ergebnis einer
polyalphabetischen Verschlüsselung mit Periode~$d$ ist, sind die Buchstaben in
einem Teiltext ($k, d+k, 2d+k,\dotsc$) entsprechend der Buchstabenhäufigkeit
der Spache verteilt. Zwischen den Teiltexten (d.\,h. von einer Spalte zu einer
anderen) sind die Buchstaben jedoch zufällig verteilt. (Eigenschaft der
polyalphabetischen Verschlüsselung.)

% Wählt man zufällig zwei Positionen in einem Teiltext, so trifft man mit einer
% Wahrscheinlichkeit von $I_{d}$ auf zwei gleiche Buchstaben. Wählt man zufällig
% zwei Positionen aus dem gesamten Geheimtext, so ist die Wahrscheinlichkeit für
% zwei gleiche Buchstaben $I_{z}$.

Die Teiltexte haben die Länge~$\frac{l}{d}$. Also gibt es
\begin{gather*}
  d\cdot \binom{\frac{l}{d}}{2} = \frac{l(l-d)}{2d}
\end{gather*}
zufällige Paare in ein und demselben Teiltext über alle Teiltexte. Für die
zufälligen Paare in unterschiedlichen Teiltexten bleiben
\begin{gather*}
  \frac{1}{2} \cdot l\cdot (l-\frac{l}{d}) = \frac{l^{2}(d-1)}{2d}
\end{gather*}
Möglichkeiten. ($l$ Möglichkeiten für die erste Position; $l-\frac{l}{d}$
Möglichkeiten für die zweite Position in den anderen Spalten; $\frac{1}{2}$
da es kein geordnetes Ziehen ist)

% 2006-11-01

Damit ist die Wahrscheinlichkeit im gesamten Geheimtext~$c$ an zwei zufällig
gewählten Positionen die gleichen Buchstaben zu finden
\begin{gather}
  \label{eq:koinzi_poly}
  I(c) =
     \frac{\frac{l(l-d)}{2d}\cdot I_{z} + \frac{l^{2}(d-1)}{2d}\cdot I_{d}}%
          { \frac{l(l-1)}{2} }
\end{gather}

Da man den Koinzidenzindex~$I(c)$ für den verschlüsselten Text mit der
\autoref{eq:koinzi} bestimmen kann, kann man so einen Schätzwert für die
Periodenlänge~$d$ der Verschlüsselung aus \autoref{eq:koinzi_poly} ableiten.
\begin{gather*}
  d = \frac{l(I_{d}-I_{z})}{I_{d} - lI_{z} +(l-1)I(c)}
\end{gather*}

Diese Schätzung kann man mit den Ergebnissen aus einem Kasiski-Test oder einem
Brute-Force-Angriff vergleichen, um die Möglichkeiten für die wahre
Periodenlänge genauer einzuschränken.

\subsection{Möglichkeiten der Verteidigung gegen die Analyse}

Ausgangspunk: Die oben formulierten Tests funktionieren nur für kleine
Periodenlängen ($d\ll l$)! Deshalb: 1) Betrachten von großen Periodenlängen,
technische Realisierung in der \highl{ENIGMA} -- 1920 deutsches Patent mit
drei Rotoren: Periodenlänge $26^{3}$, Einsatz im Krieg mit fünf Rotoren:
Periodenlänge $26^{5}$.

2.\,Ansatz: nicht periodische Verschlüsselung: a) mit einem
"`Schlüsselroman"', d.\,h. aus einem vorher gewählten Buch wird ein Text
ausgewählt -- Schlüssel ist dann (Seite, Zeile, Buchstabe). Aber dann
funktioniert wieder die Häufigkeitsanalyse, weil der Roman wieder die
Charakteristik einer natürlichen Sprache hat. (in diese Kategorie fällt auch
das anhängen des Klartextes an das Schlüsselwort.)

b) mit Zufallstexten, führt wieder zu \highl{One-Time-Pad} und damit zum
absolut sicheren Code -- aber unpraktikabel.

\chapter{Transpositionen}

Klartextbuchstaben bleiben Klartextbuchstaben, ändern aber ihr Position. Die
Häufigkeitsanalyse von Buchstaben als Angriff ist wirkungslos, da der Text nur
permutiert wurde. (Aber Digramme sind ein Versuch wert!)

Verschiedene Ansätze der Verschlüsselung:
\begin{itemize}
 \item \highl{Blocktransposition}: Klartext wird in Blöcker einer festen
  Länge~$k$ eingeteilt. Diese Blöcke werden derselben Permutation~$\pi$
  unterworfen. Beispiel: $a_{i_{1}}a_{i_{2}}\dotso a_{i_{k-1}}a_{i_{k}} =
  a_{i_{\pi(1)}} a_{i_{\pi(2)}}\dotso a_{i_{\pi(k-1)}}a_{\pi(i_{k})}$.

  Analyse:
  \begin{enumerate}[1.\,{Schritt}]
   \item Rate/Bestimme die Blocklänge~$k$
   \item Erzeuge durch geegnete Permutationen bekannte Anagramme. Teste an
    anderen Blöcken.
  \end{enumerate}
  Dies funktioniert sehr gut.

 \item \highl{Spaltentransposition}:
  \begin{enumerate}
   \item Klartext wird zeilenweise in ein Rechteck der Breite~$k$ eingelesen
    (Höhe hängt von der Länge~$l$ des Klartexts ab)
   \item permutiere die $k$~Spalten (wie oben)
   \item Lies den Geheimtext spaltenweise aus (Im Unterschied zur
    Blocktransposition, wo der Geheimtext zeilenweise ausgelesen wird.)
  \end{enumerate}
\end{itemize}

\begin{bemerk}
  Wenn für die Spaltentransposition die Identität als Permutation verwendet
  wird, hat man die \highl{Gartenzaunchiffre}.
\end{bemerk}

\begin{bsp}
  Klartext:
  \begin{verbatim}
  krypto  rptoky
  logieu  oieulg
  nddate  datend
  nsiche  scheni
  rheita  hitare
  \end{verbatim}
  Das letzte \textit{a} ist Füllmaterial, $k=6, \pi = (1, 5, 3, 6, 4, 2)$

  Text für Blockchiffre: "`rodsh\,piaci\,tetht\,oueea\,ygdie"'
\end{bsp}

Analyse:
\begin{enumerate}[1.\,{Schritt}]
 \item Schätze die Spaltenzahl~$k$, Teiler der Gesamtlänge~$l$
 \item Bestimmung benachbarter Spalten (suche nach Anagrammen)
\end{enumerate}

\begin{bsp}
  Die erste Zeile für $k=11$ enthält zu viele Konsonanten und die letzte Zeile
  zu viele Vokale für einen deutschen Text.

  Idee: 1. und letzte Spalte liegen nebeneinander, da auf ein \textit{c} sehr
  of ein \textit{k} oder ein \textit{h} folgt.

  Die sechste Spalte kommt vor die erste und dann können wir das Wort in der
  ersten Zeile erraten "`zwei"': 3., 5., 1., 6., 2., 4.
\end{bsp}

% 13.11.06

\chapter{Blockchiffren}
\section{Allgemeines}

Wir bleiben zunächst noch bei den symmetrischen Verschlüsselungsverfahren und
versuchen durch eine Vergrößerung des Schlüsselraums die Verfahren sicherer zu
machen. Im Folgenden beschränken wir uns auf (rechnerfreundliche) Bitfolgen,
d.\,h. wir arbeiten mit Teilmengen von $\Z_{2}^{n}$.

\begin{defini}[Blockchiffre]
  Bei einer \highl{Blockchiffre} wird der Klartext in Blöcke einer frei
  wählbaren, aber festen Länge~$n$ (z.\,B. 32, 64 oder 128~Bit) zerlegt. Diese
  wird als \highl{Blocklänge} bezeichnet. Eine Verschlüsselungsfunktion~$f$
  erzeugt unter Verwendung eines Schlüssels Geheimtextblöcke der
  \textit{gleichen} Länge.
\end{defini}

Damit eine Entschlüsselung des Textes möglich ist, muss die Verschlüsselung
bijektiv seien und da sie von $\Z_{2}^{n}$ auf $\Z_{2}^{n}$ abbildet, ist sie
eine Permutation der $2^{n}$ möglichen Blöcke. Es gibt also $2^{n}!$
mögliche Funktionen zur Verschlüsselung.

Ein kleines Gedankenspiel: Für die Blocklänge~$n=64$ gibt es $2^{64}!$
mögliche Verschlüsselungen und damit genau soviele Schlüssel. Um einen solchen
Schlüssel abspeichern zu können, benötigt man $l=\log_{2}(2^{64}!)$~Bit.
Mit Hilfe der Stirling-Formel kann man die Größe eines solchen Schlüssels
abschätzen:
\begin{align*}
  2^{n}! &\approx \sqrt{2\pi\cdot 2^{n}} \cdot
     \Bigl(\frac{2^{n}}{e}\Bigr)^{2^{n}}\\
  l &\approx \log_{2} \big(\sqrt{2\pi} \cdot 2^{32} \cdot
     \Big(\frac{2^{64}}{e}\Big)^{2^{64}} \big)
     \approx 64 \cdot 2^{64} = 2^{6+64}
\end{align*}
Es würden also zum Abspeichern \textit{eines} Schlüssels für eine Nachricht
$\frac{1}{8}\cdot 2^{20}\approx 10^{5}$~Pebibyte benötigt. In der Praxis kann
man also nur mit "`kleinen"' Teilmengen des Schlüsselraums arbeiten.

Für affin lineare Chiffren werden beispielsweise $\{0,1\}$-Matrizen vom Typ
$64\times 64$ verwendet, deren Determinante~1 ist. Die Darstellung des
Schlüssels ist also mit mit weniger als $64\cdot64 = 2^{12}$~Bit (im
Vergleich zu $2^{70}$~Bit) möglich.

Die Hintereinanderschaltung von \textit{verschiedenen} Blockchiffren führt zu
einer Erhöhung der Sicherheit. Oft realisiert man eine abwechselnde Folge von
Substitutionen und Transpositionen mit dem Ziel die folgenden beiden
\highl{Eigenschaften der Verschlüsselung}, die auf Claude Shannon, den
Begründer der Informationstheorie, zurückgehen, zu erreichen:
\begin{itemize}
 \item \highl{Diffusion}: Änderung eines Klartextbits bewirkt die
  Änderung von vielen Bits des Geheimtexts -- Nachteil: kleine Fehler
  (Tippfehler) ändern den Text stark.
 \item \highl{Konfusion}: Jedes Bit des Chiffretextes hängt von mehr als einem
  Bit des Schlüssels ab.
\end{itemize}

% Einschub, kam nie in der Vorlesung dran

\subsection{Blockverknüpfungsmodi}

Bei der Verschlüsselung können gleiche Blöcke gleich verschlüsselt werden
--~in Analogie zur monoalphabetischen Verschlüsselung~-- oder sie werden in
Abhängigkeit von ihrer Position im Klartext auf verschiedene Weise
verschlüsselt --~in Analogie zur polyalphabetischen Verschlüsselung.

\begin{figure}
  \begin{minipage}[t]{.45\linewidth}
    \input{ecb.pdf_t}
    \caption{Electronic Code Book}
    \label{fig:ecb}
  \end{minipage}%
  \begin{minipage}[t]{.55\linewidth}
    \input{cbc.pdf_t}
    \caption{Cipher Block Chaining}
    \label{fig:cbc}
  \end{minipage}%
\end{figure}

Die erste Variante bezeichnet man als Electronic Code Book Mode (\highl{ECB}).
Jeder Block wird unabhängig von seiner Position mit Hilfe des Schlüssels durch
die Funktion~$f$ in einen Geheimtextblock überführt. \autoref{fig:ecb}
\begin{align*}
  c_{i} &= E_{K}(m_{i})& m_{i} &= D_{K}(c_{i})
\end{align*}

Dies hat den Vorteil, dass die Verschlüsselung aller Blöcke parallel ablaufen
kann. Jedoch bleiben die Anomalien des Klartextes (häufigeres Auftreten
bestimmter Blöcke) erhalten. Da sich Änderungen an einem Klartext- oder
Chiffretextblock nur auf genau einen Klartext bzw. Chiffretextblock auswirken,
könnte ein Angreifer gezielt Daten verändern, ohne dass es bemerkt wird.
Jedoch bietet dieser Umstand auch die Möglichkeit einzelne Blöcke gezielt zu
entschlüsseln oder zu verändern, ohne die ganze Nachricht entschlüsseln zu
müssen. Für eine Dateiverschlüsselung z.\,B. könnte gezielt der neue
Klartextblock verschlüsselt und in dem Geheimtext ersetzt werden.

Beim Cipher Block Chaining Mode (\highl{CBC}) wird der Klartextblock vor der
Verschlüsselung mit dem Ergebnis der Verschlüsselung des vorherigen Blocks
verknüpft, um für gleiche Klartextblöcke unterschiedliche Geheimtextblöcke zu
erzeugen. Dies bringt jedoch die Nachteile mit sich, dass die Verschlüsselung
der Blöcke nicht mehr parallel ablaufen kann und dass bei einer Änderung eines
Klartextblocks alle folgenden Geheimtextblöcke neu berechnet werden müssen.
\autoref{fig:cbc}
\begin{align*}
  c_{i} &= E_{K}(m_{i}\oplus c_{i-1}) & m_{i} &= D_{K}(c_{i}) \oplus c_{i-1}
\end{align*}

Eine Veränderung des $r$.~Geheimtextblocks ändert nur den $r$. und den
folgenden Klartextblock:
\begin{align*}
  D_{K}(\tilde{c_{r}}) \oplus c_{r-1} &\ne m_{r}\\
  D_{K}(c_{r+1}) \oplus \tilde{c_{r}} &\ne m_{r+1}\\
  D_{K}(c_{r+2}) \oplus c_{r+1} &= m_{r+2}
\end{align*}

\begin{figure}
  \centering
  \input{cfb.pdf_t}
  \caption{Cipher Feedback}
  \label{fig:cfb}
\end{figure}

Cipher Feedback Mode (\highl{CFB}) ist ähnlich zu CBC. Der voherige
Geheimtextblock wird verschlüsselt und dieses Ergebnis mit dem Klartextblock
verknüpft, um Anomalien im Klartext auszugleichen. \autoref{fig:cfb}
\begin{align*}
  c_{i} &= E_{K}(c_{i-1}) \oplus m_{i} & m_{i} &= E_{K}(c_{i-1}) \oplus c_{i}
\end{align*}

Die Verschlüsselungsfunktion~$f$ muss nicht umkehrbar sein, da man zur
Entschlüsselung ebenfalls die Verschlüsselungsfunktion verwendet.

\begin{figure}
  \centering
  \input{ofb.pdf_t}
  \caption{Output Feedback}
  \label{fig:ofb}
\end{figure}

Für den Output Feedback Mode (\highl{OFB}) wird aus einem Initialwert eine
Folge von verschlüsselten Blöcken generiert, die mit den Klartextblöcken
verknüpft, die Geheimtextblöcke ergeben. \autoref{fig:ofb}
\begin{align*}
  c_{i} &= m_{i} \oplus s_{i} & m_{i} &= c_{i}\oplus s_{i} & s_{i} &=
     E_{K}(s_{i-1})
\end{align*}

Dies bringt zwei Vorteile mit sich: Zum Einen kann eine solche Folge schon
vorgeneriert werden, wodurch die eigentliche Verschlüsselung, bei Vorliegen
des Klartextes, sehr schnell geht. (Vorteilhaft z.\,B. bei Streaming) Zum
Anderen kann ein Klartextblock direkt ausgetauscht werden, ohne dass man die
folgenden Blöcke oder die verschlüsselte Folge neu berechnen muss:
$\tilde{c_{i}} = c_{i} \oplus m_{i} \oplus \tilde{m_{i}}$.

\begin{table}
  \centering
  \begin{tabular}{l|cccc}
    mode& Schreibzugriff & Manipulation zerstört \dots& Anomalien im Text\\
    \hline
    ECB& wahlfrei& diesen Block& unverändert\\
    CBC& linear& aktuellen u. nächsten Block& verwischt\\
    CFB& linear& aktuellen u. nächsten Block& verwischt\\
    OFB& wahlfrei& diesen Block& verwischt
  \end{tabular}
  \caption{Übersicht der Eigenschaften von ECB, CBC, CFB und OFB}
\end{table}

% 6.11.06

\section{Einschub: Crashkurs über Restklassenringe und Matrizen darüber}
\label{sec:restklassen}

Zwei Zahlen~$a,b\in\Z$ sind zueinander \highl{kongruent modulo~$k$}, wenn sie
bei der Division durch $k$ den gleichen Rest ($0\leq r<k$) lassen:
\begin{gather*}
  a\equiv_{k} b \text{~oder~} a\equiv b\pmod{k}
     \quad \gdwdef\quad \exists l\in\Z\colon a-b= l\cdot k
\end{gather*}

Das zerlegt die ganzen Zahlen in genau $k$~\highl{Restklassen} $[a]_{k}$. Die
Menge dieser Restklassen bezeichnet mal als \highl{Faktormenge}~$\Z_{k}$.
\begin{align*}
  [a]_{k} &= \{a+lk\colon l\in\Z\} = a+k\cdot\Z
     &&\text{für~} a\in\{0,\dotsc,k-1\} \\
  \Z_{k} &:= \nicefrac{\Z}{\equiv_{k}}
     = \{ [0]_{k}, [1]_{k}, \dotsc, [k-1]_{k} \}
\end{align*}
Als Kurzschreibweise verwendet man $\Z_{k} = \{0,1,2,\dotsc,k-1\}$.

Auf dieses Restklassensystem kann man die Addition und Multiplikation auf
folgende Weise übertragen:
\begin{align*}
  [a]_{k} + [b]_{k} &:= [a+b]_{k} &&\text{Nullelement:~}[0]_{k}\\
  [a]_{k} \cdot [b]_{k} &:= [a\cdot b]_{k} &&\text{Einselement:~}[1]_{k}\\
\end{align*}

Für jedes $[a]_{k}$ existiert ein \highl{inverses Element bzgl. Addition}
$-[a]_{k} := [-a]_{k} = [k-a]_{k}$. Ein Element $[a]_{k}$ heißt
\highl{Einheit} des Restklassensystems \gdwdef es existiert ein $[b]_{k}$, so dass
$[a]_{k} \cdot [b]_{k} = [1]_{k}$. In diesem Fall heißt $[b]_{k}$
\highl{inverses Element bzgl. Multiplikation} zu $[a]_{k}$.

\begin{lemma}
  \label{lem:5}
  Die Eulersche $\phi$-Funktion $\phi(k)$ ist die Anzahl der Mengen $\{a,b\}\subset
  \{1,\dotsc,k-1\}^{2}$, für die gilt $\ggT(a,b)=1$. Also gibt es in $\Z_{k}$
  genau $\phi(k)$ Einheiten.

  \begin{proof}
    $[a]_{k}$ ist eine Einheit in $Z_{k}$ \gdw ein $[b]_{k}$
    mit $[a]_{k}\cdot [b]_{k} = [a\cdot b]_{k} = [1]_{k} = 1+k\Z$ existiert,
    d.\,h. es gibt ein $b$ und ein $l$, so dass $ab= 1+kl$, also $ab-kl=1$. Dies
    gilt \gdw $\ggT(a,b)=1$.
  \end{proof}
\end{lemma}

Für das Produkt zweier Zahlen~$p$ und $q$, die zueinander teilerfremd sind,
ist $\phi(p\cdot q)=(p-1)\cdot(q-1)$ --~$\phi$ ist multiplikativ.
Falls $k=p$ eine Primzahl ist, dann gibt es $\phi(p)=p-1$ Einheiten und
$\Z_{p}$ ist ein Körper.
\begin{gather*}
  \phi(k) = k\prod_{p\mid k} \Bigl(1-\frac{1}{p}\Bigr)
\end{gather*}

Die algebraische Struktur $\Z_{k} = [\Z_{k},+,\cdot]$ mit dem
Nullelement~$[0]_{k}$ und dem Einselement~$[1]_{k}$ bezeichnet mal als
\highl{kommutativen Ring}.

In der Krypologie wird häufig mit dem Restklassenring modulo~$26$ gearbeitet:
$\Z_{26} = \{0,1,\dotsc,25\}$. Im Grunde sind alle endlichen Alphabete
kommutative Ringe, was den Vorteil hat, dass man mit Buchstaben rechnen kann.
Dies haben wir bereits bei der Caesar-Chiffre ausgenutzt.

Der Ring $\Z_{26}$ hat genau 12~Einheiten, da $\phi(\abs{\Z_{26}}) =
\phi(2\cdot13) = \phi(2)\cdot\phi(13) = 1\cdot12$. Diese sind:
$1,3,5,7,9,11,15,17,19,21,23,25$.

Wir betrachten $n\times n$-Matrizen, deren Einträge Elemente
aus einem beliebigen kommutativen Ring~$[R,+\cdot]$ sind.
\begin{gather*}
  R^{n\times n} := \bigl\{ \begin{pmatrix}
                       r_{11} & r_{12} & \dotso & r_{1n}\\
                       r_{21} & r_{22} & \dotso & r_{2n}\\
                       \vdots & \vdots & & \vdots\\
                       r_{n1} & r_{n2} & \dotso & r_{nn}
                     \end{pmatrix}
                    \colon r_{ij}\in R, 1\leq i,j \leq n\bigr\}
\end{gather*}
Die Matrizenaddition und -multiplikation ist dabei wie üblich.

In der Kryptologie betrachten wir speziell die Matrizen $\Z_{k}^{n\times n}$.

Als \highl[Zeilenvektor]{Zeilen-} (\autoref{eq:zeilenvek}) bzw.
\highl[Spaltenvektor]{Spaltenvektoren} (\autoref{eq:spaltenvek}) bezeichnet
man Matrizen der folgenden Form:
\begin{align}
  R^{1\times n} &= \{ \begin{pmatrix}b_{1} & b_{2} & \dotso & b_{n}\end{pmatrix}
                    \colon b_{i}\in R, 1\leq i \leq n\}\label{eq:zeilenvek}\\
  R^{n\times1} &= \{ \begin{pmatrix}b_{1} & b_{2}&\dotso&b_{n}\end{pmatrix}^{T}
                    \colon b_{i}\in R, 1\leq i \leq n\}\label{eq:spaltenvek}
\end{align}

Als eine \highl{Permutation}~$\sigma$ bezeichnet man eine Umordnung der
Elemente eine Menge. Mit $S_{n}$ bezeichnet man die Menge der Permutationen
einer Menge mit $n$~Elementen.
\begin{gather*}
  S_{n} = \bigl\{ \sigma\colon \sigma\colon \{1,\dotsc,n\} \rightarrow
     \{1,\dotsc,n\} \bigr\}
\end{gather*}

Für eine Permutation~$\sigma\in S_{n}$ bezeichnet man ein Paar
$(i,j)\in\{1,\dotsc,n\}^{2}$ als Fehlstand,
wenn $i<j$ und $\sigma(i)>\sigma(j)$ gilt.

Die \highl{Determinante} einer quadratischen Matrix~$A\in R^{n\times n}$
($A=(a_{ij})_{n\times n}$ mit $a_{ij}\in R$) kann man auf zwei Weisen berechnen.

Die Formel von Leibniz für die Determinante einer Matrix lautet:
\begin{gather*}
  \det A := \sum_{\sigma\in S_{n}} \sgn(\sigma) \cdot
     \prod_{i=1}^{n} a_{i\sigma(i)}\\
  \sgn(\sigma) = \begin{cases}
                   +1 &:\text{die Anzahl der Fehlstände ist gerade}\\
                   -1 &:\text{die Anzahl der Fehlstände ist ungerade}
                 \end{cases}
\end{gather*}

\begin{bsp}
  Die Determinante einer $1\times1$-Matrix~$A=(a_{11})$ ist $\det A = a_{11}$,
  da die einzig mögliche Permutation~$\sigma=
  (\begin{smallmatrix}1\\1\end{smallmatrix})$ das Vorzeichen~$+1$ hat.
  \begin{gather*}
    \det A = \sum_{\sigma\in S_{1}} \sgn(\sigma) \cdot \prod_{i=1}^{1}
       a_{i\sigma(i)} = \sum_{\sigma\in S_{1}} \sgn(\sigma) a_{11}
  \end{gather*}

  Für eine $2\times2$-Matrix~$A$ gibt es zwei Permutationen~$\sigma_{1},
  \sigma_{2}\in S_{2}$:
  \begin{gather*}
    \sigma_{1}=\begin{pmatrix}1&2\\1&2\end{pmatrix},\; \sgn(\sigma_{1})=+1
       \qquad
       \sigma_{2}=\begin{pmatrix}1&2\\2&1\end{pmatrix},\; \sgn(\sigma_{2})=-1
  \end{gather*}
  Entsprechend ergibt sich die Determinante als
  \begin{align*}
    \det A &= \sum_{\sigma\in S_{2}} \sgn(\sigma) \cdot
       \prod_{i=1}^{2} a_{i\sigma(i)}
       = \sum_{\sigma\in \{\sigma_{1},\sigma_{2}\}} \sgn(\sigma) \cdot
       a_{1\sigma(1)}\cdot a_{2\sigma(2)}\\
    &= \sgn(\sigma_{1}) \cdot a_{1\sigma(1)} \cdot a_{2\sigma(2)} +
       \sgn(\sigma_{2}) \cdot a_{1\sigma(1)} \cdot a_{2\sigma(2)}
       = a_{11} a_{22} - a_{12}a_{21}
  \end{align*}
\end{bsp}

Die andere Möglichkeit ist das Verfahren von Laplace, bei dem nach einer Zeile
oder Spalte entwickelt wird:
\begin{gather*}
  \det A = \sum_{j=1}^{n} (-1)^{i+j} a_{ij} A_{ij}
\end{gather*}
wobei $A_{ij}$ diejenige Matrix ist, die durch Streichen der $i$.~Zeile und
$j$.~Spalte aus $A$ entsteht.

Eine Matrix $A$ besitzt eine zu ihr \highl{inverse Matrix}~$A^{-1}$, d.\,h. es gilt
\begin{gather*}
  A\cdot A^{-1} = A^{-1}\cdot A = E_{n} =
     \left(\begin{smallmatrix}
       1\\
       & 1 & & \text{\Large \smash{0}}\\
       & & \ddots\\
       & \text{\Large \smash{0}} & & 1\\
       & & & & 1\
     \end{smallmatrix}\right)_{n\times n}
\end{gather*}
\gdw die Determinante~$\det A$ ein inverses Element in $[R,+,\cdot]$ besitzt \gdw
$\det A$ eine Einheit des Rings $[R,+,\cdot]$ ist.

Dabei gilt: $A^{-1}= (\det A)^{-1} B$, wobei $(b_{ij})=(-1)^{i+j}\cdot
\det A_{ij}$.

\section{Affinlineare Blockchiffren}
\label{sec:afflin}

Die Zeichen des Klartexts werden durch Elemente aus $\Z_{k}$ codiert und der
Klartext wird in Blöcke der Länge~$n$ eingeteilt, die einzeln nach demselben
Schema verschlüsselt werden.

Der Schlüssel ist ein Paar $(A,b)$, wobei $A\in\Z_{k}^{n\times n}$ und
$b\in\Z_{k}^{1\times n}$ ist. Zur Verschlüsselung eines
Blockes~$m=(\begin{smallmatrix}m_{1}& \dotso& m_{n}\end{smallmatrix})
\in\Z_{k}^{1\times n}$ wird die lineare Abbildung
\begin{gather*}
  c = m\cdot A+b
\end{gather*}
verwendet. Diese Verschlüsselung ist weder eine Substitution (ein Eintrag
$c_{i}$ hängt im Allgemeinen von allen $m_{1},\dotsc, m_{n}$ ab) noch keine
Transposition.

Aber nicht alle Verschlüsselungen dieser Art sind auch eindeutig, d.\,h. eine
Entschlüsselung ist möglich. Dafür muss zu der Matrix~$A$ die inverse
Matrix~$A^{-1}$ existieren, was genau dann der Fall ist, wenn $\ggT(\det A,
k)=1$, also die Determinante von $A$ eine Einheit von $\Z_{k}$ ist.

Die Entschlüsselung erfolgt dann mit der Abbildung
\begin{gather*}
  m=(c-b)A^{-1}
\end{gather*}

Der Spezialfall $b=0$, also $c=m\cdot A$, ist die \highl{Hill-Chiffre} (1929)
und der Spezialfall $A=E_{n}$, also $c=m+b$, ist die
\highl{Vigenère-Verschlüsselung} mit dem Schlüsselwort~$b$.

Man kann auch eine \highl{Blocktransposition} als eine affinlineare
Abbildung beschreiben. Die für die Blocktransposition genutzte Permutation
von $\{1,\dotsc,n\}$ sei $\sigma$. Mit $b=0$ und der Matrix~$P_{\sigma} =
(p_{ij})_{n\times n}$ mit
\begin{gather*}
  p_{ij} =
     \begin{cases}
       0 & \sigma(i) \ne j\\
       1 & \sigma(i) = j
     \end{cases}
\end{gather*}
ergibt sich der erwünschte Effekt, dass
\begin{gather*}
  \begin{pmatrix} m_{1}& m_{2} & \dotso & m_{n} \end{pmatrix}
     \cdot
     P_{\sigma} =
     \begin{pmatrix}
       m_{\sigma(1)}& m_{\sigma(2)} & \dotso & m_{\sigma(n)}
     \end{pmatrix}
\end{gather*}
und es gilt $P_{\sigma}^{-1} = P_{\sigma^{-1}}$.

% 8.11.06

\subsection{Kryptoanalyse affinlinearer Blockchiffren}

Sind $n+1$ Klartextblöcke~$m_{0},\dotsc,m_{n}$ und die dazugehörigen
Geheimtextblöcke~$c_{0},\dotsc, c_{n}$ bekannt --~eine
\highl{known-plaintext-attack}~--, kann man folgende zwei Matrizen definieren:
\begin{align*}
  M &=
     \begin{pmatrix}
       m_{1}-m_{0}\\
       \vdots\\
       m_{n}-m_{0}
     \end{pmatrix}_{n\times n}
     & C &=
     \begin{pmatrix}
       c_{1}-c_{0}\\
       \vdots\\
       c_{n}-c_{0}
     \end{pmatrix}_{n\times n}
\end{align*}

Es gilt also
\begin{gather*}
  C =
     \begin{pmatrix}
       c_{1}-c_{0}\\
       \vdots\\
       c_{n}-c_{0}
     \end{pmatrix} =
     \begin{pmatrix}
       (m_{1}A+b) - (m_{0}A+b)\\
       \vdots\\
       (m_{n}A+b) - (m_{0}A+b)\\
     \end{pmatrix} =
     \begin{pmatrix}
       (m_{1}-m_{0})A\\
       \vdots\\
       (m_{n}-m_{0})A\\
     \end{pmatrix} =
     M\cdot A
\end{gather*}

Wenn $\det M$ eine Einheit in $\Z_{k}$ ist, dann existiert auch $M^{-1}$.
Hieraus folgt dann $A=M^{-1}C$ und weiter $b= c_{0}-m_{0}A$.

\begin{bemerk}
  Dies kommt nicht zu selten vor, dass $\det M$ eine Einheit ist, denn es gilt:
  \begin{gather*}
    \limsup_{k\rightarrow\infty} \frac{\phi(k)}{k} = 1
       \qquad\text{und}\qquad
       \lim_{k\rightarrow\infty} \frac{\phi(k)}{k^{1-\delta}} = \infty
  \end{gather*}
  für $\delta>0$.

  Für $\Z_{26}$ gibt es z.\,B. $\phi(26)=12$~Einheiten.
\end{bemerk}

\begin{bemerk}
  In einer halbgeordneten Menge kann man definieren:
  \begin{gather*}
    \limsup_{k\rightarrow\infty} x_{k} = \inf\{ \sup\{ x_{l}\colon l\geq
       k\}\colon k\in\N\}
  \end{gather*}
  In vollständigen Verbänden existiert stets der Limes superior und Limes
  inferior und es gilt $\liminf_{k\rightarrow\infty} x_{k} \leq
  \limsup_{k\rightarrow\infty} x_{k}$.
\end{bemerk}

Für \highl{Hill-Chiffren} (d.\,h. $b=0$) genügen $n$~Paare $(m_{j},c_{j})$, da
die Matrix~$C$ nicht als $(c_{i}-c_{0})$ definiert werden muss, um den Anteil
von $b$ zu eleminieren. Damit können auch für die Matrix~$M$ direkt die
Klartextblöcke verwendet werden.

\begin{bsp}
  Es sei $k=26$ und $n=2$. Der Klartext sei "`HERBST"' und der Geheimtext sei
  "`SOMMER"'. Die Aufgabe ist den Schlüssel $(A,b)$ zu bestimmen.

  Der Klartext "`HERBST"' wird durch $\underbrace{7~4}_{m_{0}}~
  \underbrace{17~1}_{m_{1}}~ \underbrace{18~19}_{m_{2}}$ und der Geheimtext
  "`SOMMER"' durch $\underbrace{18~14}_{c_{0}}~
  \underbrace{12~12}_{c_{1}}~ \underbrace{4~17}_{c_{2}}$ codiert.

  Damit kann man nun die Matrizen~$M$ und $C$ bestimmen:
  \begin{gather*}
    M =
       \begin{pmatrix}
         m_{1}-m_{0}\\
         m_{2}-m_{0}
       \end{pmatrix}
       =
       \begin{pmatrix}
          17-7 & 1-4\\
          18-7 & 19-4
       \end{pmatrix}
       =
       \begin{pmatrix}
          10 & 23\\
          11 & 15
        \end{pmatrix}\\
    C =
       \begin{pmatrix}
         c_{1}-c_{0}\\
         c_{2}-c_{0}
       \end{pmatrix}
       =
       \begin{pmatrix}
         12-18& 12-14\\
         4-18& 17-14
       \end{pmatrix}
       =
       \begin{pmatrix}
         20 & 24\\
         12 & 3
       \end{pmatrix}
  \end{gather*}
  \textit{(Beachte: Die Elemente sind aus $\Z_{26}$, immer den Rest der
  Division durch 26 verwenden.)}

  Nun kann man die Determinante von $M$ bestimmen und da diese eine Einheit
  ist, existiert $M^{-1}$.
  \begin{gather*}
    \det M =
       \begin{pmatrix}
          10 & 23\\
          11 & 15
        \end{pmatrix} = 10\cdot15 - 23\cdot11 = 1\\
    M^{-1} = (\det M)^{-1} \cdot B
       = 1 \cdot \begin{pmatrix}15 & 3\\15 & 10\end{pmatrix}
  \end{gather*}
  \textit{(Für die Bestimmung von $B$ siehe \autoref{sec:restklassen}.)}

  Damit lässt sich jetzt die Matrix~$A$ und der Vektor~$b$ bestimmen.
  \begin{gather*}
    A = M^{-1}\cdot C =
       \begin{pmatrix}15 & 3\\15 & 10\end{pmatrix}\cdot
       \begin{pmatrix}20 & 24\\12 & 3\end{pmatrix}
       = \begin{pmatrix}24 & 5\\4 & 0\end{pmatrix}\\
    b = c_{0}-m_{0}
       = \begin{pmatrix}18 & 14\end{pmatrix}
       - \begin{pmatrix}7 & 4\end{pmatrix}
       \cdot \begin{pmatrix}24 & 5\\4 & 0\end{pmatrix}
       = \begin{pmatrix}18 & 14\end{pmatrix}
       - \begin{pmatrix}2 & 9\end{pmatrix}
       = \begin{pmatrix}16 & 5\end{pmatrix}
  \end{gather*}
\end{bsp}

Der einzige Schutz bei affinlinearen Verschlüsselungen besteht darin, den
Schlüsselraum möglichst groß zu machen, um die Berechnungen bei einem Angriff
aufwendiger werden zu lassen.

\section{Feistel-Chiffre}

Die Idee zur \highl[Feistel-Chiffre]{Feistel"=Chiffre} wurde 1971 bei IBM in
dem Projekt "`\href{http://de.wikipedia.org/wiki/Lucifer\_(Kryptographie)}{Lucifer}"'
entwickelt und ist heute Grundlage für viele symmetrische Blockchiffren unter
anderem dem heute am häufigsten eingesetzen Verschlüsselungsalgorithmus DES
--~dazu später mehr in \autoref{sec:des}. Als Erfinder der Feistel"=Chiffre
gilt
\href{http://de.wikipedia.org/wiki/Horst_Feistel}{Horst Feistel}, ein
Mitarbeiter des Projekts Lucifer.

Bei der Feistel"=Chiffre werden die Klartextblöcke durch eine alternierende Folge von
Substitutionen und Transpositionen verschlüsselt. Einen einzelnen Durchlauf
von Substitution und Transposition bezeichnet man als \highl{Runde}. Die
einzelnen Schlüssel für jede Runde werden dabei aus einem (Haupt"~)""Schlüssel
erzeugt.
\todo{Erklären, was die S-Box (Substitution) und die P-Box (Translation; von
  Permutation) ist.}
\todo{to produce a function with large amounts of what Claude Shannon
  described as ``confusion and diffusion.'' Bit shuffling creates the diffusion
  effect, while substitution is used for confusion.}

Eine Nachricht~$m\in\Z_{2}^{n}$ der Länge~$n$ (o.\,B.\,d.\,A. sei $n$ gerade)
wird in zwei gleichlange Teile~$L_{0}$ und $R_{0}$ zerlegt. Aus diesen beiden
wird durch die Zuordnung in \autoref{eq:feistel} ein neuer linker Teil~$L_{1}$
und ein neuer rechter Teil~$R_{1}$ gewonnen. Diese beiden Zeichenketten
wiederum werden als Eingabe für die nächste Runde verwendet. Die
\highl{Rundenzahl}~$r$ bestimmt dabei, wie oft ein solcher Durchlauf
stattfindet. In der letzten Runde wird die leicht modifizierte Vorschrift aus
\autoref{eq:feistel-last} verwendet, bei der die Transposition entfällt

\begin{align}\label{eq:feistel}
  \begin{split}
    L_{i} &= R_{i-1}\\
    R_{i} &= L_{i-1} \oplus f_{K_{i}}(R_{i-1})
  \end{split}
     &\text{für~}i=1,\dotsc,r-1\\
  \label{eq:feistel-last}
  \begin{split}
    L_{r} &= L_{r-1} \oplus f_{K_{r}}(R_{r-1})\\
    R_{r} &= R_{r-1}
  \end{split}
\end{align}
\begin{gather*}
  (L_{i-1}, R_{i-1})
     \xrightarrow{\text{Substitut.}}
     \bigl(L_{i-1} \oplus f_{K_{i}}(R_{i-1}), R_{i-1} \bigr)
     \xrightarrow{Transposit.}
     \bigl(R_{i-1}, L_{i-1}\oplus f_{K_{i}}(R_{i-1}) \bigr)
\end{gather*}
(Anm.: $\oplus$ ist das Exclusive-Oder \texttt{xor})

\begin{figure}
  \centering
  \input{feistel.pdf_t}
  \caption{Schematische Darstellung der Feistel"=Chiffre}
  \label{fig:feistel}
\end{figure}

Für die Entschlüsselung einer Nachricht kann man den gleichen Algorithmus mit
der umgekehrten Schlüsselfolge $K_{i}':= K_{r+1-i}$ (für $i=1,\dotsc,r$) auf
$c=(L_{0}', R_{0}')=(L_{r}, R_{r})$ verwenden und einfach die verschlüsselte
Nachricht nochmals verschlüsseln. Dies hat zum Einen den Vorteil, dass man die
gleiche Hard"~/""Software auf der Sender- und Empfängerseite einsetzen kann,
und zum Anderen kann die Funktion~$f$ sehr kompliziert sein, da man nicht
deren inverse Funktion benötigt.

Bei der Entschlüsselung gilt in allen Runden $i=1,\dotsc,r$ der Zusammenhang
$(L_{i}', R_{i}') = (L_{r-i}, R_{r-i})$ und für die letzte Runde ergibt sich
dann der Klartext der Nachricht als $(L_{r}', R_{r}') = (L_{0}, R_{0})$.

\begin{align*}
  (L_{1}', R_{1}') &= \bigl(R_{0}',\; L_{0}' \oplus f_{K_{1}'}(R_{0}')\bigr)
     &\text{nach \eqref{eq:feistel}}\\
  &= \bigl(R_{r},\; L_{r}\oplus f_{K_{r}}(R_{r}) \bigr) &\text{nach IV.}\\
  &= \bigl(R_{r-1},\; \bigl(L_{r-1} \oplus f_{K_{r}}(R_{r-1})\bigr) \oplus
     f_{K_{r}}(R_{r-1}) \bigr) &\text{nach \eqref{eq:feistel-last}}\\
  &= (R_{r-1}, L_{r-1}) &\text{da~}a\oplus a=a\displaybreak[0]\\[1.5ex]
  (L_{n}', R_{n}') &= \bigl(R_{n-1}',\; L_{n-1} \oplus f_{K_{n}'}(R_{n-1}')
     \bigr) & \text{nach \eqref{eq:feistel}}\\
  &= \bigl(L_{r-n+1},\; R_{r-n+1} \oplus f_{K_{r+1-n}}(L_{r-n+1})\bigr)
     &\text{nach IV.}\\
  &= \bigl(R_{r-n},\; \bigl(L_{r-n}\oplus f_{K_{r-n+1}}(R_{r-n})\bigr) \oplus
     f_{K_{r+1-n}}(R_{r-n}) &\text{nach \eqref{eq:feistel}}\\
  &= (R_{r-n}, L_{r-n})
\end{align*}

% 15.11.

Da die Schlüsselfolge $K_{1},\dotsc, K_{r}$ für die Ver- und Entschlüsselung
aus dem gleichen (Haupt"~)""Schlüssel erzeugt wird, ist die Feistel"=Chiffre
eine symmetrische Verschlüsselung.

Die Sicherheit der gesamten Verschlüsselung beruht auf der Eigenschaft, dass
die Substitution, genauer die Funktion~$f_{K_{i}}$, eine nichtlineare
Transformation ist. Wäre $f_{K_{i}}$ eine lineare Transformation, so wäre auch
die Verkettung von Substitution und Translation\footnote{$\begin{pmatrix}R&L
\end{pmatrix} = \begin{pmatrix}L& R\end{pmatrix}\cdot
(\begin{smallmatrix}0& 1\\1& 0\end{smallmatrix})$} in jeder Runde eine lineare
Transformation. Man könnte also den gesamten Verschlüsselungsvorgang mit einer
einzigen linearen Gleichung beschreiben. Die Funktion $\oplus$ ist
linear, da sich leicht zeigen lässt, dass $f(ax+by)=af(x)+bf(y)$ mit
$f(x)= f(x_1, x_2)= x_1\oplus x_2= x_1 + x_2 \mod 2$ für $x_1, x_2 \in
\mathbb{F}_2$ folgt.

Ist die Funktion~$f$ eine krytographisch sichere Pseudozufallsfunktion, so
haben Michael Luby und Charles Rackoff (\cite{luby}) gezeigt, reichen drei Runden um eine
Pseudozufallspermutation zu erreichen. Mit vier Runden bekommt man sogar eine
starke Pseudozufallspermutation.\footnote{Geklaut aus der
\href{http://en.wikipedia.org/wiki/Feistel_cipher}{englischen Wikipedia}, die
selbst auf \cite{luby} verweist.}

% Angenommen: $f_{K_{i}}$ ist linear:
% \begin{gather*}
%   f_{K_{i}}(R_{i-1}) = R_{i-1}\cdot A_{i} + b\qquad
%      A_{i}\in \Z_{2}^{(n\times n)}, b_{i} \in \Z_{2}^{(1\times n)}
% \end{gather*}
% dann ist die Substitution:
% \begin{gather*}
%   (L_{i-1}\oplus f_{K_{i}}(R_{i-1}), R_{i-1}) = (L_{i-1}, R_{i-1})\cdot
%      \begin{pmatrix}
%        E_{n} & 0_{n}\\
%        A_{i} & E_{n}
%      \end{pmatrix}
%      + (b_{i}, 0)
% \end{gather*}

\section{DES -- Data Encryption Standard}\label{sec:des}

Der \highl{Data Encryption Standard} (\highl{DES}) wurde in den
1970ern von IBM für eine Ausschreibung des US~National Bureau of
Standards\footnote{wurde später in
  \href{http://www.nist.gov/}{National Institute of Standards and
    Technology (NIST)} umbenannt} entwickelt. Er basiert auf den
vorangegangenen Entwicklungen des Projekts Lucifer, das die
Feistel"=Chiffre entwickelt hatte. Am 23.\,November 1976 wurde DES als
Standard für die Verschlüsselung in den amerikanischen Bundesbehörden
anerkannt und im Januar 1977 erfolgte die Veröffentlichung als
\href{http://csrc.nist.gov/publications/fips/fips46-3/fips46-3.pdf}{FIPS
  PUB 46}.

Die International Organization for Standardization~(ISO) übernahm den
Algorithmus unter der Bezeichnung "`Data Encipherment No.\,1"'~(DEA-1) in ihr
Verzeichnis.

Die Kryptographen Eli Biham und Adi Shamir entwickelten gegen Anfang
der 90er Jahre die differentielle Kryptoanalyse als Spezialform der
Kryptoanalyse. Dabei wird untersucht, wie sich das Chiffrat bei
unterschiedlichem Input ändert. Das Verfahren wandten sie auch auf DES
an\footnote{Biham, E. and A. Shamir. (1990). Differential
  Cryptanalysis of DES-like Cryptosystems. Advances in Cryptology "=
  CRYPTO
  '90. Springer-Verlag. 2?21.}\footnote{\href{http://www.cs.technion.ac.il/users/wwwb/cgi-bin/tr-get.cgi/1991/CS/CS0708.ps}{Eli
    Biham, Adi Shamir,"Differential Cryptanalysis of the Full 16-Round
    DES, CS 708, Proceedings of CRYPTO 92, Volume 740 of Lecture
    Notes in Computer Science, December 1991.}}.
Das Verfahren erfordert bei DES $2^{47}$ frei gewählte Klartexte und
nach Angaben von IBM war dieser Angriff seit 1974 bekannt. Eines der
Designziele von DES war die Absicherung gegen die differentielle
Kryptoanalyse.

Die fortschreitende Weiterentwicklung der Rechenkraft führte letztlich
dazu, dass ein Brute-Force-Angriff gegen DES erfolgreich wird. So
wurde 1997 das erste Mal eine verschlüsselte Nachricht gebrochen. Ein
Jahr später gelingt es der Electronic Frontier Foundation~(EFF) mit
dem eigens dafür angefertigten Supercomputer "`Deep Crack"', der
88~Milliarden Schlüssel pro Sekunde testen konnte, binnen 56~Stunden eine
Verschlüsselung zu brechen. Ein halbes Jahr später, im Januar~1998,
gelang es durch die Zusammenarbeit von Deep Crack und
\href{http://distributed.net}{distributed.net} einen DES"=Schlüssel in
22~Stunden und 15~Minuten zu ermitteln --~mehr als 245 Milliarden
Schlüssel wurden pro Sekunde getestet.

Im Jahr~1999 wird DES als Standard für die Verschlüsselung der
amerikanischen Bundesbehörden widerrufen und schließlich 2002 durch den
Advanced Encryption Standard~(AES) ersetzt.

DES arbeitet nach dem gleichen Prinzip wie die Feistel"=Chiffre und ist
damit eine symmetrische Blockchiffre. Die Schlüssellänge für die
Verschlüsselung beträgt 64~Bit, wobei ein Bit pro Byte als Prüfbit verwendet
wird, was den effektiven Schlüsselraum~$\mathcal{K} =\{0,1\}^{56}$ auf 56~Bit
reduziert.

DES arbeitet mit 16 Runden. Aus dem Schlüssel~$k\in\mathcal{K}$ werden
16~Teilschlüssel $k_{1}, k_{2},\dotsc, k_{16}$ der Länge $\abs{k}=16$
generiert, die jeweils in einem $SBB$ (Standard Building Block) verwendet
werden.

Die Nachricht wird in Blöcke~$m$ der Länge~64 aufgeteilt und nach einer
initialen Permutation\footnote{Die initiale Permutation hat keinen
Einfluss auf die Sicherheit des Algorithmus'. Es wurde damals
eingeführt, um das Laden der Daten in den Chip zu vereinfachen. Da die
Realisierung der $IP$ in Software schwieriger ist, wird das manchmal
weggelassen.} ($IP$) in den 16~SBB tranformiert und anschließend noch
mal mit $IP^{-1}$ permutiert.

Schema:
\begin{gather*}
  % Eine Runde "`Zeichnen für arme Leute"' :-))
  \xrightarrow[64]{m}
     \raisebox{-1.6ex}{\framebox{\rule{0pt}{5.5ex}$IP$}}\:
     \begin{split}
       \xrightarrow[32]{}\\
       \xrightarrow[32]{}\\
     \end{split}
     \stackrel{K_{1}\downarrow 48}%
              {\raisebox{-1.6ex}{\framebox{\rule{0pt}{5.5ex}$SBB_{1}$}}}
     \begin{split}
       \xrightarrow[32]{}\\
       \xrightarrow[32]{}\\
     \end{split}
     \stackrel{K_{2}\downarrow 48}%
              {\raisebox{-1.6ex}{\framebox{\rule{0pt}{5.5ex}$SBB_{2}$}}}
     \dotso
     \stackrel{K_{15}\downarrow 48}%
              {\raisebox{-1.6ex}{\framebox{\rule{0pt}{5.5ex}$SBB_{15}$}}}
     \begin{split}
       \xrightarrow[32]{}\\
       \xrightarrow[32]{}\\
     \end{split}
     \stackrel{K_{16}\downarrow 48}%
              {\raisebox{-1.6ex}{\framebox{\rule{0pt}{5.5ex}$SBB_{16}$}}}
     \begin{split}
       \xrightarrow[32]{}\\
       \xrightarrow[32]{}\\
     \end{split}
     \:\raisebox{-1.6ex}{\framebox{\rule{0pt}{5.5ex}$IP^{-1}$}}
     \xrightarrow[64]{C}
     % und wer hat jetzt Lust das Bild auszumalen?
\end{gather*}

Runde~$i$: Die Eingabe wird in eine linke und reche Hälfte $(L,R)$ geteilt.
Die Ausgabe $(L', R')$ wird durch $L'=R$ und $R'$ auf folgende Weise
erzeugt:
\begin{enumerate}
 \item Diffusionsschritt: Aus $R$ wird ein 48-Bit-Wort $R_{1}$ erzeugt
 \item $R_{2}= R_{1}\oplus K_{i}$
 \item Konfusionsschritt: aus $R_{2}$ wird durch eine nicht lineare
  Transformation~$S$ ein 32-Bit-Wort $R_{3}$ erzeugt

  $S$: Zerlegen in 8 Worte der Länge~6 und diese mit $S_{i}$ zur 8 Worten der
  Länge~4 verknuddeln und diese wieder zu einem 32-Bit-Wort zusammenkleben.
 \item Permutation von $R_{3}$ erzeugt $R_{4}$
 \item $R' = L\oplus R_{4}$
\end{enumerate}

\todo{Hier gab es ein tolles Schema. Wollen wir das?}

Vereinbarung: Die gesamte Transformation bei einem kompletten Durchlauf
beschreiben wir als $c= DES_{k}(m)$

Abwandlungen zur Erhöhung der Sicherheit von DES:
\begin{itemize}
 \item $c = DES_{k_{2}}\bigl( DES_{k_{1}}(m) \bigr)$ keine wesentliche
  Erhöhung der Sicherheit, da es einfach nur die Rundenzahl erhöht.

 \item $c = DES_{k_{1}}\bigl( DES_{k_{2}}^{-1}( DES_{k_{1}}(m) ) \bigr)$ mit
  chosen-plain-text-Angriff ist dies auch leicht knackbar.

 \item $c= DES_{k_{3}}\bigl( DES_{k_{2}}^{-1}( DES_{k_{1}}(m) ) \bigr)$
  wird als \highl{Triple-DES} (\highl{3DES}) bezeichnet.
\end{itemize}
Was ist der Unterschied zwischen $DES^{-1}_{k}$ und $DES_{k^{T}}$? DES
beschreibt auch, wie die Teilschlüssel erzeugt werden und daher ist $k^{T}$
nicht der permutierte Schlüssel, der bei $DES^{-1}_{k}$ verwendet wird.

% 20.11.

\subsection{Ein Beispiel einer vereinfachten DES-Verschlüsselung}

$n = 12$ und $\abs{L} = \abs{R} = 6$
\todo{Bild}

Ausgangsschlüssel~$k$ der Länge 9, Rundenschlüssel: $k_{1}, k_{2}, \dotsc$

Erzeugung der Rundenschlüssel: das 1.\,Bit von $k_{i}$ ist das $i$.\,Bit von
$k$ gefolgt von den nächsten 7~Bits in zyklischer Reihenfolge.
$k=(\kappa_{1}\dotso\kappa_{9})$ $\rightarrow$ $k_{i} = (\kappa_{i}
\kappa_{i+1}\dotso\kappa_{i+7})$; $k_{i} = k_{i+9} = k_{i+18} = \dotsb$

\begin{enumerate}[1.\,{Schritt}]
 \item Diffusion $D\colon \Z_{2}^{6} \mapsto \Z_{2}^{8}$ (wobei $R_{1}=D(R)$)
  mit
  \begin{gather*}
    D(\alpha_{1},\dotsc,\alpha_{6}) = (\alpha_{1}, \alpha_{2}, \alpha_{4},
       \alpha_{3}, \alpha_{4}, \alpha_{3}, \alpha_{5},\alpha_{6})
  \end{gather*}
  Damit ist $D$ eine lineare Abbildung:
  \begin{gather*}
    D(\alpha) = \alpha \cdot
       \begin{pmatrix}
         1& 0& 0& 0& 0& 0& 0& 0\\
         0& 1& 0& 0& 0& 0& 0& 0\\
         0& 0& 0& 1& 0& 1& 0& 0\\
         0& 0& 1& 0& 1& 0& 0& 0\\
         0& 0& 0& 0& 0& 0& 1& 0\\
         0& 0& 0& 0& 0& 0& 0& 1
       \end{pmatrix}
  \end{gather*}

 \item $R_{2} = R_{1} \oplus k_{i}$

 \item Transformation mit zwei $S$-Boxen; eine $S$-Box ist eine Permutation
  der Zahlen $\{0,\dotsc,7\}$ in jeweils zwei Zeilen:
  \begin{gather*}
    \sigma_{1} =
       \begin{pmatrix}
         5& 2& 1& 6& 3& 4& 7& 0\\
         1& 4& 6& 2& 0& 7& 5& 3
       \end{pmatrix}\\
    \sigma_{2} =
       \begin{pmatrix}
         4& 0& 6& 5& 7& 1& 3& 2\\
         5& 3& 0& 7& 6& 2& 1& 4
       \end{pmatrix}
  \end{gather*}

  Die Eingabe für jede $S$-Box ist ein 4-Bit-Wort: dazu $R_{2} = (A, B)$ und
  damit ist $A\in \Z_{2}^{4}$ die Eingabe für $S_{1}$ und $B\in\Z_{2}^{4}$ die
  Eingabe für $S_{2}$. Das erste Bit der Eingabe gibt die Zeile in der $S$-Box
  an: 0 für die erste und 1 für die zweite Zeile. Die verbleibenden drei Bits
  beschreiben eine Zahl zwischen 0 und 7 und legen die Spalte fest: 000 ist
  die erste Spalte, \dots, 111 für die achte Spalte.

  Der Eintrag an dieser Position ist die Ausgabe der $S$-Box. Formal: $S\colon
  \Z_{2}^{4} \mapsto \Z_{2}^{3}$ wobei
  \begin{gather*}
    (\alpha_{1},\dotsc,\alpha_{4}) \mapsto \sigma\bigl(\alpha_{1}+1,
       bin^{-1}(\alpha_{2},\alpha_{3},\alpha_{4})\bigr)
  \end{gather*}\help{Was ist bin?}

  $R_{3} = \bigl(S_{1}(A), S_{2}(B)\bigr)$
\end{enumerate}

\begin{bsp}
  $K=(0100\,11001), R=(101011)$ Frage: Was ist $f_{k_{4}}(R)$

  \begin{enumerate}[1.\,{Schritt}]
    \addtocounter{enumi}{-1}
   \item Bestimme $k_{4} = (0110\,0101)$
   \item Bestimme $R_{1} = D(R) = (1001\,0111)$
   \item Bestimme $R_{2} = R_{1}\oplus k_{4} = (1111\,0010)$
   \item $A=(1111), B=(0010)$ $S_{1}(A) = S_{1}(1\,111) = (011)$ und $S_{2}(B)
    = S_{2}(0\,010) = (110)$
  \end{enumerate}
  $\Rightarrow$ $f_{k_{4}}(R) = (011\,110)$

  Wie sieht die gesamte 4.\,Runde des vereinfachten DES aus?

  Angenommen: $(L_{3}\: R_{3}) = (001\,111\: 101\,011) \in \Z_{2}^{12}$, dann
  ist $(L_{4}\: R_{4}) = (R_{3}\: L_{3}\oplus f_{k_{4}}(R_{3})) = (101\,011\:
  010\,001)$
\end{bsp}

Wo ergeben sich jetzt Angriffspunkte?

\subsection{Analyse des DES -- Differentielle Kryptoanalyse}

Methode von Bahim und Shamir aus dem Jahr 1990. Methode speziell für DES
entwickeln, funktioniert aber auch bei ähnlichen Verfahren.

\highl{Chosen-Plaintext-Attack}: Der Angreifer kennt den Algorithmus, das Verfahren
zur Erzeugung der Rundenschlüssel, die Diffusion und die $S$-Boxen. Er kennt
nicht den Schlüssel~$k=(\kappa_{1}\dotso\kappa_{9})$

Wir setzen weiter voraus, dass der Angreifer für einen Klartext~$(L_{0},
R_{0})$ das Resultat~$(L_{r}, R_{r})$ kennt.

Idee: Analysiere Differenzen (modulo 2) verschiedener Klartextblöcke im
Vergleich zu den verschlüsselten Blöcken.

Zwei Blöcke
\begin{gather*}
  (L_{0}, R_{0}), (L_{0}', R_{0}') \mapsto (L_{0}\oplus L_{0}', R_{0}\oplus
     R_{0}')\\
  (L_{r}, R_{r}), (L_{r}', R_{r}') \mapsto (L_{r}\oplus L_{r}', R_{r}\oplus
     R_{r}')
\end{gather*}

Warum ist ein solcher Ansatz erfolgsversprechend?
\begin{itemize}
 \item Differenzen ändern sich nicht, wenn zu zwei Blöcken ein und derselbe
  Block (Rundenschlüssel) addiert wird.

 \item Eigenschaften der $S$-Boxen: Es gibt für einige
  Differenzen~$D\in\Z_{2}^{4}$, so dass für viele Eingabepaare mit dieser
  Differenz~$D$ die Ausgabepaare wieder die Differenz haben.
\end{itemize}

\begin{bemerk}
  Man muss bei der Konstruktion der $S$-Boxen darauf achten, diese Eigenschaft
  zu vermeiden oder zu mindern.
\end{bemerk}

nun konkret am oberen Beispiel: Für zwei Eingabeblöcke $A$ und $A'$ für
$S_{1}$ heißt $A\oplus A'$ \highl{Eingabedifferenz} (Input"=Differenz) und
$S_{1}(A)\oplus S_{1}(A')$ \highl{Ausgabedifferenz} (Output"=Differenz).

Es sei $A^{*}\in\Z_{2}^{4}$ beliebig. Für alle Paare $(A, A')\in
\Z_{2}^{4}\times \Z_{2}^{4}$ mit der Eigenschaft $A\oplus A'=A^{*}$ können wir
die Ausgabedifferenzen bestimmen. $S_{1}(A)\oplus S_{1}(A')$ und deren
Verteilung in einer Tabelle festhalten.

Beachte dabei folgendes: Für $A^{*}\ne(0000)$ gibt es genau \textit{acht}
Belegungen $\{A,A'\}$ mit $A\oplus A'=A^{*}$, nämlich $\{A, A\oplus A^{*}\}$.

% 22.11.

\subsection{Differentielle Kryptoanalyse}

Sei $A, A'\in\Z_{2}^{4}$ als Eingabe für $S_{1}$, $A\oplus A'$ ist die
Input-Differenz, $S_{1}(A)\oplus S_{1}(A')$ ist die Output-Differenz.
Für jeder Differenz $A^{*}\in\Z_{2}^{4}$ ($A^{*}\ne(0000)$) gibt es acht
Mengen $\{A,A'\} = \{A, A\oplus A^{*}\}$ mit dieser Differenz $A^{*}$

\begin{bsp}
  \begin{gather*}
    S_{1} =
       \begin{pmatrix}
         5& 2& 1& 6& 3& 4& 7& 0\\
         1& 4& 6& 2& 0& 7& 5& 3
       \end{pmatrix}
       \qquad A^{*}=(0011)\\
    \begin{array}{cc|c}
      A & A'& S_{1}(A)\oplus S_{1}(A')\\
      \hline
      (0000)& (0011)& (101)\oplus(110) = (011)\\
      (0001)& (0010)& (010)\oplus(001) = (011)\\
      (0100)& (0111)& (011)\oplus(000) = (011)\\
      (0101)& (0110)& (100)\oplus(111) = (011)\\
      \hline
      (1000)& (1011)& (001)\oplus(010) = (011)\\
      (1001)& (1010)& (100)\oplus(110) = (010)\\
      (1100)& (1111)& (000)\oplus(011) = (011)\\
      (1101)& (1110)& (111)\oplus(101) = (010)
    \end{array}
  \end{gather*}
\end{bsp}
Theoretisch sind acht verschiedene Ergebnisse möglich, aber einige treten
häufiger auf als andere. Es gibt 15 derartige Tabellen für $S_{1}$ und
$S_{2}$ (insgesamt 30).

unser Ansatz zunächst: Was passiert bei der Verschlüsselung zweier
Klartextblöcke $(L_{i-1}, R_{i-1})_{12 \text{ Bit}}$ und $(L_{i-1}',
R_{i-1}')_{12 \text{ Bit}}$ in Runde~$i$?
\begin{enumerate}[1.\,{Schritt}]
 \item Diffusion (oder Expansion) $D(R_{i-1})_{8 \text{ Bit}}$
 \item $(D(R_{i-1})\oplus k_{i})_{8 \text{ Bit}} = (A_{4 \text{ Bit}}, B_{4 \text{Bit}})$
 \item $(S_{1}(A)_{3 \text{ Bit}}, S_{2}(B)_{3 \text{ Bit}})_{6 \text{
  Bit}} = f_{k_{i}}(R_{i-1})_{6 \text{ Bit}}$
\end{enumerate}

genauso für den zweiten Klartextblock $(L_{i-1}', R_{i-1}')$, aber genauer:
\begin{gather*}
  R_{i-1}'\\
  \downarrow\\
  D(R_{i-1}') = (\tilde{A}', \tilde{B}') \qquad k_{i} =
     ((k_{i}^{L})_{4 \text{ Bit}}, (k_{i}^{R})_{4 \text{ Bit}})\\
  D(R_{i-1}')\oplus k_{i} = (\tilde{A}'\oplus k_{i}^{L}, \tilde{B}'\oplus
     k_{i}^{R}) = (A', B')\\
  \downarrow\\
  (S_{1}(A'), S_{2}(B')) = f_{k_{i}}(R_{i-1}')
\end{gather*}

Es gilt:
\begin{gather*}
  A\oplus A' = (\tilde{A} \oplus k_{i}^{L}) \oplus (\tilde{A}'\oplus
     k_{i}^{L}) = \tilde{A}\oplus \tilde{A}'\\
  B\oplus B' = (\tilde{B} \oplus k_{i}^{L}) \oplus (\tilde{B}'\oplus
     k_{i}^{L}) = \tilde{B}\oplus \tilde{B}'
\end{gather*}
aber die Output-Differenz $S_{1}(A)+S_{1}(A')$ hängt vom Schlüssel~$k_{i}^{L}$
ab. Wenn $S_{1}$ nicht linear ist, dann gilt i.\,A. nicht.
\begin{gather*}
  S_{1}(A)\oplus S_{1}(A') = S_{1}(A\oplus A')
\end{gather*}
Annahme: Wir kennen $\tilde{A}, \tilde{A}'$ und $S_{1}(A), S_{1}(A')$.

Es gilt:
\begin{enumerate}
 \item $A$ und $A'$ haben die Input-Differenz $A\oplus A' = A^{*} =
  \tilde{A}\oplus \tilde{A}'$
 \item $A$ und $A'$ haben die Output-Differenz $C^{*}=S_{1}(A)\oplus S_{1}(A')$
\end{enumerate}

Weiterhin gilt: $\{A, A'\}$ kommt in der Tabelle für $A^{*}$ vor und man
erkennt alle Möglichkeiten für $\{A,A'\}$ die Output-Differenz $C^{*}$ zu
bilden. Da $\tilde{A}$ und $C^{*}$ bekannt sind und $A=\tilde{A}\oplus
k_{i}^{L}$ ergben sich auf diese Weise Einschränkungen für die Wahl von
$k_{i}^{L}$.

\begin{bsp}
  Illustration am oberen Beispiel: $\tilde{A}=(0100), \tilde{A}'=(0110),
  C^{*}=S_{1}(A)\oplus S_{1}(A')=(010), \tilde{A}\oplus \tilde{A}' = (0011) =
  A^{*}$

  Tabelle: $A\in\{(1001), (1010), (1101), (1110)\}$ nun gilt weiter $k_{i}^{L}
  = A\oplus \tilde{A} \in\{ (1101), (1110), (1001), (1010)\}$
\end{bsp}

Das war jetzt für einen Klartextblock, mit einem weitern Klartextblock kann
man eine weitere Schlüsselmenge finden. Der tatsächliche Schlüssel liegt im
Durchschnitt beider Teilmengen.

Dies Ganze so oft bis der (Runden"~)""Schlüssel eindeutig bestimmt ist.

\subsubsection{Differentielle Kryptoanalyse für ein System mit drei Runden}

Der obige Ansatz ist ausreichend für eine Analyse von drei Runden.
Ausgangspunk: zwei Klartextblöcke wie eben $(L_{0}, R_{0}), (L_{0}', R_{0}')$
und die zugehörigen Geheimtextblöcke $(L_{3}, R_{3}), (L_{3}', R_{3}')$. Es
gilt:
\begin{align*}
  L_{3} &= L_{2}\oplus f_{k_{3}}(R_{2}) = R_{1}\oplus f_{k_{3}}(R_{2}) =
     L_{0}\oplus f_{k_{1}}(R_{0})\oplus f_{k_{3}}(R_{2})\\
  L_{3}' &= L_{0}'\oplus f_{k_{1}}(R_{0}')\oplus f_{k_{3}}(R_{2}')
\end{align*}
Wir wählen die Klartextblöcke, so dass $R_{0}=R_{0}'$ gilt.
Setzen die Output-Differenz $L_{3}^{*} := L_{3}\oplus L_{3}'$.
\begin{gather*}
  L_{3}^{*} = \underbrace{L_{0}\oplus L_{0}'}_{=L_{0}^{*}} \oplus
     f_{k_{3}}(R_{2}) \oplus f_{k_{3}}(R_{2}')\\
  L_{3}^{*}\oplus L_{0}^{*} = f_{k_{3}}(R_{2}')\oplus f_{k_{3}}(R_{2}') =
     f_{k_{3}}(R_{3})\oplus f_{k_{3}}(R_{3}'), da R_{2}=R_{3} und R_{2}'=R_{3}'
\end{gather*}
Wir kennen also $R_{3}=R_{2}$ und damit $D(R_{2}) = (\tilde{A}, \tilde{B})$
und $R_{3}'=R_{2}'$ und damit $D(R_{2}') = (\tilde{A}', \tilde{B}')$.

Die linke Hälfte von $f_{k_{3}}(R_{3})\oplus f_{k_{3}}(R_{3}') =
S_{1}(\tilde{A})\oplus S_{1}(\tilde{A}')$ und sind in der Situation wie oben.

% 27.11.

\begin{gather*}
  S_{2} = \begin{pmatrix}
            4& 0& 6& 5& 7& 1& 3& 2\\
            5& 3& 0& 7& 6& 2& 1& 4
          \end{pmatrix}
     \qquad
     B^{*} = \begin{pmatrix}1& 0& 1& 1\end{pmatrix}
\end{gather*}

\subsection{Differentielle Kryptoanalyse für DES mit drei Runden}

\begin{align*}
  L_{0}^{*} &= L_{0}\oplus L_{0}'\\
  L_{3}^{*}& = L_{3}\oplus L_{3}' = L_{0} \oplus f_{K_{3}}(R_{2}) \oplus
     f_{K_{3}}(R_{2}')\\
  L_{3}^{*} \oplus L_{0}^{*} & = f_{K_{3}}(R_{3})\oplus f_{K_{3}}(R_{3}')&
     \text{da,~} R_{3}=R_{2}, R_{3}'=R_{2}'
\end{align*}

Mit $R_{2}$ kennen wir $D(R_{2}) = (\tilde{A}, \tilde{B})$ und $D(R_{2}') =
(\tilde{A}', \tilde{B}')$.

linke Hälfte: $S_{1}(\tilde{A}\oplus K_{3}^{L}) \oplus S_{1}(\tilde{A}'\oplus
K_{3}^{L})$\\
rechte Hälfte: $S_{2}(\tilde{B}\oplus K_{3}^{R})\oplus S_{2}(\tilde{B}'\oplus
K_{3}^{R})$

$R_{0}=R_{0}'$

Beispiel:
\begin{align*}
  (L_{0}, R_{0})& = (000\,111, 011\,011)\\
  (L_{0}', R_{0}')& = (101\,110, 011\,011)\\
  (L_{3}, R_{3})& = (100\,101, 000\,011)\\
  (L_{3}', R_{3}')& = (011\,000, 100\,100)
\end{align*}

Ziel: Bestimme den Schlüssel~$K$ (bzw. Einschränkung der Möglichkeiten)

\begin{align*}
  R_{2}& = R_{3} = (000\,011)& D(R_{2})& =(0000, 0011) = (\tilde{A},\tilde{B})\\
  R_{2}'& = R_{3}' = (100\,100)& D(R_{2}')& =(1010, 1000) =
     (\tilde{A}',\tilde{B}')
\end{align*}

Eingabedifferenz in $S$-Box $S_{1} = \tilde{A}\oplus\tilde{A}' = (1010)$\\
Ausgabedifferenz von $S_{1}$: linke Hälfte von $L_{3}^{*}\oplus L_{0}^{*}$

linke Hälfte von $L_{3}^{*}\oplus L_{0}^{*}$
\begin{gather*}
  L_{3}^{*} = (100\,101)\oplus (011\,000) = (111\,101)\\
  L_{0}^{*} = (000\,111)\oplus (101\,110) = (101\,001)\\
  L_{3}^{*} \oplus L_{0}^{*} = (010\,100)
\end{gather*}

Die Ausgabedifferenz von $S_{1}$ ist $(010)$. kam in der Tabelle oben \todo{link
finden} zweimal vor. $A\in \{(0011), (1001)\}$

$K_{3}^{L} = A\oplus \tilde{A} = \{(0011), (1001)\}$ zwei Möglichkeiten.

Eingabedifferenz der $S$-Box $S_{2}$:
\begin{gather*}
  \tilde{B}\oplus \tilde{B}' = (0011)\oplus (1000) = (1011)
\end{gather*}
Ausgabedifferenz der $S$-Box $S_{2}$: rechte Hälfte von $L_{3}^{*}\oplus
L_{0}^{*}$: $(100)$.

liefert die Schlüssel $K_{3}^{R}\in\{(1111),(0100)\}$ zwei Möglichkeiten
$\rightarrow$ vier Möglichkeiten für $K_{3}$ und damit acht Möglichkeiten für
$K$ statt 512.

\begin{gather*}
  \begin{array}{c|c|c|c|cl}
    \tilde{B}& \tilde{B}'& S_{2}(\tilde{B})& S_{2}(\tilde{B}')&
    S_{2}(\tilde{B})\oplus S_{2}(\tilde{B}')\\
    \hline
    (0000)& (1011)& (100)& (111)& (011)\\
    (0001)& (1010)& (000)& (000)& (000)\\
    (0010)& (1001)& (110)& (011)& (101)\\
    (0011)& (1000)& (101)& (101)& (000)\\
    (0100)& (1111)& (111)& (100)& (011)\\
    (0101)& (1110)& (001)& (001)& (000)\\
    (0110)& (1101)& (011)& (010)& (001)\\
    (0111)& (1100)& (010)& (110)& (100)& (*)
  \end{array}\\
  (*)\quad B=\{(0111), (1100)\}\qquad K_{3}^{R}= B\oplus \tilde{B} = \{(0100),
     (1111)\}
\end{gather*}

Brauchen ein zweites Klartextpaar: z.\,B. $(L_{0}, R_{0}) = (010\,111,
011\,011)$ und $(L_{0}', R_{0}') = (101\,110, 011\,011)$ mit $(L_{3}, R_{3}) =
(001\,010, 001\,011)$ und $(L_{3}', R_{3}') = (011\,000, 100\,100)$.

1.\,Aufgabe: Bestimme $K_{3}^{L}$ und $K_{3}^{R}$. 2.\,Aufgabe: Bestimme $K$.

Angenommen $K_{3} = (x_{1} x_{2} x_{3} x_{4} x_{5} x_{6} x_{7} x_{8})$.
Dann hat $K$ die Gestalt $K=(x_{p} x_{1} x_{2} x_{3} x_{4} x_{5} x_{6} x_{7})$.
\begin{align*}
  L_{3} = L_{2}\oplus f_{k_{3}}(R_{2})& = R_{1}\oplus f_{k_{3}}(R_{2})\\
  & L_{0}\oplus f_{k_{1}}(R_{0})
\end{align*}

\subsection{Differentielle Analyse des DES mit vier Runden}

Ansatz: "`Eigenschaft 2"': Es gibt einige Differenzen~$D$, so dass es
"`viele"' Eingabepaare mit der Differenz~$D$ gibt, derart dass die
Ausgabedifferenzen übereinstimmen.

Beispiel: $S$-Box $S_{1}$ liefert für $D=A^{*} = (0011)$ in 6~von 8~Fällen die
Ausgabedifferenz $(011)$. $S_{1}(A)\oplus S_{1}(A')$. Das heißt: Für $A^{*} =
(0011)$ erwarten wir mit einer Wahrscheinlichkeit von $\frac{3}{4}$ die
Ausgabedifferenz $(011)$.

$S$-Box $S_{2}$ liefert für
$D=B^{*}=(1100)$ in 4~von 8~Fällen die Ausgabedifferenz $(010)$.
Das heißt: Für $B^{*}=(1100)$ erwarten wir mit einer Wahrscheinlichkeit von
$\frac{1}{2}$ die Ausgabedifferenz $(010)$.

Idee: Für Paare von Klartextblöcken $(L_{0}, R_{0})$ wird $(L_{0}', R_{0}')$
mit $L_{0}\oplus L_{0}' = (0011)$ und $R_{0}\oplus R_{0}' = (1100)$ erwarten
wir (beim richtigen Schlüssel) mit Wahrscheinlichkeit $\frac{3}{4}-\frac{1}{2}
= \frac{3}{8}$ die Ausgabedifferenz $(011\,010)$.

% 29.11.

\subsection{Analyse für vier Runden}

Ansatz: Nichtgleichverteilung der Output-Differenzen.\\
Idee: Versuchen eine Situation nach einer Runde zu erreichen, so dass wir dann
die 3-Rundenanalyse ansetzten können.

Dazu wählen wir Paare von Klartextblöcken $(L_{0}, R_{0})$ und $(L_{0}',
R_{0}')$ mit folgenden Eigenschaften:
\begin{enumerate}
 \item $R_{0}^{*} = R_{0}\oplus R_{0}' = (001\,100)$

  Bei der Bildung von $f_{K_{1}}(R_{0})$ und $f_{K_{1}}(R_{0}')$ passiert
  folgendes:
  \begin{gather*}
    D(R_{0})\oplus D(R_{0}') = (00111100)
  \end{gather*}
  Input für $S_{1}$ ist $(0011)$ für $S_{2}$ ist es $(1100)$.

  für $(0011)$ erwarten wir mit Wahrscheinlichkeit $\frac{3}{4}$ den Output
  $(011)$ bei $S_{1}$ und für $(1100)$ erwarten wir mit Wahrscheinlichkeit
  $\frac{1}{2}$ den Output $(010)$ bei $S_{2}$.

  Wir betrachten die Outputs der beiden $S$-Boxen als unabhängig und erwarten
  deshalb mit Wahrscheinlichkeit $\frac{3}{4}\cdot\frac{1}{2}=\frac{3}{8}$
  eine gesamte Output-Differenz von $f_{K_{1}}(R_{0})\oplus f_{K_{1}}(R_{0}') =
  (011\,010)$

 \item $L_{0}^{*} = L_{0} \oplus L_{0}' = (011\,010)$

  $R_{1}= L_{0}\oplus f_{K_{1}}(R_{0}), R_{1}' = L_{0}'\oplus
  f_{K_{1}}(R_{0}')$. Für den Fall $f_{K_{1}}(R_{0}) \oplus f_{K_{1}}(R_{0}')
  = (011\,010)$ ergibt sich:
  \begin{align*}
    R_{1}\oplus R_{1}' &= (L_{0}\oplus L_{0}') \oplus (f_{K_{1}}(R_{0}) \oplus
       f_{K_{1}}(R_{0}))\\
    & = (011\,010) \oplus (011\,010) = (000\,000)
  \end{align*}
  Da $L_{1} = R_{0}$ und $L_{1}' = R_{0}'$ gilt mit Wahrscheinlichkeit
  $\frac{3}{8}$, dass $(L_{1}, R_{1})$ und $(L_{1}', R_{1}')$ die Eigenschaft
  $R_{1}=R_{1}'$ haben und $(L_{1}\oplus R_{1})\oplus (L_{1}', R_{1}') =
  (R_{0}\oplus R_{0}', 0\dotso 0) = (001\,100, 000000)$.
\end{enumerate}

Strategie: Wähle Klartextpaare $(L_{0}, R_{0})$ und $(L_{0}', R_{0}')$ mit der
Summe $(011\,010, 001\,100)$ und bestimme dazu $(L_{4}, R_{4})$ und $(L_{4}',
R_{4}')$. Angenommen es ist so, dass $R_{1}\oplus R_{1}' = (000\,000)$ (das
gilt in 3 von 8~Fällen), dann haben wir die Ausgangssituation zur Analyse der
Runden 2, 3 und 4 als 3-Rundenanalyse.

Dort, wo die Annahme korrekt ist, erhalten wir eine Menge möglicher Schlüssel
für $K_{4}^{L}$ bzw. $K_{4}^{R}$. Dort, wo die Annahme falsch ist (die
Mehrzahl der Fälle), erhalten wir irgendwelche (zufälligen) Bitfolgen von
acht Bit.

\subsection{Die Sicherheit von DES}

\begin{enumerate}
 \item Die Größe des Schlüsselraums ist $2^{56}$ (es genügt aber
  $2^{55}$~Schlüssel zu testen), mit erschöpfender Suche war 1977 war defakto
  nicht möglich.

  1997: setzt die RSA-Data-Security US\,\$~10\,000 für die Dechiffrierung
  eines DES-Textes aus. Nach 5 Monaten war der Schlüssel ermittelt von Ronald
  Vesper -- durch organisiertes Parallelrechnen via Internet (25\,\%
  des Schlüsselraums wurde getestet.)

  1998: setzt die RSA-Data-Security wieder einen Preis aus und nach 39~Tagen
  war wieder der Schlüssel gefunden, obwohl 85\,\% des Schlüsselraums
  durchsucht wurden.

  1999: Electronic Frontier Foundation, 1536 parallel arbeitende Spezialchips
  benötigen im Schnitt $4\frac{1}{2}$~Tag um den kompletten Schlüsselraus zu
  durchsuchen.

  Quelle:\todo{Quelle einfügen}
 \item Es gibt bei DES \highl[Schlüssel!schwacher]{schwache Schlüssel}, die für alle Runden den gleichen
  Rundenschlüssel erzeugen. Aber man kann diese auch einfach beim Einsatz
  vermeiden.

 \item Differentielle Kryptoanalyse funktioniert nicht, wenn man die $S$-Boxen
  geeignet wählt. (Nicht-Gleichverteilung vermeiden.)
\end{enumerate}

% 4.12.

\subsubsection{DES und differentielle Kryptoanalyse}

Die differentielle Kryptoanalyse war den Designern des DES bekannt und deshalb
folgte die Verteidigung. $S$-Boxen sind so konstruiert, dass für höchstens ein
Viertel der Zweiermengen $\{A, A'\}$ die Output-Differenzen $S(A)\oplus S(A')$
übereinstimmen. Mit der Folge, dass für einen Chosen-Plaintext-Angriff
$2^{47}$ Klartextblöcke benötigt werden. Ein Known-Plaintext-Angriff benötigt
$2^{55}$ Klartextblöcke. Dies ist nicht wesentlich weniger als für einen
Brute-Force-Angriff benötigt werden: $2^{56}$. Deshalb sind es 16~Runden!

\subsubsection{DES und lineare Kryptoanalyse}

Von M.\,Matsui auf der Konferenz EUROCRYPT im Jahre 1993 vorgestellt
(\cite{matsui1}). War den Designern von DES nicht bekannt.

Weder die $S$-Boxen und damit auch die gesamte Verschlüsselung beschreibt eine
lineare Abbildung. Damit sicher gegen solche Angriffe.

Die Idee der \highl{linearen Kryptoanalyse} ist: Approximation der
Verschlüsselung durch lineare Abbildungen. Ansatz: Bilde \texttt{xor} für
einige Klartextbits und \texttt{xor} für eine Geheimtextbits und verknüpfe
beide mit \texttt{xor}. Das Ergebnis ist ein einzelnes Bit, das als die
\texttt{xor}-Verknüpfung einiger Schlüsselbits interpretiert wird. Das Ganze
wieder für eine bestimmte Wahrscheinlichkeit~$p$. Wenn
$p\ne\frac{1}{2}$, Ausnutzung der Asymmetrie (insbesondere ist der
fünfte $S$-Boxtyp des DES dafür anfällig) liefert eine Einschränkung
der Schlüssel.

In der Arbeit von M.\,Mitsui wurde gezeigt, dass man für einen
Known-Plaintext-Angriff nur $2^{43}$~Paare, d.\,h. sie ist besser als die
\highl{differentielle Kryptoanalyse}.

\subsubsection{DES realisiert Diffusion und Konfusion}

\begin{compactdesc}
 \item[Diffusion] Die Änderung der Eingabe in eine $S$-Box in einem
  Bit ändert die Ausgabe in mindestens zwei Bit.
 \item[Konfusion] Jedes Ausgabebit hängt nach fünf Runden von allen
  Eingabebits ab.
\end{compactdesc}

\subsubsection{Keine Gruppeneigenschaft}

Die \highl{Gruppeneigenschaft} lässt sich folgender Maßen beschreiben:
\begin{gather*}
  \forall k_{1},k_{2}\in\mathcal{K} \exists k_{3}\colon
     DES_{k_{1}} \circ DES_{k_{2}} = E_{k_{3}}
\end{gather*}


Für DES gilt aber im Allgemeinen für je drei Schlüssel $k_{1},k_{2},k_{3}$:
\begin{gather*}
       DES_{k_{1}} \circ DES_{k_{2}} \ne E_{k_{3}}
\end{gather*}

Das heißt $2^{56}$ mögliche Schlüssel erzeugen eine viel größere Gruppe
innerhalb von $\mathcal{S}_{2^{64}}$. Beachte $\abs{\mathcal{S}_{2^{64}}} =
(2^{64})! > 10^{10^{20}}$

Gezeigt wurde (1993: Don Coppersmith \help{Kennt jemand den Namen des
Papier?}): Die Gruppe der DES-Verschlüsselungen
umfasst mehr als $10^{2500}$ Verschlüsselungen, die sich durch Kombination
ergeben.

Konsequenz: DES wird bei Mehrfachverschlüsselung sicherer.

\subsubsection{"`Meet-in-the-Middle"'-Angriff}

Doppelte Verschlüsselung bewirkt eine Vergrößerung des Schlüsselraums auf
$2^{112}$~Schlüssel. Der folgende Angriff beschränkt das Durchprobieren auf
$2^{57}$~Versuche bei extremen Speicherplatzbedarf.

Angenommen ein Angreifer kennt einen Klartext~$m$ und den doppelt chiffrierten
Klartext $c=E_{k_{2}}(E_{k_{1}}(m))$ und sucht das Paar $(k_{1}, k_{2})$.
\begin{enumerate}
 \item Berechne und speichere $DES_{k}(m)$ für alle Schlüssel~$k$
  ($2^{56}$~Stück).
 \item Berechne und speichere $DES^{-1}_{k}(c)$ für alle Schlüssel~$k$
  ($2^{56}$~Stück).
 \item Vergleiche beide Listen nach Stellen, die die Gestalt $DES_{k_{1}}(m) =
  DES^{-1}_{k_{2}}(c)$. Hierfür gilt $DES_{k_{2}}(DES_{k_{1}}(m))=c$ und damit
  hat man $(k_{1},k_{2})$.
\end{enumerate}

Unter Umständen gibt es mehrere Schlüsselpaare, dann muss man das Verfahren
nochmal mit einem anderen Paar $(m',c')$ wiederholen. Also sind für
$n$~Schlüssel $2n$~Berechnungen nötig, anstelle von $n^{2}$~Berechnungen. (es
sind noch $n\log n$~Vergleiche notwendig)

\subsubsection{Dennoch in der Praxis}
Denoch wird DES in der Praxis eingesetzt als: $DES_{k_{1}}\circ
DES_{k_{2}}\circ DES_{k_{3}}$ und $DES_{k_{1}}
\circ DES_{k_{2}}^{-1} \circ DES_{k_{1}}$, da DES schnell ist und weit
verbreitet/Hardware vorhanden.

\section{International Data Encryption Algorithm (IDEA)}

Der International Data Encryption Algorithm (kurz \highl{IDEA}) wurde zu
Beginn der neunziger Jahre des letzten Jahrhunderts in einer
Gemeinschaftsarbeit von James Massey und Xueija Lai von der ETH~Zürich und der
Ascom Systec~AG entwickelt. Die Ascom Systec~AG hält zum gegenwärtigen
Zeitpunkt noch einige Patente für IDEA. Denoch wird der Algorithmus im
PGP-""Verfahren eingesetzt.
\help{Stimmt es, dass IDEA in PGP verwendet wird?}

IDEA arbeitet mit der Blocklänge von 64~Bit, einer Schlüssellänge von 128~Bit
und 8~Runden zuzüglich einer Abschlussrunde. Durch den riesigen Schlüsselraum
wird ein Brute-Force-Angriff gegenüber DES wesentlich erschwert.

\begin{figure}[ht]
  \centering
  \input{idea.pdf_t}
  \caption{Blockschema für den Ablauf der $i$. Runde der IDEA-""Verschlüsselung}
  \label{fig:idea}
\end{figure}

Der Ablauf jeder Runde ist in \autoref{fig:idea} dargestellt. Jeder
Klartextblock wird in vier Teilblöcke zu je 16~Bit zerlegt, die durch
Verknüpfung mit 6~Rundenschlüsseln bzw. den Ergebnissen der Verknüpfungen in
vier Teilblöcke von 16~Bit transformiert werden. Als Verknüpfung werden die
drei Operationen Exklusives-""Oder~($\oplus$), Addition modulo~$2^{16}$~
($\boxplus$) und Multiplikation modulo $2^{16}+1$~($\odot$) eingesetzt.

% \begin{enumerate}
%  \item $\alpha_{1} = x_{1}\odot k_{i_{1}}$
%  \item $\alpha_{2} = x_{2}\boxplus k_{i_{2}}$
%  \item $\alpha_{3} = x_{3}\boxplus k_{i_{3}}$
%  \item $\alpha_{4} = x_{4}\odot k_{i_{4}}$
%  \item $\beta_{1} = \alpha_{1} \oplus \alpha_{3}$
%  \item $\beta_{2} = \alpha_{2} \oplus \alpha_{4}$
%  \item $\gamma = \beta_{1} \odot k_{i_{5}}$
%  \item $\delta = \beta_{2} \boxplus \gamma$
%  \item $\epsilon = \delta \odot k_{i_{6}}$
%  \item $\zeta = \gamma \boxplus \epsilon$
%  \item $x_{1}' = \alpha_{1} \oplus \epsilon$
%  \item $x_{2}' = \alpha_{3} \oplus \epsilon$
%  \item $x_{3}' = \alpha_{2} \oplus \zeta$
%  \item $x_{4}' = \alpha_{4} \oplus \zeta$
% \end{enumerate}

Nach der 8.~Runde gibt es eine Schlussrunde:
\begin{align*}
  x_{1}' &= x_{1}\odot k_{9_{1}} &
     x_{2}' &= x_{2}\boxplus k_{9_{2}} &
  x_{3}' &= x_{3}\boxplus k_{9_{3}} &
     x_{4}' &= x_{4}\odot k_{9_{4}}
\end{align*}

Da IDEA andere algebraische Operationen einsetzt als die Feistel-Chiffre,
bezeichnet man ihn auch nicht als eine Feistel-Chiffre. Denoch ist er so
konstruiert, dass die Verschlüsselungsfunktion auch als
Entschlüsselungsfunktion verwendet werden kann.

Die Sicherheit von IDEA ist auf der Unverträglichkeit der drei
unterschiedlichen arithmetischen Operationen begründet. Es ist zwar eine
Klasse von \highl[Schlüssel!schwacher]{schwachen Schlüsseln} mit
$2^{65}$~Elementen bekannt, denoch ist der Algorithmus durch die komplexen
Runden sicher gegen lineare und differentielle Kryptoanalyse.\cite{idea-save}

\section{RC-Familie}

In den 1990ern wurden von Ronald Rivest von der RSA Data Security eine Reihe
von Verschlüsselungsverfahren entwickelt, die als
\highl[RC-Familie]{RC-""Familie} (Ron's Code oder Rivest's Cipher)
zusammengefasst werden.\cite[Abs.\,3.6.2--4]{rsafaq}

\highl{RC2} bezeichnet eine Feistelchiffre, die mit 18~Runden und einer
Klartextblocklänge von 64~Bit arbeitet. Die Schlüssellänge muss ein Vielfaches
von acht sein und kann zwischen einschließlich 8 und 128~Bit gewählt werden.

RC2 wurde 1987 als Ersatz für DES entwickelt und ist als solcher auch
schneller und, bei geeigneter Wahl des Schlüssels, sicherer als DES. RC2
wurde, bis es 1996 von einem Unbekannten im Usenet veröffentlicht wurde,
geheim gehalten.

\highl{RC5} wurde 1994 ebenfalls für die RSA Data Security entwickelt und
weist ungewöhnlich viele Freiheiten bei der Wahl der Parameter auf. Die
Blocklänge kann 32, 64 oder 128~Bit sein. Die Schlüssellänge kann von 0 bis
2040~Bit und die Rundenanzahl von 0 bis 255 gewählt werden.

Es gibt drei Operationen: Schlüsselerweiterung, Ver- und Entschlüsselung. Bei
der Schlüsselerweiterung wird in Abhängigkeit von der Rundenanzahl eine
Tabelle für die Ver"~/""Entschlüsselung erzeugt. Die Ver"~/""Entschlüsselung
arbeitet mit Addition, exklusiven Oder und Bitrotation. Durch einen extrem
einfachen Aufbau ist der RC5-""Algorithmus leicht zu implementieren und zu
verifizieren.
\begin{align*}
  x_{1}' &= rot(x_{1} \oplus x_{2}, x_{2}) \boxplus K_{1} &
  x_{2}' &= rot(x_{2} \oplus x_{1}', x_{1}') \boxplus  K_{2}
\end{align*}

RC5 ist sicher gegen differentielle und lineare Kryptoanalyse.\cite{rc5save}

Um die Kriterien für die Ausschreibung des Advanced Encryption Standards zu
erfüllen, wurde RC5 etwas verändert und als \highl{RC6} eingereicht. Die
Blockgröße, Schlüssellänge und Rundeanzahl können aus den selben Bereichen wie
bei RC5 gewählt werden. RC6 wurde 1998 veröffentlich und gelangte auch in die
letzte Ausscheidungsrunde für den AES.

% 6.12.

\section{Blowfish und Twofish}

Blowfish (1994), Twofish (1998) von Bruce Schneier

\begin{description}
 \item[Blowfish] variable Schlüssellänge (bis 448~Bit), $S$-Boxen
  schlüsselabhängig, 16~Runden, Blöcklänge~64. Trotz aufwendiger $S$-Boxen
  ein schnell zu implementierender Algorithmus (\texttt{xor} und Addition von
  32-Bitwerten)

 \item[Twofish] Runde der letzten 5 AES-Kandidaten. Schlüssellänge: 128, 192,
  256, Blocklänge: 64, $8\times8$ $S$-Boxen, arithmetische Operationen in
  $\F_{2^{8}}$ endlicher Körper der Ordnung $2^{8}$ (anstelle von $\Z_{2}=\F_{2}$)
\end{description}

\section{Sonstige Blockchiffren}

\begin{description}
 \item[SAFER] 1995, Massey
 \item[CAST] 1990, 1997 -- wird bei PGP benutzt
 \item[SKipjack] NSA, 1990
 \item[KASUMI] Weiterentwicklung von MISTY, wird zur Verschlüsselung bei UMTS
  eingesetzt.
\end{description}

\section{Exkurs über endliche Körper}

\subsection{Endliche Körper von Primzahlordnung}

Wir wissen bereits aus \autoref{sec:restklassen}, dass sich die ganzen Zahlen
in Äquivalenzklassen modulo~$m$ zerlegen lassen:
\begin{gather*}
  \Z_{m} := \Z_{\nicefrac{}{\equiv (m)}}
     = \{ [0]_{m}, [1]_{m}, \dotsc, [m-1]_{m} \}
     = \{0,1,\dotsc,m-1\}
\end{gather*}
Damit ergibt sich für $m>1$ ein Ring $[\Z_{m}, +,\cdot]$ mit dem Nullelement
$0 := [0]_{m}$, dem Einselement $1 := [1]_{m}$ und insgesamt $\abs{\Z_{m}}=m$
Elementen. Ein Element $a\in\Z_{m}$ heißt Einheit \gdwdef es ein inverses
Element $b$ mit $a\cdot b=1$ gibt. Es gilt: $a$ ist Einheit in $\Z_{m}$ \gdw
$\ggT(a,m) = 1$ (\autoref{lem:5}).

$\Z_{m}^{*}$ bezeichnet die \highl{Menge der Einheiten} in $\Z_{m}$, also
gilt: $\abs{\Z_{m}^{*}} = \phi(m)$ (\autoref{lem:5}). Wenn $m=p$ eine Primzahl
ist, dann ist $\Z_{p}^{*} = \{1, 2,\dotsc,p-1\}$ (da $\phi(p)=p-1$) und
$\Z_{p}$ ein endlicher Körper der Ordung~$p$.

\subsection{Polynomringe}

Es sei $[R, +,\cdot]$ ein (endlicher) Ring, z.\,B. $[\Z_{m}, +,\cdot]$, und
$x$ ist ein Symbol, das nicht im Ring vorkommt ($x\notin R$). Wir definieren
\highl{Polynome} vom Grad~$k$, mit $r_{i}\in R$ für $i=0,\dotsc,k$, wobei
$r_{k}\ne0$ ist, wie folgt:
\begin{gather*}
  p(x) := r_{k}\cdot x^{k} + r_{k-1}\cdot x^{k-1} + \dotsb+ r_{1} x^{1} + r_{0}
\end{gather*}
$R[x]$ bezeichnet die \highl{Menge aller Polynome} in $x$ über $R$.

Die Addition und Multilikation von zwei Polynomen erfolgt wie üblich
komponentenweise. Damit bildet die Struktur $[R[x], +, \cdot]$ einen
(abzählbar unendlichen) \highl{Polynomring}.

Ein Polynom~$p\in R[x]$ heißt \highl{reduzibel} \gdwdef es zwei
Polynome~$r,s\in R[x]$ vom Grad größer 0 gibt, so dass man $p$ als Produkt von
$r$ und $s$ schreiben kann; $p(x) = r(x)\cdot s(x)$.

Ein Polynom~$p\in R[x]$ heißt \highl{irreduzibel} \gdwdef es nicht reduziebel
ist, d.\,h. es keine zwei Polynome $r,s\in R[x]$ gibt, so dass $p=r\cdot s$
ist.

Man kann sich die Bedeutung von irreduzibel wie die von prim für ganze Zahlen
vorstellen. Eine Zahl heißt prim, wenn sie keine (nicht trivialen) Teiler
besitzt und analog bezeichnet man ein Polynom als irreduzibel, wenn es sich
nicht als Produkt (nicht trivialer) Polynome darstellen lässt.

% 13.12.

\subsection{\texorpdfstring{$\F_{p^{k}}$}{Fpk} endlicher Körper der Ordnung
  \texorpdfstring{$p^{k}$}{pk}}

Analog zur Zerlegung der ganzen Zahlen in Restklassen anhand eines Moduls
definiert man die Zerlegung der Menge aller Polynome (mit Koeffizienten aus
$\Z_{p}$; $p$~prim) in Restklassen, wobei man die Faktormenge (Menge der
Restklassen) mit $\F_{p^{k}}$ identifiziert.

Dazu benötigt man ein irreduzibles Polynom~$m\in\Z_{p}[x]$ vom Grad~$k$, das
als \highl{Modulpolynom} dient. Zwei Polynome~$s,t\in\Z_{p}[x]$ sind in der
gleichen Restklasse, wenn sie bei der Division durch $m$ den gleichen
Rest~$r\in\Z_{p}[x]$ vom Grad kleiner~$k$ lassen:
\begin{align*}
  s(x) &= a(x)\cdot m(x) + r(x)\qquad\text{und}\qquad t(x) =b(x)\cdot m(x)+r(x)\\
  [r]_{m} &= \{ r(x) + l(x)\cdot m(x)\colon l\in\Z_{p}[x]\}\\
  \nicefrac{\Z_{p}[x]}{m(x)} &= \{ [r(x)]_{m(x)}\colon r(x)\in \Z_{p}[x],
     r\text{~vom Grad $<$ dem Grad von $m$}\}
\end{align*}
Das Polynom~$r$ heißt \highl{Repräsentant} von $s$ und $t$ in $\F_{p^{k}}$ und
hat die Form
\begin{gather*}
  r(x) = \rho_{k-1} x^{k-1} + \rho_{k-1} x^{k-2} + \dotsb+ \rho_{1} x + \rho_{0}
\end{gather*}
mit den Koeffizienten $\rho_{k-1},\rho_{k-2},\dotsc,\rho_{1},\rho_{0}\in
\Z_{p}$. Es gibt also $p^{k}$ verschieden Polynome dieser Form, also hat die
Menge $\nicefrac{\Z_{p}[x]}{m(x)}$ die Mächtigkeit $p^{k}$.
\begin{gather*}
  \F_{p^{k}} = \nicefrac{\Z_{p}[x]}{m(x)}
\end{gather*}

Für das Rechnen mit diesen Restklassen gilt: Die Addition~$\oplus$ und die
Multiplikation~$\odot$ erfolgen wie üblich bei Polynomen, nur dass bei der
Multiplikation noch eine Division durch den Modul $m(x)$ angeschlossen wird,
wobei der Rest das Ergebnis ist.

Die Multiplikation~$\odot$ hängt also von dem Modulpolynom~$m(x)$ ab. Jedoch
sind die Körper $F_{256}[m(x)]$ und $F_{256}[m'(x)]$ isomorph zu einander.
\help{Kann das mal bitte jemand bestätigen!}

Bei AES verwendet man $p=2, k=8$, d.\,h. wir betrachen $\F_{2^{8}} = \F_{256}$
mit Koeffizienten aus $\Z_{2}$, und das Modulpolynom
\begin{gather*}
  m(x) = x^{8} + x^{4} + x^{3} + x +1
\end{gather*}
\help{Kann man zeigen dann $m(x)$ irreduzibel ist oder ist das genauso
  schwierig, wie der Primnachweis einer Zahl?}

\begin{bsp}
  \label{bsp:1}
  Gegeben sind die beiden Polynome~$p,q\in\F_{2^{8}}$ mit $p(x)= x^{6} + x^{4}
  + x^{2} + x + 1$ und $q(x)= x^{7}+x+1$ und gesucht ist das
  Produkt $p\odot q$ gemäß obiger Definition.

  Zuerst die übliche, komponentenweise Multiplikation von Polynomen:
  \begin{multline*}
    (x^{6} + x^{4} + x^{2} + x + 1) \odot (x^{7}+x+1)\\
    \begin{array}{*{13}{r@{\;}}}
      = &x^{13} &+ x^{11} &+ x^{9} &+ x^{8} &+ x^{7}\\
      +&&&&&+ x^{7} &&+ x^{5} &&+ x^{3} &+ x^{2} &+ x\\
      +&&&&&&+ x^{6} &&+ x^{4} &&+ x^{2} &+ x &+1\\
      \cline{2-13}\\[-3mm]
      = &x^{13} &+ x^{11} &+ x^{9} &+ x^{8} &&+ x^{6} &+ x^{5} &+ x^{4}
      &+ x^{3} &&&+ 1
    \end{array}
  \end{multline*}
  (Hinweis: Die Koeffizienten $x^{7}, x^{2}$ und $x$ entfallen, da
  $1+1\pmod{2}\equiv0$ ist.)

  Jetzt muss dieses Polynom noch reduziert werden:
  \begin{gather*}
    \begin{array}{*{11}{r@{\;}}l}
      &(x^{13} &+ x^{11} &+ x^{9} &+ x^{8} &+ x^{6} &+ x^{5} &+ x^{4} &+ x^{3} &+ 1&)& :
      (x^{8} + x^{4} + x^{3} + x + 1)
      = \underbrace{x^{5} + x^{3}}_{=q(x)}\\[-4mm]
      \oplus\,&(x^{13} &&+ x^{9} &+ x^{8} &+ x^{6} &+x^{5}&&&&)\\
      \cline{1-11}\\[-3mm]
      &&x^{11} &&&&&+ x^{4} &+ x^{3} &+ 1\\
      &&\oplus\,(x^{11} &+ x^{7} &+ x^{6} &&&+ x^{4} &+x^{3}&&)\\
      \cline{3-11}\\[-3mm]
      &&&x^{7} &+ x^{6} &&&&&+1&&= r(x)
    \end{array}
  \end{gather*}

  Also ist
  \begin{gather*}
    (x^{6} + x^{4} + x^{2} + x + 1) \odot (x^{7} + x +1) = x^{7} + x^{6} +1
  \end{gather*}
\end{bsp}

Da es für die Multiplikation nur 65\,536 verschiedene Kombinationen
gibt, kann man diese auch vorberechnen und in einer $256\times256$-Tabelle
abspeichern.

\subsection{Darstellung der Elemente aus \texorpdfstring{$\F_{256}$}{F256}}

\begin{enumerate}
 \item Darstellung als Polynom
  \begin{gather*}
    p(x) = b_{7} x^{7} + b_{6} x^{6} + \dotsb+ b_{1} x + b_{0}
  \end{gather*}
  mit $b_{7},\dotsc, b_{0} \in \{0,1\}$.

 \item Darstellung als eine Folge von Bits $(b_{7}, b_{6}, \dotsc, b_{0})$,
  wobei $b_{7},\dotsc, b_{0}$ die Koeffizienten aus der Polynomdarstellung
  sind.

  Für die Zahlen in \autoref{bsp:1} lautet die Darstellung
  \begin{gather*}
    (0,1,0,1,0,1,1,1) \odot (1,0,0,0,0,0,1,1) = (1,1,0,0,0,0,0,1)
  \end{gather*}

 \item Darstellung als zweistellige Hexadezimalzahl der Bitfolgen

  In unserem \autoref{bsp:1}: $57\odot 83 = C1$
\end{enumerate}

\subsection{Der erweiterte euklidische Algorithmus}

Mit dem \highl{erweiterten euklidischen Algorithmus} bestimmt man zusätzlich
zum größten gemeinsamen Teiler zweier Zahlen~$a$ und $b$ zwei Zahlen~$u$ und
$v$, die folgende Gleichung erfüllen
\begin{gather}
  \label{eq:erw-euk-algo}
  \ggT(a,b) = u\cdot a+v\cdot b
\end{gather}

\begin{verbatim}
Eingabe: a, b;
begin
    b[0] := a; b[1] := b;
    u[0] := 1; v[0] := 0;
    u[1] := 0; v[1] := 1;
    i := 1;
    while not teilt(b[i], b[i-1]) do
    begin
        q[i] := b[i-1] div b[i];
        b[i+1] := b[i-1] - q[i] * b[i];
        u[i+1] := u[i-1] - q[i] * u[i];
        v[i+1] := v[i-1] - q[i] * v[i];
        i := i + 1;
    end
end
Ausgabe: ggT := b[i], u := u[i], v := v[i];
\end{verbatim}

\begin{lemma}\label{lem:6}
  Die oben gemachte Aussage, dass der erweiterte euklidische Algorithmus zwei
  Zahlen~$u$ und $v$ bestimmt, die die Gleichung $\ggT(a,b) = u\cdot a+v\cdot
  b$ erfüllen, ist korrekt.

  \begin{proof}
    Per Induktion können wir zeigen, dass für alle Schritte~$i$ gilt:
    $b_{0}\cdot u_{i} + b_{1}\cdot v_{i} = b_{i}$.

    Der Induktionsanfang für $i=1$ ist klar. Also gilt die Aussage
    für den $(i-1)$. und $i$.\,Schritt. Für den $(i+1)$.\,Schritt
    folgt dann
    \begin{align*}
      b_{0} u_{i+1} + b_{1} v_{i+1} &= b_{0} (u_{i-1} - q_{i} u_{i}) + b_{1}
         (v_{i-1}-q_{i}v_{i})\\
      &= (b_{0}u_{i-1} + b_{1} v_{i-1}) - q_{i} (b_{0} u_{i} + b_{1}v_{i})\\
      &= b_{i-1} - q_{i}b_{i} = b_{i+1}
    \end{align*}
  \end{proof}
\end{lemma}

% 18.12.

\begin{bsp}
  Seien $a=220=b_{0}$ und $b=26=b_{1}$ (ganze Zahlen) gegeben.
  \begin{gather*}
    \begin{array}{c|cccc}
      i& q_{i} & b_{i+1} & u_{i+1}& v_{i+1}\\
      \hline
      1& 8& 200-8\cdot 26=12& 1-8\cdot0=1& 0-8\cdot1=-8\\
      2& 2& 26-2\cdot 12=2& 0-2\cdot1=-2& 1-2\cdot(-8) = 17\\
    \end{array}
  \end{gather*}
  Abbruch im 3.\,Schritt, da $2\mid12$. Der größte gemeinsame Teiler von 220
  und 26 ist also 2 und es gilt:
  \begin{gather*}
    2 = -2\cdot 220 + 17\cdot 26 = -440 + 442
  \end{gather*}
\end{bsp}

Mit Hilfe des erweiterten euklidischen Algorithmus' lässt sich zu einem
Element des $\F_{256}$ das \highl{multiplikative Inverse} bestimmen. Dazu muss
man den \highl{erweiterten euklidischen Algorithmus} auf Polynome anwenden,
was aber keine Änderungen am Algorithmus selbst erfordert. Man muss nur
beachten, dass man für die einzelnen Operationen ($+$, $-$, $\cdot$ und $div$)
die entsprechenden Operationen für den $\F_{256}$ ($\oplus$,
$\oplus$\footnote{Wenn man sich die Verknüpfungstabellen für $\oplus$, $-$ und
\texttt{xor} aufschreibt, sieht man, dass alle drei Operationen äquivalent sind.},
$\odot$ und Polynomdivision) verwendet.

Es sei $p(x)\in\F_{256}$ mit $p(x)\ne0$. Da $m(x)$ irreduzibel ist, sind
$p(x)$ und $m(x)$ teilerfremd zu einander, d.\,h. der größe gemeinsame Teiler
von $p(x)$ und $m(x)$ ist 1. Also liefert der erweiterte euklidische
Algorithmus nach \autoref{eq:erw-euk-algo} zwei Polynome $u(x)$ und $v(x)$
mit der Eigenschaft, dass sich 1 als
\begin{gather*}
  1 = p(x) u(x) + m(x) v(x)
\end{gather*}
darstellen lässt. Daraus folgt: $p(x)\odot u(x) =1$, $u$ ist also das Inverse
zu $p$ bezüglich~$\odot$.

\begin{bsp}
  Gegeben seien $a(x) = m(x) = x^{8} + x^{4} + x^{3} + x +1 = b_{0}$ und
  $b(x) = x^{7} + x^{6} + x^{3} + x + 1 = b_{1}$. (Elemente des $F_{256}$)

  \begin{enumerate}[1.\,{Schleifendurchlauf}]
   \item $(x^{8} + x^{4} + x^{3} + x + 1) : (x^{7} + x^{6} + x^{3} + x +1) =x+1$\\
    $\oplus (x^{8} +x^{7} + x^{4} + x^{2} +x)$\\
    ---\\
    $x^{7} + x^{3} + x^{2} + 1$\\
    $\oplus (x^{7} + x^{6} + x^{3} +x +1)$\\
    ---\\
    $x^{6} + x^{2} + x$

    Es ergibt sich also:
    \begin{align*}
      q_{1}(x) &= x + 1\\
      b_{2}(x) &= b_{0}(x) - q_{1}(x)\cdot b_{1}(x) = x^{8} + x^{4} + x^{3} +
         x +1 - (x+1)\cdot(x^{7} + x^{6} + x^{3} + x + 1) = x^{6}+x^{2}+x\\
      u_{2}(x) &= u_{0}(x) - q_{1}(x)\cdot u_{1}(x) = 1 - (x+1)\cdot0 = 1\\
      v_{2}(x) &= v_{0}(x) - q_{1}(x)\cdot v_{1}(x) = 0 - (x+1)\cdot1 = x+1
    \end{align*}

   \item $(x^{7} + x^{6} + x^{3} + x + 1) : (x^{6} + x^{2} + x) = x+1$\\
    $\oplus(x^{7} + x^{3} + x^{2})$\\
    ---\\
    $x^{6} + x^{2} + x + 1$\\
    $\oplus(x^{6} + x^{2} + x)$\\
    ---
    1

    Die Zwischenergebnisse:
    \begin{align*}
      q_{2}(x) &= x+1\\
      b_{3}(x) &= b_{1}(x) - q_{2}(x)\cdot b_{2}(x)
         = (x^{7} +x^{6} +x^{3} +x +1) - (x+1)\cdot (x^{6}+x^{2}+x) = 1\\
      u_{3}(x) &= u_{1}(x) - q_{2}(x)\cdot u_{2}(x)
         = 0 - (x+1)\cdot 1 = x+1\\
      v_{3}(x) &= v_{1}(x) - q_{2}(x)\cdot v_{2}(x)
         = 1 - (x+1)\cdot (x+1) = x^{2}
    \end{align*}
  \end{enumerate}

  Es gilt also nach \autoref{eq:erw-euk-algo}
  \begin{align*}
    u(x)\cdot a(x) + v(x) \cdot b(x)
       &= (x+1) (x^{8} +x^{4} +x^{3} +x +1) + x^{2} (x^{7} +x^{6} +x^{3} +x +1)\\
       &= x^{9} +x^{5} +x^{4} +x^{2} +x
          +x^{8} +x^{4} +x^{3} +x +1\\
         &\qquad +x^{9} +x^{8} +x^{5} +x^{3} +x^{2} = 1
  \end{align*}
  woraus folgt, dass $v(x) a(x) = u(x) m(x) + 1$. Also ist $v(x) \odot a(x) =
  1$ und somit ist $v$ das Inverse bzgl. $\odot$ zu $a$: $v(x) = a^{-1}(x)$.

  Oder als Bitfolgen geschrieben: $a(x) = (1100\,1011)$ und $a^{-1}(x) =
  (0000\,0100)$
\end{bsp}

\subsection{Polynome über dem Körper \texorpdfstring{$\F_{256}$}{F256}}
\label{sec:f256x}

Wir betrachten den Polynomring $\nicefrac{\F_{256}[x]}{(x^{4}+1)}$. Die
Elemente sind Polynome höchstens dritten Grades.
\begin{gather*}
  c(x) = c_{3} x^{3} + c_{2} x^{2} + c_{1} x + c_{0}
\end{gather*}
dabei sind die Koeffizienten~$c_{i}\in\F_{256}$ und erlauben die folgende
Darstellung:

\begin{bsp}
  \begin{enumerate}
   \item als Polynom: $c(x) = 01 x^{3} + 03 x^{2} + A1 x + 02$
   \item Binär: $[0000\,0001, 0000\,0011, 1010\,0001, 0000\,0010]$
   \item Hexadezimal: $[01, 03, A1, 02]$
  \end{enumerate}
\end{bsp}

Für das Rechnen mit den Elementen aus $\nicefrac{\F_{256}[x]}{(x^{4}+1)}$ gilt
wieder, dass die Addition $a\oplus b$ komponentenweise mit \texttt{xor} erfolgt
\begin{gather*}
  a(x)\oplus b(x) = (a_{3}\oplus b_{3}) x^{3} + (a_{2} \oplus b_{2}) x^{2} +
     (a_{1}\oplus b_{1}) x + (a_{0} \oplus b_{0})
\end{gather*}
und die Multiplikation $a\otimes b$ in zwei Schritten abläuft
\begin{enumerate}
 \item zuerst die Polynommultiplikation $c(x) = a(x)\odot b(x) = c_{6} x^{6} + \dotsb+
  c_{1} x^{1} + c_{0}$, wobei folgendes gilt
  \begin{align*}
    c_{6}& = (a_{3}\odot b_{3})\\
    c_{5}& = (a_{3}\odot b_{2})\oplus (a_{2}\odot b_{3})\\
    c_{4}& = (a_{3}\odot b_{1})\oplus (a_{2}\odot b_{2})\oplus
       (a_{1}\odot b_{3})\\
    c_{3}& = (a_{3}\odot b_{0})\oplus (a_{2}\odot b_{1})\oplus
       (a_{1}\odot b_{2})\oplus (a_{0}\odot b_{3})\\
    c_{2}& = (a_{2}\odot b_{0})\oplus (a_{1}\odot b_{1})\oplus
       (a_{0}\odot b_{2})\\
    c_{1}& = (a_{1}\odot b_{0})\oplus (a_{0}\odot b_{1})\\
    c_{0}& = (a_{0}\odot b_{0})
  \end{align*}

 \item Anschließend muss noch eine Faktorisierung modulo $(x^{4}+1)$
  durchgeführt werden. Entweder führt man die drei Schritte der
  Polynomdivision $c(x) : (x^{4}+1)$ durch oder man verwendet die Eigenschaft
  $x^{i}\pmod{x^{4}+1} = x^{i\pmod{4}}$ und erhält so das modulare Produkt
  \begin{align*}
    d(x) &= a(x)\odot b(x) \pmod{x^{4}+1}
       = c_{6} x^{6} + \dotsb+ c_{1} x^{1} + c_{0} \pmod{x^{4}+1}\\
    &= c_{6} x^{2} + c_{5} x + c_{4} + c_{3} x^{3} + c_{2} x^{2} + c_{1} x +
       c_{0}\\
    &= \underbrace{c_{3}}_{=d_{3}} x^{3}
       + \underbrace{(c_{6}\oplus c_{2})}_{=d_{2}} x^{2}
       + \underbrace{(c_{5}\oplus c_{1})}_{=d_{1}} x
       + \underbrace{(c_{4}\oplus c_{0})}_{=d_{0}}
  \end{align*}
  mit den Koeffizienten
  \begin{align*}
    d_{3}& = (a_{3}\odot b_{0}) \oplus (a_{2}\odot b_{1}) \oplus
       (a_{1}\odot b_{2}) \oplus (a_{0}\odot b_{3})\\
    d_{2}& = (a_{2}\odot b_{0})\oplus (a_{1}\odot b_{1})\oplus
       (a_{0}\odot b_{2}) \oplus (a_{3}\odot b_{3})\\
    d_{1}& = (a_{1}\odot b_{0})\oplus (a_{0}\odot b_{1}) \oplus
       (a_{3}\odot b_{2})\oplus (a_{2}\odot b_{3})\\
    d_{0}& = (a_{0}\odot b_{0})\oplus (a_{3}\odot b_{1})\oplus
       (a_{2}\odot b_{2})\oplus (a_{1}\odot b_{3})
  \end{align*}

  Matrizenschreibweise:
  \begin{gather*}
    \begin{pmatrix}
      d_{3}\\
      d_{2}\\
      d_{1}\\
      d_{0}
    \end{pmatrix} =
       \begin{pmatrix}
         a_{0}& a_{1}& a_{2}& a_{3}\\
         a_{3}& a_{0}& a_{1}& a_{2}\\
         a_{2}& a_{3}& a_{0}& a_{1}\\
         a_{1}& a_{2}& a_{3}& a_{0}
       \end{pmatrix} \cdot
       \begin{pmatrix}
         b_{3}\\
         b_{2}\\
         b_{1}\\
         b_{0}
       \end{pmatrix}
  \end{gather*}
\end{enumerate}

\begin{bsp}
  \begin{gather*}
    [00,00,00,01] \otimes [47, 08, 1F, 2B] = [47, 08, 1F, 2B]\\
    [01,00,00,00]\otimes [2B, 1F, 08, 47] = [47, 2B, 1F, 08]
  \end{gather*}
\end{bsp}

Der Ring $R=\nicefrac{\F_{256}[x]}{(x^{4}+1)}$ ist kein Körper, d.\,h. nicht
jedes Element $c(x)\in R$ besitzt ein Inverses. AES
benutzt
\begin{gather*}
  c(x) = 03 x^{3}+ 01 x^{2} + 01 x + 02
\end{gather*}
mit dem Inversen $c^{-1}(x) = 0B x^{3} + 0D x^{2} + 09 x + 0E$

\section{Der Advanced (Data) Encryption Standard -- AES}

\subsection{Historischer Abriss}
\begin{description}
 \item[1997:] macht die US-Standardisierungsbehörte ein \textit{öffentliche}
  Ausschreibung eines Verfahrens als Nachfolgers von DES. Forderungen an das
  Verfahren: öffentlich, lizenzfrei, weltweit verfügbar, schneller als
  Triple-DES. Vorgaben: Blocklänge min. 128 und Schlüssellänge von 128, 192,
  256.

 \item[1998:] Wurden 15 Verfahren eingereicht. (darunter auch MAGENTA von der
  deutschen Telekom, das schon in der Präsentation gebrochen wurde)

 \item[1999:] 5 Kandidaten in der Endrunde: Twofisch (Platz 2, weil $\F_{256}$ und
  nicht $\F_{2}$), RC6, MARS (IBM, David Coppersmith), Serpent (ähnlich DES,
  über 32 Runden, Platz 3), Rijndael

 \item[2000:] Wird Rijndael als Sieger bekannt gegeben.

 \item[2002:] Rijndael wird als AES (FIPS) veröffentlich.
\end{description}

Durch die Forderung, dass AES öffentlich seien soll, ist der mathematische
Hintergrund für AES bekannt, wärend z.\,B. der Grund für die Wahl der
$S$-Boxen bei DES unbekannt ist. --~IBM kannt bereits seit den 1970ern die
differentielle Kryptoanalyse.~-- Damit ist auch für jederman nachprüfbar, dass
AES korrekt arbeitet.

\subsection{Bescheibung des Verfahrens von Rijndael}

Das Verfahren von Rijndael ist eine iterierte Blockchiffre, deren Block- und
Schlüssellänge unabhängig voneinander 128, 192 oder 256~Bit betragen können.
Davon abhängig ergibt sich die Rundenzahl als 10, 12 oder 14~Runden. Das
Verfahren ist keine Feistel-Chiffre.

\help{Was ist eine iterierte Blockchiffre?}
\help{Warum ist Rijndael keine Feistel-Chiffre?}

Für AES wurden 128~Bit als Blocklänge festgelegt, woraus sich 10~Runden für
einen 128~Bit Schlüssel, 12~Runden bei einem 192~Bit Schlüssel und 14~Runden
für einen 256~Bit langen Schlüssel ergeben. Aus dem Schlüssel werden
$r+1$~Rundenschlüssel von je 128~Bit Länge erzeugt, wobei $r$ die Rundenzahl
ist. Jede Runde bis auf die letzte besteht aus vier Schritten
(\autoref{fig:aes}):
\begin{enumerate}
 \item \highl{Key-Add} -- Verknüpfung mit dem Rundenschlüssel
 \item \highl{Byte-Sub} -- nicht lineare Transformation als Schutz vor
  differenzieller und linearer Kryptoanalyse
 \item \highl{Shift-Row} -- Diffusion der Bits innerhalb einer Zeile
 \item \highl{Mix-Column} -- Diffusion der Bits innerhalb einer Spalte
\end{enumerate}
In der letzten Runde wird statt dem Mix-Column-Schritt nochmal ein
Key-Add-Schritt mit dem $(r+1)$.\,Schlüssel vorgenommen.

% 20.12.

\subsection{Notationen für AES}

Es werden Bytes von je 8~Bit verwendet, die somit als Elemente des Körpers
$\F_{256}$ interprtiert werden können; $a=a_{7}a_{6}\dotso a_{0}\in\F_{256}$.
Ein Eingabeblock~$S$ von 128~Bit Länge wird in eine Folge von 16~Bytes
zerlegt.
\begin{gather*}
  S = a^{(0)}a^{(1)}\dotso a^{(14)}a^{(15)}
\end{gather*}
Diese Bytefolge wird auf eine $4\times4$-Matrix spaltenweise übertragen:
\begin{gather*}
  S =
     \begin{pmatrix}
       a^{(0)}& a^{(4)}& a^{(8)}& a^{(12)}\\
       a^{(1)}& a^{(5)}& \dotso\\
       a^{(2)}& \dotso \\
       a^{(3)}& a^{(7)}& a^{(11)}& a^{(15)}
     \end{pmatrix} =
     \begin{pmatrix}
       a^{(0,0)}& a^{(0,1)}& a^{(0,2)}& a^{(0,3)}\\
       a^{(1,0)}& a^{(1,1)}& \dotso\\
       a^{(2,0)}& \dotso \\
       a^{(3,0)}& a^{(3,1)}& a^{(3,2)}& a^{(3,3)}
     \end{pmatrix}
     = (a^{z,s})_{4\times4}
\end{gather*}

\begin{figure}
  \centering
  \input{aes-runde.pdf_t}
  \caption{Schema für die $i$.\,Runde des AES}
  \label{fig:aes}
\end{figure}

Die Eingabe des ersten Schritts (\highl{Key-Add}) in der $i$.\,Runde wird mit
$S_{i,a}$ bezeichnet und das Ergebnis des ersten Schritts wird als Eingabe des
zweiten Schritts (\highl{Byte-Sub}) verwendet und mit $S_{i,b}$ bezeichnet
\begin{gather*}
  S_{i,a} =
     \begin{pmatrix}
       a^{(0,0)}& a^{(0,1)}& a^{(0,2)}& a^{(0,3)}\\
       \vdots &&& \vdots\\
       a^{(3,0)}& \hdotsfor{2} & a^{(3,3)}
     \end{pmatrix}
     \qquad S_{i,b} =
     \begin{pmatrix}
       b^{(0,0)}& b^{(0,1)}& b^{(0,2)}& b^{(0,3)}\\
       \vdots &&&\vdots \\
       b^{(3,0)}& \hdotsfor{2} & b^{(3,3)}
     \end{pmatrix}
\end{gather*}
Das Ergbnis des zweiten Schritts wird als Eingabe des dritten Schritts
(\highl{Row-Shift}) verwendet und mit $S_{i,c}$ bezeichnet. Das Ergebnis des
dritten Schritts wird als Eingabe für den vierten Schritt
(\highl{Column-Mix}) verwendet und mit $S_{i,d}$ bezeichnet. Die
Ausgabe des vierten Schritts ist gleichzeitig die Ausgabe der $i$.\,Runde und
somit wieder die Eingabe~$S_{i+1,a}$ für den ersten Schritt in der
$(i+1)$.\,Runde. siehe \autoref{fig:aes}

Für die Elemente des Rings $\nicefrac{\F_{256}[x]}{x^{4}+1}$ verwendent man
die Polynomdarstellung oder die Hexadezimalschreibweise
\begin{gather*}
  a(x) = 03x^{3} + 01x^{2} + 01x + 02\quad\text{bzw.}\quad a = [03, 01, 01, 02]
\end{gather*}

\subsection{Beschreibung der einzelnen Schritte}

\help{Warum macht man das alles so kompliziert? Warum muss man das alles
  mathematisch begründen? Man könnte doch die Abbildungen der S-Boxen zufällig
  festlegen. Was hilft es, ständig den Körper/Ring ($\F_{256}$,
  $\nicefrac{\F_{256}[x]}{x^{4}+1}$ $\nicefrac{\F_{2}[x]}{x^{8}+1}$) zu
  wechseln? Warum wechselt man immer zwischen den Körpern/Ringen?}

\subsubsection{Key-Add}
Die Verknüpfung mit dem Rundenschlüssel, um die Ausgabe vom Schlüssel abhängig
zu machen, ist nicht weiter spektakulär:
\begin{gather*}
  S_{i, b} = S_{i,a} \oplus K_{i}
\end{gather*}

\subsubsection{Byte-Sub}

Für jedes Byte $b^{(z,s)}\in\F_{256}$ ($z,s\in\{0,\dotsc,3\}$) der Eingabe $S_{i,b} =
(b^{(z,s)})_{4\times4}$ werden zwei Transformationen ausgeführt:
\begin{enumerate}
 \item Bestimme das multiplikative Inverse $(b^{(z,s)})^{-1} = \tilde{b}^{(z,s)}
  \tilde{b}_{7}\tilde{b}_{6}\dotso\tilde{b}_{0}$ zu $b^{(z,s)}$ in $\F_{256}$.
  Falls $b^{(z,s)}= 00$, dann ist $\tilde{b}^{(z,s)} = 00$.

 \item Die Elementen des Körpers $F_{256}$ können auch als Elemente des
  Polynomrings $\nicefrac{\F_{2}[x]}{x^{8}+1}$ verstanden werden, d.\,h.
  \help{ist $\nicefrac{\F_{2}[x]}{x^{8}+1}$ isomorph zu $F_{256}$?}
  $\tilde{b}^{(z,s)}\in\nicefrac{\F_{2}[x]}{x^{8}+1}$. Darauf wendet man folgende
  Abbildung an:
  \begin{gather*}
    c^{(z,s)} = [1,1,1,1,0,0,0,1] \otimes \tilde{b}^{(z,s)} + [0,1,1,0,0,0,1,1]
  \end{gather*}
  Analog zu den Rechenregeln, wie sie im \autoref{sec:f256x} hergeleitet
  wurden, ergibt sich folgende affine Abbildung mit dem Ergebnis $c^{(z,s)} =
  c_{7}c_{6}\dotso c_{0}$
  \begin{gather*}
    \begin{pmatrix}
      c_{0}\\ c_{1}\\ c_{2}\\ c_{3}\\ c_{4}\\ c_{5}\\ c_{6}\\ c_{7}
    \end{pmatrix} =
       \begin{pmatrix}
         1& 0& 0& 0& 1& 1& 1& 1\\
         1& 1& 0& 0& 0& 1& 1& 1\\
         1& 1& 1& 0& 0& 0& 1& 1\\
         1& 1& 1& 1& 0& 0& 0& 1\\
         1& 1& 1& 1& 1& 0& 0& 0\\
         0& 1& 1& 1& 1& 1& 0& 0\\
         0& 0& 1& 1& 1& 1& 1& 0\\
         0& 0& 0& 1& 1& 1& 1& 1
       \end{pmatrix} \cdot
       \begin{pmatrix}
         \tilde{b}_{0}\\
         \tilde{b}_{1}\\
         \tilde{b}_{2}\\
         \tilde{b}_{3}\\
         \tilde{b}_{4}\\
         \tilde{b}_{5}\\
         \tilde{b}_{6}\\
         \tilde{b}_{7}
       \end{pmatrix} +
       \begin{pmatrix}
         1\\ 1\\ 0\\ 0\\ 0\\ 1\\ 1\\ 0
       \end{pmatrix}
  \end{gather*}
\end{enumerate}

Die praktische Umsetzung der Byte-Sub-Transformation erfolgt durch eine
\highl{lookup-table}, d.\,h. man berechnet einmal für alle möglichen Eingaben
die Ergebnisse und speichert sie in einer Tabelle im Programm ab. Das Programm
schlägt dann nur noch in der Tabelle das Ergebnis nach und berechnet nichts
mehr.

\begin{table}
  \centering
  \begin{ttfamily}
    \begin{tabular}{c|*{16}{c}}
      $S_{8}$& 0& 1& 2& 3& 4& 5& 6& 7& 8& 9& A& B& C& D& E& F\\
      \hline
      00& 63& 7C& 77& 7B& F2& 6B& 6F& C5& 30& 01& 67& 2B& FE& D7& AB& 76\\
      10& CA& 82& C9& 7D& FA& 59& 47& F0& AD& D4& A2& AF& 9C& A4& 72& C0\\
      20& B7& FD& 93& 26& 36& 3F& F7& CC& 34& A5& E5& F1& 71& D8& 31& 15\\
      30& 04& C7& 23& C3& 18& 96& 05& 9A& 07& 12& 80& E2& EB& 27& B2& 75\\
      40& 09& 83& 2C& 1A& 1B& 6E& 5A& A0& 52& 3B& D6& B3& 29& E3& 2F& 84\\
      50& 53& D1& 00& ED& 20& FC& B1& 5B& 6A& CB& BE& 39& 4A& 4C& 58& CF\\
      60& D0& EF& AA& FB& 43& 4D& 33& 85& 45& F9& 02& 7F& 50& 3C& 9F& A8\\
      70& 51& A3& 40& 8F& 92& 9D& 38& F5& BC& B6& DA& 21& 10& FF& F3& D2\\
      80& CD& 0C& 13& EC& 5F& 97& 44& 17& C4& A7& 7E& 3D& 64& 5D& 19& 73\\
      90& 60& 81& 4F& DC& 22& 2A& 90& 88& 46& EE& B8& 14& DE& 5E& 0B& DB\\
      A0& E0& 32& 3A& 0A& 49& 06& 24& 5C& C2& D3& AC& 62& 91& 95& E4& 79\\
      B0& E7& C8& 37& 6D& 8D& D5& 4E& A9& 6C& 56& F4& EA& 65& 7A& AE& 08\\
      C0& BA& 78& 25& 2E& 1C& A6& B4& C6& E8& DD& 74& 1F& 4B& BD& 8B& 8A\\
      D0& 70& 3E& B5& 66& 48& 03& F6& 0E& 61& 35& 57& B9& 86& C1& 1D& 9E\\
      E0& E1& F8& 98& 11& 69& D9& 8E& 94& 9B& 1E& 87& E9& CE& 55& 28& DF\\
      F0& 8C& A1& 89& 0D& BF& E6& 42& 68& 41& 99& 2D& 0F& B0& 54& BB& 16
    \end{tabular}
  \end{ttfamily}
  \caption{Die Substitutionsbox $S_{8}$ für den Byte-Sub-Schritt im AES;
    Quelle: \href{http://en.wikipedia.org/wiki/Rijndael_S-box}{englische
  Wikipedia}}
  \label{tab:s8-aes}
\end{table}

Die Tabelle ist die $S$-Box\footnote{da sie je 8~Bit verarbeitet, wird
sie mit $S_{8}$ bezeichnet}, die z.\,B. zweidimensional mit 16~Zeilen und
16~Spalten dargestellt werden kann. Die niederwertigen Bits $b_{3}, b_{2},
b_{1}$ und $b_{0}$ der Eingabe bestimmen die Spalte in der Tabelle und die
Bits $b_{7}, b_{6}, b_{5}$ und $b_{4}$ die Zeile. \autoref{tab:s8-aes}

Beispiel: $S_{8}(1011\,0101)$, Zeile~11 und Spalte~5. \autoref{tab:s8-aes}
liefert $D5$. $S_{8}(1011\,0101) = (1101\,0101)$.

Zusammengefasst gesprochen, wird im Byte-Sub-Schritt mit einer Abbildung, der
$S$-Box, für jedes Byte (jeden 8-Bit-Block) der Eingabe ein Byte bestimmt,
dass dem inversen Element des Eingabebytes entspricht, wenn man beide als
Elemente des Körpers $\F_{258}$ auffasst.
\begin{gather*}
  c^{(z,s)} = S_{8}(b^{(z,s)})
\end{gather*}

\subsubsection{Row-Shift}
Rechnen in $\nicefrac{\F_{256}[x]}{x^{4}+1}$ zeilenweise:
\begin{align*}
  [d^{(0,0)}, d^{(0,1)}, d^{(0,2)}, d^{(0,3)}]
     &= [c^{(0,0)}, c^{(0,1)}, c^{(0,2)}, c^{(0,3)}] \otimes 01x^{4}\\
  [d^{(1,0)}, d^{(1,1)}, d^{(1,2)}, d^{(1,3)}]
     &= [c^{(1,0)}, c^{(1,1)}, c^{(1,2)}, c^{(1,3)}] \otimes 01x^{3}\\
  [d^{(2,0)}, d^{(2,1)}, d^{(2,2)}, d^{(2,3)}]
     &= [c^{(2,0)}, c^{(2,1)}, c^{(2,2)}, c^{(2,3)}] \otimes 01x^{2}\\
  [d^{(3,0)}, d^{(3,1)}, d^{(3,2)}, d^{(3,3)}]
     &= [c^{(3,0)}, c^{(3,1)}, c^{(3,2)}, c^{(3,3)}] \otimes 01x
\end{align*}

Praktisch bedeutet das, dass die Elemente in der $k$.\,Eingabezeile um $k$
Plätze nach links rotiert werden.
\begin{gather*}
  \begin{pmatrix}
    d^{(0,0)}& d^{(0,1)}& d^{(0,2)}& d^{(0,3)}\\
    d^{(1,0)}& d^{(1,1)}& d^{(1,2)}& d^{(1,3)}\\
    d^{(2,0)}& d^{(2,1)}& d^{(2,2)}& d^{(2,3)}\\
    d^{(3,0)}& d^{(3,1)}& d^{(3,2)}& d^{(3,3)}
  \end{pmatrix} =
     \begin{pmatrix}
       c^{(0,0)}& c^{(0,1)}& c^{(0,2)}& c^{(0,3)}\\
       c^{(1,1)}& c^{(1,2)}& c^{(1,3)}& c^{(1,0)}\\
       c^{(2,2)}& c^{(2,3)}& c^{(2,0)}& c^{(2,1)}\\
       c^{(3,3)}& c^{(3,0)}& c^{(3,1)}& c^{(3,2)}
     \end{pmatrix}
\end{gather*}

\subsubsection{Column-Mix}
Auf die Eingabe $S_{i,d}$ wird spaltenweise die
Abbildung~$S_{32}$\footnote{$S_{32}$, weil die Abbildung 32~Bit verarbeitet}
angewendet.
\begin{gather*}
  \begin{pmatrix}
    e^{(0,s)} \\ e^{(1,s)}\\ e^{(2,s)}\\ e^{(3,s)}
  \end{pmatrix} = S_{32}(
     \begin{pmatrix}
       d^{(0,s)} \\ d^{(1,s)}\\ d^{(2,s)}\\ d^{(3,s)}
     \end{pmatrix}
     )
\end{gather*}
Diese entspricht folgender Berechnung im $\nicefrac{\F_{256}[x]}{x^{4}+1}$:
\begin{gather*}
  [e^{(0,s)}, e^{(1,s)}, e^{(2,s)}, e^{(3,s)}] =
      [03, 01, 01, 02] \otimes [d^{(0,s)}, d^{(1,s)}, d^{(2,s)}, d^{(3,s)}]
\end{gather*}
Die Matrixschreibweise für die Operation $\otimes$ (\autoref{sec:f256x}) ergibt
\begin{align}
  \notag
  \begin{pmatrix}
    e^{(0,s)}\\ e^{(1,s)}\\ e^{(2,s)}\\ e^{(3,s)}
  \end{pmatrix} &=
     \begin{pmatrix}
       02& 03& 01& 01\\
       01& 02& 03& 01\\
       01& 01& 02& 03\\
       03& 01& 01& 02
     \end{pmatrix} \cdot
     \begin{pmatrix}
       d^{(0,s)}\\ d^{(1,s)}\\ d^{(2,s)}\\ d^{(3,s)}
     \end{pmatrix}\\
  \label{eq:aes-s32}
  &= \begin{pmatrix}
       02\odot (d^{(0,s)}\oplus d^{(1,s)}) \oplus d^{(1,s)} \oplus
       d^{(2,s)} \oplus d^{(3,s)}\\
       02\odot (d^{(1,s)} \oplus d^{(2,s)}) \oplus d^{(0,s)} \oplus
       d^{(2,s)} \oplus d^{(3,s)}\\
       02\odot (d^{(2,s)} \oplus d^{(3,s)}) \oplus d^{(0,s)} \oplus
       d^{(1,s)} \oplus d^{(3,s)}\\
       02\odot (d^{(3,s)} \oplus d^{(0,s)}) \oplus d^{(0,s)} \oplus
       d^{(1,s)} \oplus d^{(2,s)}
     \end{pmatrix}
\end{align}

Die praktische Umsetzung in mit einer lookup-table ist nicht möglich, da für
die $2^{32}$ möglichen Eingabewerte je 32~Bit Speicherplatz benötigt werden,
was 127\,Gigabit entspricht, was sich praktisch nur schwer umsetzen lässt.

\begin{figure}
  \centering
  \input{aes-s32.pdf_t}
  \caption{Schematische Darstellung der $S$-Box $S_{32}$ für den Column-Mix im
    AES}
  \label{fig:s32}
\end{figure}

\begin{gather}
  \label{eq:xtime}
  \mathit{xtime}(p_{7}p_{6}\dotso p_{0}) =
     \begin{cases}
       \pi_{6}\pi_{5}\pi_{4}\pi_{3}\:\pi_{2}\pi_{1}\pi_{0} 0&\colon \pi_{7}=0\\
       (\pi_{6}\pi_{5}\pi_{4}\pi_{3}\:\pi_{2}\pi_{1}\pi_{0} 0) \oplus (0001\,1011)&
       \colon \pi_{7} = 1
     \end{cases}
\end{gather}

Aber durch eine geschickte Umordnung der Operanten, wie es in
\autoref{eq:aes-s32} geschehen ist, kann man eine sehr symmetrische Struktur
\autoref{fig:s32} erreichen. Die Funktion $xtime\colon\F_{256}\rightarrow
\F_{256}$ (\autoref{eq:xtime}) berechnet dabei für ein $p\in\F_{256}$ das
Produkt
\begin{align*}
  02\odot p &= x \odot p(x)
     = x \cdot (\pi_{7}x^{7}+\dotsb+ \pi_{1}x + \pi_{0}) \pmod{m(x)}\\
     &= \pi_{7} x^{8} + \pi_{6}x^{7} + \dotsb+ \pi_{1}x^{2} + \pi_{0}x
     \pmod{x^{8}+x^{4}+x^{3}+x^{1}+1}
\end{align*}
Die Polynomdivision ergibt (nach einem Schritt) das Restpolynom
\begin{multline*}
  \pi_{6}x^{7} + \pi_{5} x^{6} + \pi_{4}x^{5} + (\pi_{3}\oplus \pi_{7})x^{4}
     + (\pi_{2}\oplus \pi_{7})x^{3} + \pi_{1}x^{2} + (\pi_{0}\oplus\pi_{7})x
     + \pi_{7}\\
  = [\pi_{6}, \pi_{5}, \pi_{4}, (\pi_{3}\oplus\pi_{7}),
     (\pi_{2}\oplus\pi_{7}), \pi_{1}, (\pi_{0}\oplus\pi_{7}), \pi_{7}]
\end{multline*}

\subsection{Struktur des Entschlüsselungsalgorithmus}

Da jeder Verschlüsselungsschritt einen Umkehrschritt besitzt ist die
Entschlüsselung der Nachricht gesichert:
\begin{enumerate}
 \item Key-Add$^{-1} = $Key-Add ist einfach ein \texttt{xor}
  mit demselben Schlüssel.

 \item Byte-Sub$^{-1}$ existiert, da die affine Abbildung eine
  Umgekehrabbildung besitzt und das Inverse des Inversen das ursprüngliche
  Element im Körper liefert.

 \item Row-Shift$^{-1}$ ist einfach eine Rotation nach rechts.

 \item Column-Shift$^{-1}$ existiert, da $a(x) = 02+01x+ 01x^{2} +
  03x^{3}$ im Ring $\nicefrac{\F_{256}[x]}{x^{4}+1}$ das inverse Polynom
  $a^{-1}(x)$ hat.
\end{enumerate}

% 8.1.2007

\chapter{Public-Key Kryptosysteme}

\textit{klassisch:} symmetrische Verfahren, d.\,h. Sender und Empfänger
verfügen über zueinander passende Schlüssel (quasi-gleiche Schlüssel), die
beide geheim gehalten werden müssen.

\textit{neu:} asymmetrische Verfahren, d.\,h. es gibt ein Paar von Schlüsseln
für den Empfänger. Der Schlüssel zum Verschlüsseln ist öffentlich, deshalb
kennt ihn auch der Sender. Der Schlüssel zum Entschlüsseln ist geheim,
privater Schlüssel für den Empfänger.

Entscheidend dabei ist, dass die Kenntnis des öffentlichen Schlüssels keine
Rückschlüsse auf den privaten Schlüssel erlaubt.

\section{Das Problem des Tauschens geheimer Schlüssel}

Alice (Sender) und Bob (Empfänger) kommunizieren über einen unsicheren Kanal
und wollen daher ihre Nachrichten verschlüsseln. Dabei stehen sie vor dem
Problem, dass sie ein Paar geheim zuhaltender Schlüssel über diesen Kanal
austauschen müssen. (\textit{engl. secret key agreement problem})

1976 stellten Diffie und Hellmann in "`New directions in
cryptography"'\cite{diffihellman} ein Verfahren für dieses augenscheinlich
unlösbare Problem vor.

\subsection{Das Protokoll von Diffie und Hellmann}

\begin{table}
  \centering
  \begin{tabularx}{.85\linewidth}{*{2}{|c|>{\raggedright\arraybackslash}X}|}
    \hline
    Schritt& \multicolumn{1}{c|}{Alice}& Kanal& \multicolumn{1}{c|}{Bob}\\
    \hline
    1.& \multicolumn{3}{c|}{\parbox{.6\linewidth}{beide einigen sich
       auf eine große Primzahl~$p$ und eine primitive Wurzel~$g$; $g$ und $p$
       sind öffentlich}}\\
    2.& wählt zufällig eine große Zahl~$a$, berechnet
       $\alpha=g^{a}\pmod{p}$; $a$ ist privat && wählt zufällig
       eine große Zahl~$b$,  berechnet $\beta=g^{b}\pmod{p}$; $b$ ist privat\\
    3.& & $\xleftarrow{\beta} \xrightarrow{\alpha}$ &\\
    4.& $K_{A}=\beta^{a}\pmod{p}$& & $K_{B}=\alpha^{b}\pmod{p}$\\
    \hline
  \end{tabularx}
  \caption{Austausch eines geheimen Schlüssels in der Öffentlichkeit nach
    Diffie und Hellmann}
\end{table}

Alice und Bob verabreden eine große Primzahl~$p$ und eine primitive
Wurzel~$g$, die beide öffentlich bekannt seien können. Danach wählt jeder für
sich eine zufällige, große Zahl~$a$ bzw. $b$ und berechnet
$\alpha=g^{a}\pmod{p}$~(Alice) bzw. $\beta=g^{b}\pmod{p}$~(Bob). Diese beiden
Ergebnisse tauschen dann beide wieder aus, wobei die Zahlen öffentlich
zugänglich seien können. Jeder berechnet dann für sich das gemeinsame
Geheimnis~$K$ durch $K_{A}=\beta^{a}\pmod{p}$~(Alice) bzw.
$K_{B}=\alpha^{b}\pmod{p}$~(Bob).
\begin{gather*}
  K_{A} \equiv \beta^{a}\pmod{p} \equiv (g^{b})^{a}\pmod{p}\equiv
     (g^{a})^{b}\pmod{p} = \alpha^{b}\pmod{p} = K_{B}
\end{gather*}

\subsection{Das Protokoll von Rivest und Sherman}

\begin{table}
  \centering
  \begin{tabularx}{.85\linewidth}{*{2}{|c|>{\raggedright\arraybackslash}X}|}
    \hline
    Schritt& \multicolumn{1}{c|}{Alice}& Kanal& \multicolumn{1}{c|}{Bob}\\
    \hline
    1.& wählt zufällig 2 große Zahlen~$x,y$, berechnet $x\circ y$; $x$ privat,
       $y,x\circ y$ öffentlich
       &&\\
    2.& & $\xrightarrow{y,x\circ y}$& \\
    3.& & & wählt zufällig eine große Zahl~$z$, berechnet $y\circ z$; $z$
       privat, $y\circ z$ öffentlich\\
    4.& & $\xleftarrow{y\circ z}$& \\
    5.& berechnet $K_{A}=x\circ(y\circ z)$& & berechnet $K_{B}=(x\circ y)\circ z$
  \end{tabularx}
  \caption{Austausch eines geheimen Schlüssels in der Öffentlichkeit nach
    Rivest und Shermann}
\end{table}

Alice wählt zufällig zwei große Zahlen~$x$ und $y$ und berechnet $x\circ y$,
wobei $\circ$ eine zweistellige und assoziative Operation ist, die stark "`nicht
invertierbar"' ist, d.\,h. die Kenntnis von $x\circ y$ und $y$ erlaubt keine
Rückschlüsse auf~$x$. Die Zahl~$x$ bleibt privat und die Zahlen~$y$ und
$x\circ y$ übermittelt sie an Bob, wobei die Zahlen öffentlich zugänglich seien
können. Bob wählt sich dann zufällig eine große Zahl~$z$, die privat bleibt,
und berechnet $y\circ z$. Dieses Ergebnis teilt er Alice mit und auch hier kommt
es nicht auf die Geheimhaltung an. Somit haben beide jetzt das gemeinsame
Geheimnis $x\circ y\circ z$
\begin{gather*}
  K_{A} = x\circ(y\circ z) = (x\circ y)\circ z = K_{B}
\end{gather*}

\help{Ist bei beiden Verfahren wirklich sichergestellt, dass man aus den
  öffentlichen Größen keine Rückschlüsse auf das Geheimnis ziehen kann?}

\section{Das Konzept der Einwegfunktion}
\label{sec:rsa-math}

Die Frage ist nun, ob es denn überhaupt eine solche Operation~$\circ$ gibt und
wenn ja, wie sieht diese aus? In der Komplexitätstheorie gibt es das Konzept
der Einwegfunktion, das Funktionen beschreibt, die einfach zu berechnen, aber
"`schwer"' zu invertieren sind.

\begin{defini}
  Eine Funktion $f\colon\N\rightarrow\N$ ist eine \highl{Einwegfunktion}
  \gdwdef sie die folgenden Eigenschaften besitzt
  \begin{itemize}
   \item $f$ ist im worst case in Polynomialzeit zu berechnen, d.\,h.
    $f\in\FP$ und 
   \item für fast alle $y\in W_{f}$ gibt es keinen probalistischen
    Algorithmus, der im average case ein zugehöriges Urbild~$x$ mit $f(x)=y$
    in Polynomialzeit berechnet, d.\,h. $f^{-1}\notin\FP$.
  \end{itemize}
\end{defini}

\begin{bemerk}
  \label{bem:1}
  Aus der Komplexitätstheorie ist bekannt, dass eine solche Einwegfunktion nur
  dann existiert, wenn $\mathrm{P}\ne \mathrm{NP}$ ist.
\end{bemerk}

% 10.1.

\subsection{Modulare Exponentiation mit fester Basis und festem Modul}
\label{sec:diskrlog}
Im Folgenden sei $f_{a,n}\colon\Z_{n}\mapsto\Z_{n}$ wie folgt definiert:
\begin{gather*}
  f_{a,n}(m) := a^{m} \mod n
\end{gather*}

\begin{satz}\label{satz:1}
  Die Zahlenfunktion $f_{a,n}$ (wie sie oben definiert ist) gehört zur
  Klasse~$\FP$ der in Polynomialzeit berechenbaren Funktionen.

  \begin{proof}
    Folgende rekursive Prozedur berechnet $f_{a,n}(m)$:
    \begin{Verbatim}[gobble=4]
    function (a,m,n)
    begin
        if m = 0
        then return 1
        else
        begin
            if m gerade
            then return (function(a, m/2, n) ** 2) mod n
            else return (function(a, m-1, n) * a) mod n
        end
    end
    \end{Verbatim}

    Da in mindestens jedem zweiten Schritt der Exponent~$m$ halbiert wird,
    erfordert dieser Algorithmus zwischen $\log_{2}m$ und $2\cdot\log_{2}m$
    Durchläufe und hat somit eine Laufzeit von $O(\log_{2}m) = O(\abs{m})$. Da
    ist einzelnen Operationen mit $O(1)$ angenommen werden, ist dies ein
    Polynomialzeitalgorithmus.
  \end{proof}
\end{satz}

\begin{defini}
  Als \highl{diskreten Logarithmus} bezeichnet man die inverse
  Abbildung~$f^{-1}_{a,n}$, die zu einem gegebenen Wert~$y$ einen Wert~$m$
  bestimmt, so dass $a^{m}\mod n = y$, falls ein solches $m$ existiert.
\end{defini}

Diese Abbildung~$f^{-1}_{a,n}$ ist jedoch \textit{keine} Funktion, da
$f_{a,n}$ nicht injektiv ist. Zum Beispiel ist das Ergebnis von $f_{5,21}$ für
$m_{1}=4$ und $m_{2}=10$ gleich.
\begin{gather*}
  f_{5,21}(5) = 5^{4}\mod{21} = 16 = 5^{10}\mod{21} = f_{5,21}(10)
\end{gather*}

\begin{dogma}
  Wir glauben, dass die Funktion~$f_{a,n}$ nicht $\FP$-invertierbar und damit
  ein Kandidat für eine Einwegfunktion ist.
\end{dogma}

Könnten wir beweisen, dass $f_{a,n}$ nicht $\FP$-invertierbar ist, dann wäre
damit eine echte Einwegfunktion gefunden und man könnte nach \autoref{bem:1}
zeigen, dass $\mathrm{P}\ne\mathrm{NP}$ ist.

\begin{bemerk}
  Wenn $f$ eine Einwegfunktion ist, dann kann auch der \textit{legitimierte}
  Empfänger aus dem Kryptogramm $c=f(m)$ die Botschaft $m$ nicht in
  Polynomialzeit zurückrechnen.
\end{bemerk}

\subsection{Falltür-Einwegfunktionen}

\begin{defini}
  Eine Zahlenfunktion~$f\colon X\rightarrow Y$ heißt
  \highl{Falltür-Einwegfunktion} (engl. trap door one way function) \gdwdef
  sie die folgenden Bedingungen erfüllt:
  \begin{itemize}
   \item Die Funktion ist in Polynomialzeit berechenbar; $f\in\FP$
   \item $f$ ist mit der \highl{Falltürinformation} in Polynomialzeit
    umkehrbar;
    \begin{gather*}
      \exists g\in\FP~\exists \text{\:Falltürinformation\:}T~
         \forall y\in W_{f}\colon f\bigl(g(y,T)\bigr) = y
    \end{gather*}
   \item $f$ ist ohne die Falltürinformation nicht in Polynomialzeit
    umkehrbar; $f$ ist nicht $\FP$-invertierbar
  \end{itemize}

  Diese Definition geht auf Deffie und Helman zurück.
\end{defini}

\begin{bemerk}
  Eine solche Falltür-Einwegfunktion ist keine Einwegfunktion, denn es gibt
  einen Polynomialzeitalgorithmus, der die $\FP$-Invertierung ermöglicht.
\end{bemerk}

\subsection{Modulare Exponentation mit festem Exponenten und festem Modul}

Analog zur Definition von $f_{a,n}$ im \autoref{sec:diskrlog} sei im Folgenden
$g_{n,m}\colon \Z_{n} \mapsto \Z_{n}$ so definiert
\begin{gather*}
  g_{n,m}(a) := a^{m} \mod n
\end{gather*}

\begin{satz}
  Die oben definierte Funktion $g_{n,m}$ ist in Polynomialzeit berechenbar,
  d.\,h. $g_{n,m}\in\FP$.

  \begin{proof}
    Der rekursive Algorithmus aus dem Beweis von \autoref{satz:1} kann
    ebenfalls zur Berechnung der Funktion~$g_{n,m}$ verwendet werden.
  \end{proof}
\end{satz}

\begin{defini}
  Die inverse Abbildung $g_{n,m}^{-1}\colon\Z_{n} \rightarrow \Z_{n}$
  bezeichnet man als \highl{$m$.\, Wurzel}. $g^{-1}_{n,m}$ berechnet für
  ein gegebenes $y$, das $a$, so dass $a^{m}\mod n = y$ gilt, falls ein
  solches $a$ existiert.
\end{defini}

Hier gibt es das gleiche Problem wie beim diskreten Logarithmus, dass
$g_{n,m}$ nicht eindeutig ist, d.\,h. die $m$.\,Wurzel ist keine Funktion.
Beispielsweise ist die 4.\,Wurzel von 16 für $n=21$ gleich
\begin{gather*}
  g_{21,4}(5) = 5^{4}\mod{21} = 16 = 2^{4}\mod 21 = g_{21,4}(2)
\end{gather*}

Doch im Gegensatz zu $f_{a,n}$ lässt sich $g_{n,m}$ in Polynomialzeit
invertieren, wenn die Faktorisierung von $n$ als Falltürinformation zur
Verfügung steht. Dazu ein Exkurs in die Zahlentheorie.

\subsubsection{Exkurs in die Zahlentheorie}

Ansatzpunk:
\begin{gather*}
  \Z_{n}^{*} := \{ i\colon 1\leq i < n, \ggT(i,n)=1\}
\end{gather*}
ist eine multiplikative Gruppe der Ordnung $\phi(n)$.
\help{Ist das gleich der Menge der Einheiten in 4.10.1?}

\begin{satz}
  Von Euler stammt die folgende Erkenntnis: Es gilt für alle $x$ mit $1\leq x
  < n$ und $\ggT(x,n) = 1$ folgende Kongruenz:
  \begin{gather*}
    x^{\phi(n)} \equiv 1\pmod{n}
  \end{gather*}
  oder mit anders ausgedrückt: ein beliebiges Element einer Gruppe hoch der
  Ordnung der Gruppe ergibt das Einselement der Gruppe.

  Ein Spezialfall davon ist der kleine Satz von Fermat: Für alle Primzahlen~$p$ und alle
  $x$ mit $1\leq x < p$ gilt:
  \begin{gather*}
    x^{p-1} \equiv 1\pmod{p}
  \end{gather*}
\end{satz}

\begin{defini}
  Eine Zahl~$a$ ($1\leq a< n$) heißt \highl{primitive Wurzel} von $n$ \gdwdef
  $a$ die folgenden Eigenschaften erfüllt
  \begin{itemize}
   \item $a$ und $n$ sind Teilerfremd ($\ggT(a,n)=1$) und
   \item der kleineste Exponent~$d$, der $a^{d}\equiv1\pmod{n}$ erfüllt, ist
    $\phi(n)$ --~$d$ heißt \highl{Ordnung} von $a$~-- oder anders formuliert:
    für alle $d<\phi(n)$ gilt $a^{d}\not\equiv 1\pmod{n}$
  \end{itemize}
\end{defini}

\begin{bsp}
  Für $n=5$ kommen als primitive Wurzeln die Zahlen $\Z_{5}^{*} = \{1,2,3,4\}$
  in Frage. Davon entfallen 1 (aus offensichtlichen Gründen) und 4, da $4^{2}
  \equiv 1\pmod{5}$. Es bleiben also 2 und 3 als primitive Wurzeln von 5.

  Für $n=11$ gibt es die Kandidaten $\Z_{11}^{*} = \{ 1,2,\dotsc,10\}$, von
  denen nur 2, 6, 7 und 8 primitive Wurzeln sind.

  Für $n=6$ sind $\Z_{6}^{*}=\{1,5\}$ mögliche primitive Wurzeln, von denen
  nur 5 die Bedingung $5^{d}\not\equiv1\pmod{6}$ für alle $d=1<\phi(6)=
  \phi(3\cdot2) = 1\cdot2$ erfüllt.

  \begin{gather*}
    \begin{array}[t]{*{4}{c}}
      a& a^{2}& a^{3}& a^{4}\\
      \hline
      2& 4& 3& 1\\
      3& 4& 2& 1\\
      4& 1& 4& 1
    \end{array} \quad
       \begin{array}[t]{*{10}{c}}
         a& a^{2}& a^{3}& a^{4}& a^{5}& a^{6}& a^{7}& a^{8}& a^{9}& a^{10}\\
         \hline
         2& 4& 8& 5& 10& 9& 7& 3& 6& 1\\
         3& 9& 5& 4& 1& 3& 9& 5& 4& 1\\
         4& 5& 9& 3& 1& 4& 5& 9& 3& 1\\
         5& 3& 4& 9& 1& 5& 3& 4& 9& 1\\
         6& 3& 7& 9& 10& 5& 8& 4& 2& 1\\
         7& 5& 2& 3& 10& 4& 6& 9& 8& 1\\
         8& 9& 6& 4& 10& 3& 2& 5& 7& 1\\
         9& 4& 3& 5& 1& 9& 4& 3& 5& 1\\
         10& 1& 10& 1& 10& 1& 10& 1& 10& 1
       \end{array}
  \end{gather*}
\end{bsp}

\begin{satz}
  Carl Friedrich Gauss hat gezeigt, dass
  \begin{itemize}
   \item $n$ besitzt primitive Wurzeln \gdw $n$ ist $1, 2$ oder $4$ oder $n$
    ist einfache oder doppelte Potenz einer Primzahl~$p>2$ ($n = p^{k}$
    oder $n=2\cdot p^{k}$).

   \item Falls $n$ primitve Wurzeln besitzt, dann sind es $\phi(\phi(n))$ Stück.
  \end{itemize}
\end{satz}

\begin{bemerk}
  \begin{itemize}
   \item 8 und 12 sind die kleinsten Zahlen, die keine primitven Wurzeln haben
   \item $n=5$ hat $\phi(\phi(5)) =\phi(4) = 2$ primitve Wurzeln.
  \end{itemize}
\end{bemerk}

\begin{lemma}
  Damit lässt sich der \highl{diskrete Logarithmus} $f_{a,n}^{-1}$ exakt als
  Funktion definieren, falls $a$ eine primitive Wurzel von $n$ ist.
  \begin{gather*}
    f_{a,n}^{-1}(y) := \log_{a} y \mod n
  \end{gather*}
  Dabei ist der Wert $\log_{a}x$ eindeutig als diejenige Zahl~$m$ bestimmt, für
  die $a^{m} \mod n = y$ gilt.
\end{lemma}

% 15.1.

\begin{lemma}\label{lem:1}
  Der \highl{erweiterte euklidische Algorithmus} lässt sich in Polynomialzeit
  berechnen; $\ggT\in\FP$.

  \begin{proof}
    Der Satz von Lemé (1985) zeigt, dass die Anzahl der Schleifendurchläufe
    für zwei aufeinander folgende Fibonacci-Zahlen $f_{k-1}$ und $f_{k}$ am
    Größten ist. Dann werden höchstens
    \begin{gather*}
      \floor{\log_{\frac{1}{2}(1+\sqrt{5})} (\sqrt{5}N) }-2
    \end{gather*}
    Schleifendurchläufe benötigt, wobei $N > f_{k}$ ist.
  \end{proof}
\end{lemma}

\begin{lemma}\label{lem:4}
  Seien $x,u>0$. Für alle Primzahlen~$p$ und $q$, die voneinander verschieden
  sind, gilt:
  \begin{gather*}
    x^{u}\equiv x\mod p\quad\text{und}\quad x^{u}\equiv x\mod q \Rightarrow
       x^{u}\equiv x\mod (p\cdot q)
  \end{gather*}

  \begin{proof}
    $x^{u}\equiv x\mod p$ bedeutet $x^{u}-x$ ist durch $p$ teilbar und
    entsprechend $x^{u}-x$ ist durch $q$ teilbar. Da $p$ und $q$ teilerfremd
    sind, ist $x^{u}-x$ durch $p\cdot q$ teilbar.
  \end{proof}
\end{lemma}

\begin{satz}
  \label{satz:2}
  Es gibt einen Polynomialzeitalgorithmus, der bei Eingabe von drei
  natürlichen Zahlen~$n$, $m$ und $y$, wobei $\ggT(m,\phi(n)) = 1$ und $n$ das
  Produkt von zwei bekannten Primzahlen~$p$ und $q$ ist, eine Zahl $a$ mit der
  Eigenschaft $g_{n,m}(a) = a^{m}\mod n = y$ bestimmt. Die Eigenschaft
  $n=p\cdot q$ ist die \highl{Falltürinformation}.

  \begin{proof}
    Der Algorithmus besteht aus zwei Teilschritten:
    \begin{enumerate}
     \item Da $m$ und $\phi(n)$ teilerfremd zueinander sind, bestimmt der
      erweiterte euklidische Algorithmus in Polynomialzeit (\autoref{lem:1})
      zwei Zahlen~$u$ und $v$ (\autoref{lem:6}), so dass $1 = \ggT(\phi(n),m)
      = u\cdot\phi(n) + v\cdot m$.

     \item Damit lässt sich $a$ nach \autoref{satz:1} in Polynomialzeit als
      $a:= f_{y,n}(v) = y^{v}\pmod{n}$ bestimmen.
    \end{enumerate}

    Die Behauptung ist nun, dass $y\equiv a^{m}\pmod{n}$ gilt. Dazu machen wir
    die Annahme, dass $y\equiv x^{m}\pmod{n}$ für irgendein $x$ ist und zeigen
    $x=a$.
    \help{Wieso kann man annehmen, dass $y$ so aussieht?}

    Aus der Annahme $y\equiv x^{m}\pmod{n}$ folgt $y=x^{m}-s\cdot n$ (für geeignetes
    $s$) und mit $a\equiv y^{v}\pmod{n}$ ergibt sich
    \begin{align*}
      a &\equiv (x^{m}-sn)^{v} \pmod{n}\\
      \intertext{Mithilfe des binomischen Satz' lässt sich das Dingsbums
        umschreiben zu}
      \intertext{\help{Wie heißt das doch gleich, das kleine, schwarze, das Dings?}}
      &\equiv \sum_{k=0}^{v} \binom{v}{k} (x^{m})^{v-k} (-sn)^{k} \pmod{n}\\
      &\equiv x^{m\cdot v} + \sum_{k=1}^{v} \binom{v}{k} x^{m(v-k)} (-s)^{k}
         n^{k} \pmod{n}\\
      \intertext{Da innerhalb des Summenzeichens Vielfache von $n$ auftreten,
        entfällt dieser Teil}
      &\equiv x^{m\cdot v}\pmod{n}\\
      \intertext{Da $u$ und $v$ so bestimmt sind, dass $u\cdot\phi(n)+v\cdot
        m=1$ gilt, ergibt sich}
      &\equiv x^{u\cdot\phi(n)+1}\pmod{n}
    \end{align*}
    \help{Wieso können wir einfach aus $1-u\cdot\phi(n)$ das + machen?}

    \help{Wieso braucht man hier eine Fallunterscheidung?}
    \begin{enumerate}[1.\,{Fall}]
     \item Für $x\equiv0\pmod{p}$ gilt die Kongruenz trivialer Weise.

     \item Ist $x\not\equiv0\pmod{p}$, dann gilt nach \autoref{satz:2}
      $x^{p-1}\equiv 1\pmod{p}$ (Kleiner Fermat), d.\,h. es gilt
      $x^{p-1} = r\cdot p+1$ für ein passendes $r$. Also gilt für die
      Kongruenz:
      \begin{align*}
        a&= x^{u\cdot\phi(n)+1} = x^{u\cdot(p-1)\cdot(q-1)}\cdot x =
           (x^{p-1})^{u\cdot(q-1)}\cdot x
        \equiv 1^{t\cdot(q-1)}\cdot x\equiv x\mod p
      \end{align*}
    \end{enumerate}
    Für alle $x$ ist also $a\equiv x\pmod{p}$.

    Genauso kann man $a\equiv x\pmod{q}$ zeigen. Nach \autoref{lem:4} gilt
    also $a\equiv x\pmod{n}$.
  \end{proof}
\end{satz}

\begin{dogma}
  Wir glauben, dass die \highl{Faktorisierung} (Zerlegung in Primfaktoren)
  einer Zahl nicht in Polynomialzeit berechenbar ist. Die Falltürinformation
  $p\cdot q=n$ ist also nicht $\FP$-""invertierbar.
\end{dogma}

\begin{bemerk}
  Der Algorithmus für \autoref{satz:2} verwendet im ersten Schritt $n$ und
  $\phi(n)$. Ist die Primfaktorzerlegung für $n$ (die Falltürinformation)
  nicht gegeben, so ist die Berechnung von $\phi(n)$ genauso schwer wie die
  Zerlegung von $n$ in Primfaktoren. (\autoref{lem:7}) Damit ist der
  Algorithmus laut unserem Dogma ohne die Falltürinformation nicht in
  Polynomialzeit berechenbar.

  Damit ist die Funktion $g_{n,m}$ ein Kandidat für eine
  Falltür-""Einwegfunktion.
\end{bemerk}

\begin{lemma}
  \label{lem:7}
  Die Berechnung von $\phi(n)$, ohne Kenntnis der Primfaktorzerlegung von $n$,
  ist genauso schwer wie die \highl{Faktorisierung} von $n$, d.\,h. die
  Zerlegung von $n$ in ihre Primfaktoren.

  \begin{proof}
    \begin{description}
     \item["`$\Rightarrow$"'] Falls die Faktorisierung $n=p\cdot q$ bekannt
      ist, lässt sich $\phi(n)$ leicht berechnen, da $\phi$ multiplikativ ist.
      (\autoref{sec:restklassen})
      \begin{gather*}
        \phi(n) = \phi(p\cdot q) = \phi(p)\cdot\phi(q) = (p-1)\cdot(q-1)
      \end{gather*}
      Es gilt also: $\phi$-Funktion $\leq_{m}^{p}$ Faktorisierung.

     \item["`$\Leftarrow$"'] Falls $\phi(n)$ bekannt ist (und $n$ das Produkt
      zweier Primzahlen ist), dann sind $p$ und $q$, so dass $n=pq$, leicht
      berechenbar.

      \begin{align*}
        \phi(n) &= (p-1)\cdot(q-1) = pq - p-q +1 = n - (p+q) +1
      \end{align*}
      Also lässt sich die Summe der beiden Primzahlen anhand der gegebenen
      Größen bestimmen:
      \begin{gather*}
        p+q = n-\phi(n) +1
      \end{gather*}

      Die Differenz $p-q$ lässt sich aus den gegebenen Größen auf die
      folgenden Weise bestimmen:
      \begin{gather*}
        (p-q)^{2} = p^{2} - 2pq + q^{2} = p^{2} + 2pq + q^{2} - 4pq = (p+q)^{2}
           - 4n\\
        p-q = \sqrt{(p+q)^{2}-4n}
      \end{gather*}

      Die gesamte Berechnung erfordert $O(1)$ viele Schritte, womit beide
      Probleme gleich schwer sind. Es gilt also: Faktorisierung $\leq_{m}^{p}$
      $\phi$-Funktion.
    \end{description}
  \end{proof}
\end{lemma}

\begin{bsp}
  Gegen seien $n=943 = 23\cdot41$ und $\phi(n)=22\cdot40=880$. Damit ergibt
  sich $p+q = 943-880+1 = 64$ und $p-q = \sqrt{64^{2}-4\cdot943} = 18$. Aus
  $(p+q)+(p-q)$ ergibt sich wie erwartet so $p=41$ und aus $(p+q)-(p-q)$
  ergibt sich $q=23$.
\end{bsp}

Wir haben jetzt zwei Funktionen, von denen wir annehmen, dass sie nicht
$\FP$-invertierbar sind: der diskrete Logarithmus und die Faktorisierung von
Zahlen. Die Public-Key-Verfahren beruhen auf diesen Funktionen, wobei RSA auf
der Faktorisierung von Zahlen und El Gamal auf dem diskreten Logarithmus
basiert.

% 17.1.

\section{Das RSA-Verfahren}

1978: Ron Rivest, Adi Shamir, Leonard Adleman; Führer der Truppe war Rivest.
wollten zeigen, das Deffie und Helman nicht recht hatten mit ihrem Ansatz,
dass es Einwegfunktionen gibt.

\begin{table}
  \centering
  \begin{tabularx}{.85\linewidth}{*{2}{|c|>{\raggedright\arraybackslash}X}|}
    \hline
    Schritt& Alice& Kanal& Bob\\
    \hline
    1.& & & "`Wähle"' zwei große Primzahlen $p$ und $q$, bestimme $n=p\cdot q$\\
    2.& & & "`Wähle"' eine große Zahl $d$ mit $\ggT(d,\phi(n)) = 1$\\
    3.& & & Berechne das eindeutig bestimmte Inverse $e$ in $\Z_{\phi(n)}^{*}$;
       $d\cdot e\equiv1\pmod{\phi(n)}$\\
    4.& & $\xleftarrow{n,e}$& Veröffentliche $n$ und $e$\\
    5.& Chiffriere die Botschaft~$M\leq n-1$ durch $C=M^{e}\pmod{n}$& & \\
    6.& Sende verschlüsselte Botschaft& $\xrightarrow{C}$& \\
    7.& & & Dechiffriere $C^{d}\pmod{n} = M$\\
    \hline
  \end{tabularx}
  \caption{Das RSA-Verfahren (Alice schickt eine verschlüsselte Nachricht an Bob.)}
\end{table}

öffentlich sind $n,e$ und $C$, geheim bleiben $p,q, \phi(n), d$ und $M$

\begin{satz}
  Der RSA-Algorithmus ist korrekt.

  \begin{proof}
    ist bereits im \autoref{sec:rsa-math}.

    (zur Übung selber nachrechnen)
  \end{proof}
\end{satz}

\begin{bemerk}
  \begin{enumerate}
   \item RSA ist etwa 100 mal langsamer als AES. Daher verwendet man
    \highl{Hybridverfahren}: Schlüsseltausch (des Schlüssels für die
    Blockverschlüsselung) gemäß RSA, Verschlüsselung mit AES

   \item "`Wähle"' große Primzahlen: $p$ und $q$ sollten in der Größenordnung
    von $10^{100}$ liegen, damit man $n$ nicht leicht faktorisieren kann. Es
    gibt unterschiedliche, probabilistische Verfahren, um eine Zahl auf prim
    zu testen; z.\,B. von Solovay und Strassen: ca.\,170 Zahlen testen oder
    von Rabin und Miller: ca.\,100 Zahlen testen

   \item "`Wähle"' große Zahl $d$, damit sie nicht durch probieren
    gefunden werden kann.

   \item $e$ ist mit dem erweiterten euklidischen Algorithmus in
    Polynomialzeit berechenbar.

   \item $C$ und $M$ sind ebenfalls in Polynomialzeit berechenbar.
    (sqare-and-multiply-Algorithmus)

   \item $p$ und $q$ mit $p\cdot q>10^{200}$ sollten um einige Dezimalstellen
    differieren, damit man nicht durch $\sqrt{pq}$ diese schon fast erhält.

   \item $p-1$ und $q-1$ sollten große Primfaktoren besitzen und $p-1$ und
    $q-1$ sollten möglichst teilerfremd sein ($\ggT(p-1, q-1)$ möglichst klein).

   \item Ein direkter Angriff würde bedeuten, da $C=M^{e}\pmod{n}$ ist, aus
    $C$ die $e$.\,Wurzel modulo~$n$ zu berechen. Dogma: Dies ist ohne
    Falltürinformation praktisch nicht möglich.

   \item Nachrichten in Blöcke passender Länge zerlegen; passende Blocklänge
    ist ??? \help{Hat jemand kappiert, wie man die Blocklänge wählt?}
  \end{enumerate}
\end{bemerk}

\begin{bsp}
  $p=47, q=59$. Dann ist $n=pq = 2773$, $\phi(n) = (p-1)(q-1) = 46\cdot58 =
  2668$.

  $d\in\Z_{\phi(n)}^{*}$, $d=157$.

  Berechne $e$ mit erweiterten euklidischen Algorithmus: $e=17$

  Als Blocklänge ergibt sich 2, da $(\abs{\mathrm{Buchstaben}}+
  \abs{\mathrm{Satzzeichen}})^{2}\leq n-1$ ($26^{3}>n-1$).

  Nachricht: "`\texttt{ITS ALL GREEK TO ME}"' wird codiert zu
  \texttt{0920 1900 0112 1200 0718 0505 1100 2015 0013 0500} (Leerzeichen ist 00)

  $e = 17 = 10001_{2}$. Der erste Block $M_{1}^{2} = 920$ wird verschlüsselt zu
  \begin{gather*}
    920^{17}\pmod{2773} = (((920^{2})^{2})^{2})^{2}\cdot920 \pmod{2773} = 948
  \end{gather*}

  Insgesamt ergibt sich als Geheimtext \texttt{0948 2342 1084 1444 2663 2390
  0778 0774 0219 1655}.

  Dechiffrierung: $948^{157}\pmod{2773}$; da $d=157= 10011101_{2}$ ergibt sich
  \begin{gather*}
    948^{157}\pmod{2773} = ((((((948^{2})^{2})^{2}\cdot948)^{2}\cdot948)^{2}
       \cdot948)^{2})^{2}\cdot948\pmod{2773} = 920
  \end{gather*}

  Bemerkung: mach mach modulo nach jedem Quadrieren bzw. Multiplizieren, damit
  die Operanten nicht zu groß werden.
\end{bsp}

% 22.1.

\begin{fakt}
  Die Sicherheit von RSA beruht auf der Sicherheit des Faktorisierungsproblems
  FACTORING. Falls FACTORING "`einfach"' ist, dann ist auch RSA "`einfach"'.
  Es gilt: $RSA\leq_{m}^{p} FACTORING$.
\end{fakt}

Ein Angriff auf das Faktorisierungsproblem ist die \highl{$(p-1)$-Methode} von
Polard. Dies funktioniert fpr zusammengesetzte Zahlen~$n$ mit einem
Primfaktor~$p$, falls $p-1$ kleine Primfaktoren hat. Dann ist es möglich, ein
Vielfaches von $p-1$ zu bestimmen, ohne $p$ zu kennen. Falls $\nu$ ein solches
Vielfaches ist, dann gilt $a^{\nu}\equiv1\pmod{p}$ für alle $a$ mit
$\ggT(a,p)=1$ (der kleine Satz von Fermat).

Hieraus folgt: $p$ ist ein Teiler von $a^{\nu}-1$. Dann gilt: wenn $n$ kein
Teiler von $a^{\nu}-1$ ist, dass ist $\ggT(n,a^{\nu}-1)$ ein echter Teiler von
$n$. (d.\,h. $n$ ist faktorisiert!)

Woher kommt dieses $\nu$? Als Kandidat für $\nu$ sind Produkte der Form
\begin{gather*}
  \nu = \prod_{\substack{q\text{~ist prim}\\q^{k}\leq S}} q^{k}
\end{gather*}
für eine Schranke~$S$.

Falls hier ein $q$ als Teiler von $p-1$ dabei ist, dann ist $\nu$ ein
Vielfaches von $p-1$, falls nicht, probiere eine größere Schranke~$S'>S$.

Eine Bemerkung zum \highl{quadratischen Sieb}: Für eine zu faktorisierende
Zahl~$n$ werden Zahlen~$a$ und $b$ so ermittelt, dass gilt:
\begin{gather*}
  a^{2}\equiv b^{2}\pmod{m}\qquad\text{und}\qquad a\not\equiv \pm b\pmod{n}
\end{gather*}

Das heißt $n$ teilt $a^{2}-b^{2}=(a+b)(a-b)$, aber weder $a+b$ noch $a-b$.
Damit ist der größer gemeinsame Teiler von $a-b$ und $n$ ein nichttrivialer
Faktor von $n$.

Falls FACTORING "`schwer"' ist, bedeutet dies nicht, dass RSA "`schwer"' ist.
Insbesondere ist RSA kein Primzahltest, da es auch mit Modulen funktioniert,
die keine Primzahlen sind!

\begin{defini}
  Eine \highl{Carmichael-Zahl}~$c$ ist eine zusammengesetzte Zahl, so dass für
  alle Primfaktoren~$q$ von $c$ gilt:
  \begin{itemize}
   \item $q-1$ teilt $c-1$ und
   \item für alle zu $q$ teilerfremden Zahlen~$n$ gilt $a^{q-1}\equiv
    1\pmod{q}$. (diese Eigenschaft ist aus der ersten ableitbar \gdw (wegen
    der ersten Eigenschaft) $a^{c-1}\equiv1\pmod{c}$ \gdw (wegen dem
    chin.\,Restklassensatz) $a^{c-1}\equiv1\pmod{c}$)
  \end{itemize}
\end{defini}

\begin{bsp}
  $561 = 3\cdot11\cdot17$. Dann gilt
  \begin{itemize}
   \item 2, 10 und 16 Teiler von 560
   \item falls $a$ teilerfremd zu 3, 11 und 17 ist, dann ist $a^{560}\equiv1
    \pmod{561}$, z.\,B. $14^{560}\equiv1\pmod{561}$, aber z.\,B. gilt
    $9^{560}\equiv375\pmod{561}$.
  \end{itemize}
\end{bsp}

Wir betrachten folgenden Modul~$n=p\cdot c$, wobei $c$ eine Carmichael-Zahl
mit $c=\prod q_{i}$ ist. (Dann gilt $\phi(n)\ne(p-1)\cdot(c-1)$, da $c$ keine
Primzahl ist, aber $(p-1)\cdot(c-1)=(q-1)\cdot b_{i}$.) Wir wählen ein $e$ mit
$\ggT(e,(p-1)(c-1)) =1$ und bestimmen ein $d$ mit $e\cdot d\equiv1
\pmod{(p-1)(c-1)}$.

Behauptung: $a^{ed}\equiv a\pmod{n}$.
\begin{enumerate}[{Fall}~1]
 \item Wir betrachten den Primteiler $p$ von $n$.
  \begin{enumerate}[{Fall~1}a]
   \item $p$ ist Teiler von $a$, dann ist $a^{ed}\equiv0\equiv a\pmod{p}$.
   \item $p$ ist kein Teiler von $a$, dann ist
    \begin{gather*}
      a^{ed}\equiv a^{k(p-1)(c-1)}\cdot a\equiv (a^{p-1})^{k(c-1)}\cdot a
         \equiv1\cdot a\equiv a\pmod{p}
    \end{gather*}
  \end{enumerate}

 \item Wir betrachten alle Primteiler $q_{i}$ von $n$.
  \begin{enumerate}[{Fall~2}a]
   \item Wenn $q_{i}$ Teiler von $a$ ist, dann ist $a^{ed}\equiv0\equiv
    a\pmod{q_{i}}$.
   \item Ist $q_{i}$ kein Teiler von $a$, dann ist
    \begin{gather*}
      a^{ed}\equiv a^{k(p-1)(c-1)}\cdot a\equiv a^{k(q_{i}-1)b_{i}}\cdot
         a\equiv (a^{q_{i}-1})^{k\cdot b_{i}} \cdot a\equiv a\pmod{q_{i}}
    \end{gather*}
  \end{enumerate}
\end{enumerate}

Also gilt nach dem chinesischen Restklassensatz:
\begin{gather*}
  a^{ed}\equiv a\pmod{(p\cdot\prod q_{i})}
\end{gather*}

Das heißt, es gibt Zahlen, die nicht prim sind, für die aber der
RSA-Algorithmus korrekt ist.

"`Optimieren"' lässt sich der Algorithmus in folgendem Sinne: Es ist nicht
notwendig, den öffentlichen Schlüssel~$e$ so zu bestimmen, dass
$\ggT\bigl(e,\phi(n)\bigr)=1$ ist. Für $n=p\cdot q$ genügt es ein $e$ zu
bestimmen, für das gilt: $\ggT\bigl(e,\kgV(p-1,q-1)\bigr)$. Der Vorteil zeigt
sich bei der Berechnung des geheimen Schlüssels~$d$, da hierfür das Modul
kleiner geworden ist: Für $p=11$ und $q=13$ ist $(p-1)(q-1)=120$, aber
$\kgV(p-1,q-1)=60$.

Der Korrektheitsbeweis hierfür erfolgt analog zum ursprünglichen Beweis von
RSA und zum Beweis für die Carmichael-Zahlen, denn es gelten die folgenden
Beziehungen:
\begin{itemize}
 \item $\kgV(p-1,q-1) = (p-1)\cdot b$ bzw.
 \item $\kgV(p-1, q-1) = (q-1)\cdot c$
\end{itemize}

Zum Beispiel der Fall $\ggT(a,n)=1$
\begin{gather*}
  a^{ed} \equiv a^{k\kgV(p-1,q-1)}\cdot a\equiv a^{k(p-1)b}\cdot a\equiv1\cdot
     a\equiv a\pmod{p}
\end{gather*}

Es ist sinnvoll diese Optimierung in einem hybriden Verfahren abzuwenden.
\help{So richtig habe ich nicht verstanden warum.}

\section{Das Verfahren von El Gamal}
(1985)

Das Protokoll:
\begin{table}
  \centering
  \begin{tabularx}{.9\linewidth}{*{2}{|c|>{\raggedright\arraybackslash}X}|}
    \hline
    Schritt& Alice& Kanal& Bob\\
    \hline
    1.& \multicolumn{3}{c|}{\rule{0pt}{5ex}\parbox{.6\linewidth}{Alice und Bob
       verabreden eine große Primzahl~$p$ und eine primitive Wurzel $g$ von
       $p$. $p$ und $g$ sind öffentlich}}\\
    2.& & & Bob wählt zufällig ein $b\in\Z_{p-1}^{*}$ und berechnet
       $\beta=g^{b}\pmod{p}$; $b$ ist privat\\
    3.& & $\xleftarrow{\beta}$& \\
    4.& Alice wählt zufällig ein $a\in\Z_{p-1}^{*}$ und berechnet
       $\alpha=g^{a}\pmod{p}$ und $C=M\cdot b^{a}\pmod{p}$; $a$ und $M$
       sind privat, $C$ und $\alpha$ sind öffentlich& & \\
    5.& & $\xrightarrow{C,\alpha}$& \\
    6.& & & Bob berechnet $x=p-1-b$ und $M=C\cdot\alpha^{x}\pmod{p}$\\
    \hline
  \end{tabularx}
  \caption{Ablauf des El Gamal-Verfahrens}
\end{table}

\begin{satz}
  Der El Gamal-Algorithmus ist korrekt.

  % 24.1.

  \begin{proof}
    $p,g$ öffentlich, $\ggT(a,p-1)=1, \alpha=g^{a}\pmod{p},
    C=M\beta^{a}\pmod{p}$, $\ggT(b,p-1) = 1, \beta=g^{b}\pmod{p}$.

    $x:= p-1-b$,
    \begin{gather*}
      C\cdot\alpha^{x}\equiv (M\beta^{a})(g^{a})^{x} \equiv
         M\cdot (g^{b})^{a} (g^{a})^{p-1-b} \equiv M\cdot g^{ba+a(p-1)-ab}
         \equiv M\cdot(g^{b-1})^{a}\equiv M\cdot1 \equiv M\pmod{p}
    \end{gather*}

    Sicherheit: Die Kenntnis von $a$ und $b$ liefert den "`Rest"'. $a$ und $b$
    sind geheim. $a=\log_{g}\alpha\pmod{p}$ bzw. $b=\log_{g}\beta\pmod{p}$.
    (Die Wahl von $g$ als Primitive Wurzel sichert, dass $a$ und $b$ eindeutig
    bestimmt sind.) Dogma: modulare Exponentation mit fester Basis und festem
    Modul ist eine Einwegfunktion, d.\,h. der diskrete Logarithmus ist nicht
    $\FP$-berechenbar. Die Größen $a$ und $b$ sind nicht $\FP$-berechenbar,
    insebsondere kann Bob auch nicht das geheime $a$ von Alice berechnen, aber
    sie werden auch nicht zur Entschlüsselung benötigt.
  \end{proof}
\end{satz}

Für den diskreten Logarithmus braucht man wie für die diskrete Wurzel keine
Falltürinformation.

\begin{bemerk}
  Es gibt auch noch andere Public-Key-Verfahren: Das Verfahren von Rabin:
  Idee: Wähle zwei große Primzahlen~$p$ und $q$ mit $p\equiv 3\pmod{4}$ und
  $q\equiv3\pmod{4}$, also $\frac{p+1}{4},\frac{q+1}{4}\in\N$; $p,q$ sind
  geheim, $n=p\cdot q$ ist öffentlich.

  Für eine Nachricht~$M<n$ ist $C=M^{2}\pmod{n}$.

  Sicherheit: Wurzelziehen geht nur, wenn $p$ und $q$ bekannt sind, da
  diskrete Wurzel nicht $\FP$-berechenbar.

  Problem: Wurzel ist nicht eindeutig.
\end{bemerk}

\section{Digitale Signaturen}

Das Anliegen besteht in der \highl{Authentifizierung} des Absenders.
Grundidee: Wir nutzen die Sicherheit der Protokolle der Public-Key-Verfahren
in modifizierter Form für die Authentifizierung.

\begin{table}
  \centering
  \begin{tabularx}{.85\linewidth}{*{2}{|c|>{\raggedright\arraybackslash}X}|}
    \hline
    Schritt& \multicolumn{1}{c|}{Alice}& Kanal& \multicolumn{1}{c|}{Bob}\\
    \hline
    1.& \multicolumn{3}{c}{\parbox{.6\linewidth}{wähle eine große Primzahl $p$
       und eine primitve Wurzel $g$ von $p$; $p,g$ öffentlich}}\\
    2.& && wähle $b$; $\beta=g^{b}\pmod{p}$ wie zuvor\linebreak wähle weiter
       $r\in\Z_{p-1}^{*}$ und $\rho=g^{r}\pmod{p}$ und berechne $s$ gemäß
       $b\cdot\rho+r\cdot s\equiv M\pmod{p}$ und $sig_{Bob}(M) = (\rho,s)$\\
    3.& & $\xleftarrow{\beta,M,sig_{Bob}(M)}$& \\
    4.& Überprüfe $g^{m} = \beta^{s}\cdot\rho\pmod{p}$& & \\
    \hline
  \end{tabularx}
  \caption{Das Protokoll von El~Gamal zur digitalen Signatur}
\end{table}

$\beta$ und $\rho$ wie gehabt berechnen (square-and-multiply-Algo), $s$ mit
dem erweiterten euklidischen Algorithmus

Korrektheit:
\begin{gather*}
  g^{m} \equiv g^{b\cdot\rho+r\cdot s} \equiv \beta^{\rho}\cdot \rho^{s} \pmod{p}\\
  g^{m} = g^{b\cdot\rho+r\cdot s + k\cdot p} = g^{b\cdot\rho+r\cdot s} \cdot
     (g^{p})^{k} = g^{b\cdot\rho+r\cdot s} \cdot 1^{k} = \beta^{\rho}\cdot \rho^{s} \pmod{p}
\end{gather*}

Ergänzung vom 31.1.:
\textbf{Achtung:} Irgendwo muss hier $b\rho+rs=m\pmod{p-1}$ stehen und nicht
$\pmod{p}$.

\begin{enumerate}[1.\,{Schritt}]
 \item Da $r$ teilerfrem zu $p-1$ ist, gibt es ein Inverses $s'$ mit $r\cdot
  s'=1\pmod{p-1}$ (mit erweiterten euklidischen Algorithmus). Dann bestimme
  $s$ mit $r\cdot s\equiv m-b\rho\pmod{p-1}$
 \item Verifikation
  \begin{gather*}
    g^{m} \equiv g^{b\rho+rs + l(p-1)} \equiv g^{b\rho} g^{rs}
       (\underbrace{g^{p-1}}_{=1})^{l}
       \pmod{p-1} \equiv g^{b\rho} g^{rs} = \beta^{\rho} \rho^{s}
  \end{gather*}
\end{enumerate}

Ende der Ergänzung.

\begin{table}
  \centering
  \begin{tabularx}{.85\linewidth}{*{2}{|c|>{\raggedright\arraybackslash}X}|}
    \hline
    Schritt& \multicolumn{1}{c|}{Alice}& Kanal& \multicolumn{1}{c|}{Bob}\\
    \hline
    1.& wählt $n=p\cdot q$ und $e$ wie gehabt als öffentlichen Schlüssel und
       $d$ als privaten Schlüssel& & \\
    2.& & $\xrightarrow{n,e}$& \\
    3.& signiert die Botschaft $M$ durch $sig_{Alice}(M) = M^{d}\pmod{m}$ & & \\
    4.& & $\xrightarrow{M,sig_{Alice}(M)}$& überprüft $M=
       (sig_{Alice}(M))^{e}\pmod{n}$
  \end{tabularx}
  \caption{RSA-Protokoll für digitale Signaturen}
\end{table}

Korrektheit wie gehabt:
\begin{gather*}
  sig_{Alice}(M)^{e} \equiv M^{d\cdot e} \equiv M\pmod{n}
\end{gather*}

\section{Das Shamir-ohne-Schlüssel-Protokoll}

In Anlehnung an den Diffie-Helman-Schlüsseltausch.

\begin{table}
  \centering
  \begin{tabularx}{.85\linewidth}{*{2}{|c|>{\raggedright\arraybackslash}X}|}
    \hline
    Schritt& \multicolumn{1}{c|}{Alice}& Kanal& \multicolumn{1}{c|}{Bob}\\
    \hline
    1.& \multicolumn{3}{c}{\parbox{.6\linewidth}{wähle eine große Primzahl;
       $p$ öffentlich}}\\
    2.& für eine Nachricht $M$ berechne $x =
       M^{a}\pmod{p}$; $x$ öffentlich& & \\
    3.& & $\xrightarrow{x}$& \\
    4.& & & berechnet $y= x^{b}\pmod{p}$; $y$ öffentlich\\
    5.& & $\xleftarrow{y}$& \\
    6.& berechnet $z=y^{a^{-1}}\pmod{p}$; $z$ öffentlich& & \\
    7.& & $\xrightarrow{z}$& \\
    8.& & & $M=z^{b-1}\pmod{p}$
  \end{tabularx}
  \caption{Das Protokoll Shamir-ohne-Schlüssel}
\end{table}

Alice hat ihr Geheimnis~$a$, Bob hat sein Geheimnis~$b$, aber es gibt kein
gemeinsames Geheimnis. Alice berechnet ein Paar $(a,a^{-1})$ mit der
Eigenschaft $a\cdot a^{-1}\equiv1\pmod{p-1}$ und entsprechend berechnet Bob
ein Paar~$(b,b^{-1})$ mit der Eigenschaft, dass $b\cdot
b^{-1}\equiv1\pmod{p-1}$ ist. Dann gilt
\begin{gather*}
  z^{b^{-1}} \equiv y^{a^{-1}\cdot b^{-1}}
     \equiv x^{b\cdot a^{-1}\cdot b^{-1}}
     \equiv m^{a\cdot b\cdot a^{-1}\cdot b^{-1}} \equiv m
\end{gather*}

% 29.1.

\chapter{Kryptographische Hashfunktionen}

\begin{defini}
  Eine \highl{Hashfunktion} ist eine Abbildung der Form $H\colon\Sigma^{*}
  \mapsto \Sigma^{n}$ für ein festes $n\in\N$.
\end{defini}

\begin{bsp}
  $\Sigma=\{0,1\}$ für den Wert $w=b_{1}b_{2}\dotso b_{k}$ sei $H(w) =
  b_{1}\oplus b_{2}\oplus \dotsb \oplus b_{k}$; $H(w)=1$ \gdw die Anzahl der
  Einsen in $w$ ist ungerade. $H\colon\Sigma^{*} \mapsto\sigma^{1}$
\end{bsp}

Trivialer Weise kann eine Hashfunktion nicht injektiv sein.

In der informatischen Pracis werden Hashfunktionen häufig durch
Kopressionsfunktionen erzeugt. Ein \highl{Kompressionsfunktion} ist eine
Abbildung der Form $K\colon\Sigma^{m}\mapsto\Sigma^{n}$ für $m>n$.

Zwei Forderungen:
\begin{itemize}
 \item $H$ (und $K$) müssen schnell berechenbar sein
 \item $H(w) = H(w')$ für $w\ne w'$ sollte nicht zu häufig auftreten! Eine
  solche Situation nennt man \highl{Kollision}.
\end{itemize}

Fü kryptographische Hashfunktionen kommt eine weitere Forderung hinzu: Wir
betrachten folgende Situation bei digitalen Signaturen: Alice schickt neben
der Nachricht~$m$ ihren Identitätsnachweise $sig_{Alice}(m)$ und also
insgesamt $(m,sig_{Alice}(m))$.

Problem: Die Signatur ist genauso lang wie die Nachricht! Idee: Den Hashwert
einer Nachricht zu signieren. Aber der Hashwert $H(m)$ ist leicht zu berechnen.
Findet ein Angreifer eine Nachricht $m'$ mit $H(m')=H(m)$, dann gilt: $(m',
sig_{Alice}(H(m))) = (m', sig_{Alice}(H(m')))$ und damit kann sich der
Angreifer als Alice ausgeben.

Um genau das zu vermeiden, formulieren wir folgende Eigenschaften einer
kryptographischen \highl{Hashfunktion}~$H$:
\begin{itemize}
 \item $H$ ist in Polynomialzeit berechenbar; $H\in\FP$
 \item $H$ ist eine Einwegfunktion
 \item $H$ ist (schwach) \highl{Kollitionsresistent}; d.\,h. für gegebenes $m$
  gibt es keinen Polynomialzeitalgorithmus, der ein $m'\ne m$ mit der
  Eigenschaft $H(m')=H(m)$ berechnet.
 \item $H$ ist (stark) Kollitionsresistent; d.\,h. es gibt keinen
  Polynomialzeitalgorithmus, der überhaupt eine Kollision berechnet.
\end{itemize}

\begin{bemerk}
  Ein Invertierungsalgorithmus~$A$ für $H$ liefert für ein gegebenes $m$ ein
  Element~$m'=A(H(m))$. Da die Anzahl der Urbilder von $H(m)$ im Mittel größer
  als eins ist, ist die Wahrscheinlichkeit eine Kollision $m'$ zu brechnen im
  Mittel größer als $\frac{1}{2}$.
\end{bemerk}

Konsequenz: $H$ ist eine Einwegfunktion, deswegen probabilistische Algorithmen
zur Erzeugung von Kollisionen.

\section{Das Geburtstagsparadoxon}

\begin{satz}
  (von Merkle) Aus einer stark kollisionsrestistenten Kompressionsfunktion~$K$
  der Form $K\colon\Z_{2}^{m} \mapsto \Z_{2}^{n}$ ($m>n$) lässt sich eine
  stark kollisionsrestistente Hashfunktion~$H\colon\Z_{2}^{m} \mapsto
  \Sigma_{2}^{n}$ konstruieren.
  lässt sich
\end{satz}

Da nicht bewiesen ist, dass es kryptographische Einwegfunktionen gibt,
verwendet man nur solche Hashfunktionen, deren Kollisionsrestistenz (bisher)
nicht widerlegt ist. Dazu werden Verschlüsselungsverfahren benutzt, die als
sicher gelten. Es ergibt sich die Frage nach der Länge~$n$ der Hashwerte.

Der gewünschte Hashwert sei $n$. Dazu benötigt man ein
Verschlüsselungsverfahren für das die Klartext- und Chiffremenge $\Z_{2}^{n}$
ist, die Verschlüsselungsfunktion~$E_{k}\colon\Z_{2}^{n}\mapsto\Z_{2}^{n}$ und
der zugehörige Schlüssel~$k\in\Z_{2}$. Dann lässt sich eine
Hashfunktion~$H\colon\Z_{2}^{*} \mapsto \Z_{2}^{n}$ wie folgt definieren: Es
sei $x=x_{1}x_{2}\dotso x_{l}$ ($x$ in Blöcke zerlegt), wobei alle
$x_{i}\in\Z_{2}^{*}$ ($x_{l}$ bis zur Länge $n$ auffüllen). Ausgangsschlüssel
$k_{0}\in\Z_{2}^{n}$. Wir berechnen $k_{i}=f(x_{i},k_{i-1})$ für
$i=1,\dotsc,l$ und $H(x) := k_{l}$. Dabei ist $f\colon\Z_{2}^{n}\times
\Z_{2}^{n} \mapsto\Z_{2}^{n}$ eine Funktion, die durch die
Verschlüsselungsfunktion definiert ist: Man unterscheidet vier Typen:
\begin{itemize}
 \item $k_{i} = E_{k_{i-1}}(x_{i})\oplus x_{i}$
 \item $k_{i} = E_{k_{i-1}}(x_{i})\oplus x_{i}\oplus k_{i-1}$
 \item $k_{i} = E_{k_{i-1}}(x_{i}\oplus k_{i-1})\oplus x_{i}$
 \item $k_{i} = E_{k_{i-1}}(x_{i}\oplus k_{i-1})\oplus x_{i}\oplus k_{i-1}$
\end{itemize}

Es bleibt die Frage: "`Wie groß soll $n$ sein?"' Zwei sich widersprechende
Richtungen: nicht zu groß (eine Hashfunktion soll komprimieren), aber nicht zu
klein, da sonst zu viele Kollisionen. jetzt: Geburtstagsparadoxon

\begin{satz}[Geburtstagsparadoxon]
  Ein Merkmal komme in genau $m$ Ausprägungen vor -- $m$ verschiedene
  Hashwerte. Jede Person hat genau eine Ausprägung des Merkmals. Es sei $k$
  die Anzahl der Personen. Die Wahrscheinlichkeit dafür, dass zwei Personen
  dieselbe Merkmalsausprägung haben, ist $\geq\frac{1}{2}$, falls $k\geq
  \frac{\sqrt{1+8\cdot m\ln2}+1}{2}\approx 1\mathord{,}18\sqrt{m}$.

  Zum Beispiel gilt für $m=365$ $k\geq23$.
\end{satz}

Für eine Hashfunktion $H\colon\Z_{2}^{*} \mapsto \Z_{2}^{n}$ hat die
"`Geburtstagsattake"' folgende Konsequenz: Das Erzeugen von etwa
$2^{\frac{n}{2}}$ Hashwerten, impliziert das die Wahrscheinlichkeit für eine
Kollision $\geq\frac{1}{2}$ ist. Dies bedeutet für die Praxis, dass $n=64$ ist
zu kurz und damit zu unsicher, da $2^{32}\approx4\cdot10^{9}$ Hashwerte für
eine Kollision berechnet werden müssen.

Illustration an einem Beispiel: "`Ein unehrenhaftes Protokoll"' Alice
erarbeitet zwei Verträge: Der eine begünstigt Bob, der ander benachteiligt ihn
und erzeugt für jeden Vertrag durch marginale Änderungen (z.\,B.
hinzufügen/weglassen von Leerzeichen) $2^{32}$~Varianten, berechnet für jede
Variante den Hashwert und wählt die zwei Fassungen, deren Hashwerte gleich
sind. Bob signiert den Hashwert und akzeptiert damit auch den für ihn
nachteiligen Vertrag.

% 31.1.

\begin{proof}[für die Geburtstagsattake]
  $m$ verschiedene Merkmalsausprägungen werden durch $\{1,2,\dotsc,m\}$
  beschrieben. $k$ Personen bedeutet: wir betrachten den
  Wahrscheinlichkeitsraum $\{1,2,\dotsc,m\}^{k}$ unter Gleichverteilung. Ein
  Elementarereignis $(g_{1},g_{2},\dotsc, g_{k})\in\{1,2,\dotsc,m\}^{k}$
  trifft zu \gdw für alle $i=1,\dotsc,k$ gilt: Person $i$ besitzt das Merkmal
  $g_{i}$.

  Die Wahrscheinlichkeit pro Elementarereignis ist
  \begin{gather*}
    \frac{1}{m^{k}}
  \end{gather*}

  Wir nehmen uns die duale Aufgabe her: Wie groß ist die Wahrscheinlichkeit,
  dass alle $g_{i}$ paarweise verschieden sind.
  \begin{gather*}
    q = \frac{\card \{(g_{1},\dotsc, g_{k})\colon \text{alle $g_{i}$ sind
       verschieden}\}}{m^{k}} = \frac{\prod_{i=0}^{k-1} (m-i)}{m^{k}} =
      \prod_{i=0}^{k-1} (1-\frac{i}{m})
  \end{gather*}
  Es gilt für alle reellen $x\in\R\colon e^{x}\geq1+x$.
  \begin{gather*}
    q\leq \prod_{i=0}^{k-1} e^{-\frac{i}{m}} = e^{-\sum_{i=0}^{k-1}\frac{i}{m}}
       = e^{-\frac{k(k-1)}{2m}}\\
    e^{-\frac{k(k-1)}{2m}} \leq \frac{1}{2} \gdw -\frac{k(k-1)}{2m} \leq \ln2
       \gdw k\geq \frac{1+\sqrt{1+8m\ln2}}{2}
  \end{gather*}
\end{proof}

Konsequenz: Bei einer Hashfunktion $H\colon\Z_{2}^{*} \mapsto \Z_{2}^{n}$ ist
die Wahrscheinlichkeit für eine Kollision $>\frac{1}{2}$, wenn
$2^{\frac{n}{2}}$ Hashwerte erzeugt werden. Für die Praxis: Hashfunktionen mit
mehr als $n\geq128$. Bei Signaturen: $n\geq160$.

In der Praxis haben sich zur Berechnung von Hashfunktionen (neben der
Erzeugung mit Hilfe der Verschlüsselung) spezielle Algorithmen etabliert:
\begin{description}
 \item[MD4] Erfinder Ron Rivest
 \item[MD5] Weiterentwicklung von MD4
 \item[SHA-1] von NSA
\end{description}

Fazit: Alice will Bob eine Nachricht senden und eine Signatur anfügen;
$(m,sig_{Alice}(m))$. Bob verifiziert mit dem öffentlichen Schlüssel von Alice
die Signatur; $ver_{Alice}(sig_{Alice}(H(M))) = H(m)$.

Oskar (der Angreifer) ist erfolgreich, wenn
\begin{itemize}
 \item er zu $m$ ein $m'$ mit $H(m)=H(m')$ erzeugen kann oder
 \item $sig_{Alice}$ berechnen kann.
\end{itemize}
Aber:
\begin{itemize}
 \item aus der Kenntnis von $ver_{Alice}$ kann er nicht auf die $sig_{Alice}$
  schließen, da $ver_{Alice}$ eine Einwegfunktion ist.
 \item Wenn $H$ kollisionsrestistent ist, dann lässt sich $m'$ nicht erzeugen.
\end{itemize}

\chapter{Zero-knowledge-Protokolle}
Gibt es eine Möglichkeit, dass Alice Bob klar macht, dass sie Alice ist, ohne
ihr Geheimnis an Bob zu verraten? Stcihwort aus der Komplexitätstheorie:
Arthur-Merlin-Game.

Ein Problem in der Komplexitätstheorie ist noch offen in Bezug auf
Man-in-the-middle-attack: \highl{Identifizierungsnachweis} von Alice gegenüber
Bob. Alice überzeugt Bob davon ein persönliches Geheimnis zu kennen, dass nur
Alice kennen kann, ohne dies Bob zu verraten.

Mit Hilfe des Graphisomorphieproblem: Gegeben seien zwei einfache
Graphen~$G_{1}=(V_{1},E_{2})$ und $G_{2}=(V_{2},E_{2})$. Die Frage ist: Ist
$G_{1}\cong G_{2}$ ($G_{1}$ isomorph zu $G_{2}$). $ISO =
\{(G_{1},G_{2})\colon G_{1}\cong G_{2}\}$. Klar: $ISO\in NP$, offen: $ISO\in
P$ und $ISO$ $NP$-vollständig.

Für das Protokoll:
\begin{enumerate}
 \item Merlin wählt einen großen Graphen~$G_{0}$ und eine Permutation~$\pi$
  und berechnet $G_{1}=\pi(G_{0})$, d.\,h. $G_{0}\cong G_{1}$. Die
  Permutation~$\pi$ stellt das persönliche Geheimnis von Merlin dar. $G_{0}$
  und $G_{1}$ ist öffentlich.
 \item Aufgabe: Arthur davon überzeugen, dass $G_{0}\cong G_{1}$.
\end{enumerate}

\begin{tabularx}{.85\linewidth}{*{2}{|c|>{\raggedright\arraybackslash}X}|}
  \hline
  Schritt& \multicolumn{1}{c|}{Merlin}& Kanal& \multicolumn{1}{c|}{Arthur}\\
  \hline
  1.& wählt zufällig ein Permutation $\rho$ und ein Bit $a\in\{0,1\}$ und
     berechnet $H=\rho(G_{1})$& & \\
  2.& & $\xrightarrow{H}$ &\\
  3.& & & wählt zufällig ein Bit~$b$ und verlangt eine Isomorphie zwischen $H$
     und $G_{b}$\\
  4.& & $\xleftarrow{b}$& \\
  5.& Merlin berechnet den Isomorphismus~$\sigma$ mit $\sigma(G_{b})=H$
     1.\,Fall: $b=a$, dann ist $\sigma=\rho$, 2.\,Fall $a=1, b=0$, dann ist
     $\sigma=\pi\cdot\rho$, 3.\,Fall $a=0, b=1$, dann ist
     $\sigma=\pi^{-1}\cdot\rho$& & \\
  6.& & $\xrightarrow{\sigma}$& \\
  7.& & Arthur verifiziert, dass $\sigma(G_{b}) = H$
\end{tabularx}

\clearpage
\appendix

\stepcounter{chapter}
\begin{thebibliography}{99}
\addcontentsline{toc}{chapter}{\thechapter.~\bibname}
 \bibitem{schneier} Bruce Schneier: "`Angewandte Kryptographie"', Pearson
  Studium, 1996
 \bibitem{rothe} Jörg Rothe: "`Complexity theory and cryptology---an
  introduction to cryptocomplexity"', Springer, 2005
 \bibitem{buchmann} J.\,Buchmann: "`Einführung in die Kryptographie"',
  Springer, 1999
 \bibitem{menezes} A.\,J.\,Menezes, P.\,C.\,van Oorschot, S.\,A.\,Vanstone:
  "`Handbook of Applied Cryptography"', CRC Press, 1997
 \bibitem{trappe} Trappe, Washington: "`Introduction to cryptography by coding
  theory"', Prantice Hall, 2002
 \bibitem{watjen} D.\,Wätjen: "`Kryptographie -- Grundlagen, Algorithmen,
  Protokolle"', Spektrum, 2004
 \bibitem{douglas} Douglas Stinson: "`Cryptography---Theory and praxis"', CRC
  Press, 1995
 \bibitem{bauer} F.\,Bauer: "`Entzifferte Geheimnisse"', Springer, 2000
 \bibitem{beutelspacher} A.\,Beutelspacher, J.\,Schwenk, K.-D.\,Wolfenstetter:
  "`Moderne Verfahren der Kryptographie"', 6.\,Auflage, Vieweg, 2006
 \bibitem{delfs} H.\,Delfs, H.\, Knebl: "`Introduction to cryptography"',
  Springer, 2002
 \bibitem{goldreich} O.\,Goldreich: "`Foundamentals of cryptography"',
  Cambridge, 2001
 \bibitem{diffihellman} W.\,Diffie, M.\,Hellman: "`New directions in
  cryptography"', IEEE Transaction on information theory 22, Seiten
  644--654, 1976
 \bibitem{adleman} L.\,Adleman, R.\,Rivest, A.\,Shamir: "`On digital
  signatures and public key cryptosystems"', MIT Press, 1977
 \bibitem{rsafaq} RSA Laboratories: "`RSA Laboratories' Frequently Asked
  Questions About Today's Cryptography, Version 4.1"', RSA Security Inc.,
  2000,\\ \url{ftp://ftp.rsasecurity.com/pub/labsfaq/rsalabs_faq41.pdf}
 \bibitem{rc5save} Y.\,L.\,Yin: "`The RC5 encryption algorithm: two years on"',
  CryptoBytes (3) 2, 1997
 \bibitem{idea-save} [DGV94] J.\,Daemen, R.\,Govaerts, J.\,Vandewalle: "`Weak 
  keys for IDEA, Advances in Cryptology -- Crypto '93"', Springer-Verlag, 1994
 \bibitem{luby} M.\,Luby,  C.\,Rackoff: "`How to Construct
  Pseudorandom Permutations and Pseudorandom Functions."' SIAM J.
  Comput., vol. 17, 1988, pp. 373-386
 \bibitem{matsui1} M.\,Matsui: "`Linear cryptanalysis method for DES
  cipher"', Advances in Cryptology---EUROCRYPT '93 Proceedings,
  Springer-Verlag, 1994, pp.386--397
\end{thebibliography}

\chapter{Übungsaufgaben}
\section{Blatt 1}

Der folgende mit Vigenère-Chiffrierung deutschsprachige Text ist zu
entschlüsseln. (Die Blockstruktur dient lediglich der besseren Lesbarkeit.)

\subsection*{Aufgabe 1}
Bestimmen Sie eine mögliche Periodenlänge~$d$
\begin{enumerate}[a)]
 \item mit Hilfe des Kasiski-Tests.
 \item mit Hilfe des Friedman-Tests.
 \item Formulieren Sie eine Hypothese für $d$.
\end{enumerate}

\subsection*{Aufgabe 2}
Bestimmen Sie gemäß $d$ eine Häufigkeitsverteilung und leiten Sie daraus ein
Schlüsselwort ab.

\subsection*{Aufgabe 3}
Bestimmen Sie den Klartext.

\begin{verbatim}
  FSGEXV  EVIISA  MGYFNX  EJTMUR  MPNYME  FMPSIH  EFIXUE  HQFOOU
  PGIAVI  KJSWLT  IIZJIJ  ELXVOT  YBKMEC  GYUELW  RHEHOR  ONIFVS
  EHKCJS  WLFEEL  JIBNTS  VTIMGY  JSNECT  IBRQVE  HXJDHF  YVTSYP
  EEIYWX  JLNRRU  UYVCJC  BELDHZ  YVSKFE  IUERXV  TGCFKF  IHIZOF
  UGYFSP  IIGABV  VOGYRL  FGYRUM  AHKVOK  FEIUER  XRVFTY  XFHIII
  JGEIZU  ZOIZOE  LFVLAH  RKFNMT  IBCBIQ  VUHXVS  SOGYFN  ILEFSY
  MEFSSR  KBXORU  TEGEEU  IEDLCE  NVRDHN  IE
\end{verbatim}

\section{Blatt 2}

\subsection*{Aufgabe 1}
\begin{enumerate}
 \item Verschlüsseln Sie die Nachricht $m=\mathrm{WASSER}$ mit Hilfe der
  Hill-Chiffre und verwenden Sie die Matrix
  \begin{gather*}
    K =
    \begin{pmatrix}
      7 & 3\\
      5 & 8
    \end{pmatrix}
  \end{gather*}

 \item Bestimmen Sie die enschrechende Matrix zur Entschlüsselung und wenden
  Sie diese auf den in a) erhaltenen Geheimtext an.
\end{enumerate}

\subsection*{Aufgabe 2}
Bestimmen Sie eine $2\times 2$-Matrix~$M$, durch die die Nachricht "`hund"'
mit der Hill-Chiffre in den Geheimtext "`AFFE"' umgewandelt wird.

\subsection*{Aufgabe 3}
Wir definieren die Abbildung $\Phi_{a,b}\colon \Z_{26}\rightarrow\Z_{26}$ durch
\begin{gather*}
  \Phi_{a,b}(x) := (ax+b) \pmod{26}
\end{gather*}
Bestimmen Sie diejenigen ganzen Zahlen $a,b$, für die die Abbildung
$\Phi_{a,b}$ bijektiv ist.

\textbf{Bemerkung:} Diese Abbildung kann zum Verschlüsseln verwendet werden
(affine Chiffre)

\section{Blatt 3}

Der folgende Text wurde mit der Vigenère-Chiffrierung verschlüsselt. Die
Blockstruktur dient lediglich der besseren Lesbarkeit.

\subsection*{Aufgabe 1}

Bestimmen Sie eine mögliche Periodenlänge~$d$
\begin{enumerate}
 \item mit Hilfe des Kasiski-Tests.
 \item mit Hilfe des Friedman-Tests.
 \item Formulieren Sie eine Hypothese für $d$.
\end{enumerate}

\subsection*{Aufgabe 2}

Bestimmen Sie gemäß $d$ eine Häufigkeitsverteilung und leiten Sie darauf ein
Schlüsselwort ab.

\subsection*{Aufgabe 3}

Bestimmen Sie den Klartext.

\begin{verbatim}
  UEQPC  VCKAH  VNRZU  RNLAO  KIRVG  JTDVR  VRICV  IDLMY
  IYSBC  COJQS  ZNYMB  VDLOK  FSLMW  EFRZA  VIQMF  JTDIH
  CIFPS  EBXMF  FTDMH  ZGNMW  KAXAU  VUHJH  NUULS  VSJIP
  JCKTI  VSVMZ  JENZS  KAHZS  UIHQV  IBXMF  FIPLC  XEQXO
  CAVBV  RTWMB  LNGNI  VRLPF  VTDMH  ZGNMW  KRXVR  QEKVR
  LKDBS  EIPUC  EAWJS  BAPMB  VSZCF  UEGIT  LEUOS  JOUOH
  UAVAG  ZEZIS  YRHVR  ZHUMF  RREMW  KNLKV  KGHAH  FEUBK
  LRGMB  JIHLI  IFWMB  ZHUMP  LEUWG  RBHZO  LCKVW  THWDS
  ILDAG  VNEMJ  FRVQS  VIQMU  VSWMZ  CTHII  WGDJS  XEOWS
  JTKIH  KEQ
\end{verbatim}

\chapter{Lösungen}
\section{Blatt 1}
\subsection*{Aufgabe 1}
\begin{enumerate}[a)]
 \item Kasiski-Test (Wiederholung von Zeichenketten länger als 2), Beispiele:
  \begin{tabular}{l|l}
    KFEIUERX & $50 = 2\cdot 5\cdot 5$\\
    TIB & $138 = 2\cdot3\cdot23$\\
    IZO
       LAH
       GYR
  \end{tabular}

 \item Friedman-Test: $I(c) = 0,0483$ und $d\approx3\mathord{,}93$.

 \item Wir entscheiden uns für $d=5$.
\end{enumerate}

\subsection*{Aufgabe 2}
Schlüsselwort "`bauer"'.

Es bleibt: suchen 5 Caesar-Chiffren
1. Spalte: B für E, d.\,h. B für A (Verschiebung 1)\\
2. Spalte: A für E, d.\,h. A für A (Verschiebung 0)\\
3. Spalte: U für E, d.\,h. U für A (Verschiebung 3)\\
4. Spalte: E für E, d.\,h. E für A (Verschiebung 4)\\
5. Spalte: R für E, d.\,h. R für A (Verschiebung 13)\\

\todo{Ich bin mir nicht mehr sicher, ob das so richtig war. Bitte gegenprüfen.}

\subsection*{Aufgabe 3}
Es mag ueberraschen, dass man von einem vorgelegten monoalphabetisch
chiffrierten Text leichter sagen kann, ob er englisch oder franzoesisch ist
als ihn zu entschluesseln. Dies gilt natuerlich auch fuer Klartext. Es gibt
ein einfaches Verfahren genuegend langen Klartext auf Zugehoerigkeit zu einer
bekannten Sprache zu untersuchen ohne seine Syntax und Semantik zu betrachten.

\section{Blatt 2}
\subsection*{Aufgabe 1}

\begin{enumerate}
 \item
  $m=WASSER$\\
  $22~0, 18~18, 4~17$\\
  $w_{1} = v_{1}\cdot K = 24~14$\\
  $w_{2} = v_{2}\cdot K = 8~16$\\
  $w_{3} = v_{3}\cdot K = 9~18$\\
  $c=YOIJS$

 \item Die inverse Matrix zu $K$ kann man entweder mit der Formel aus
  \autoref{sec:restklassen} oder durch simultane Umformung einer
  Einheitsmatrix bei der Umformung von $K$ in eine Einheitsmatrix bestimmen.

  \begin{minipage}{.45\linewidth}
    \begin{align*}
      \begin{gmatrix}[p]
        7& 3\\ 5& 8
      \end{gmatrix} &
         \begin{gmatrix}[p]
           1& 0\\ 0&1
           \rowops
           \mult{0}{\cdot 15}
         \end{gmatrix}\\
      \begin{gmatrix}[p]
        1& 19\\ 5& 8
      \end{gmatrix} &
         \begin{gmatrix}[p]
           15& 0\\ 0&1
           \rowops
           \add[21]{0}{1}
         \end{gmatrix}\\
      \begin{gmatrix}[p]
        1& 19\\ 0& 17
      \end{gmatrix} &
         \begin{gmatrix}[p]
           15& 0\\ 3&1
           \rowops
           \mult{1}{\cdot 23}
         \end{gmatrix}\\
      \begin{gmatrix}[p]
        1& 19\\ 0& 1
      \end{gmatrix} &
         \begin{gmatrix}[p]
           15& 0\\ 17& 23
           \rowops
           \add[7]{1}{0}
         \end{gmatrix}\\
      \begin{gmatrix}[p]
        1& 0\\ 0& 1
      \end{gmatrix} &
         \begin{gmatrix}[p]
           4& 5\\ 17& 23
         \end{gmatrix}
    \end{align*}
  \end{minipage}%
  \begin{minipage}{.55\linewidth}
    Mit etwas Glück fällt auf, dass 7 eine Einheit von $\Z_{26}$ ist und man so
    leicht in der oberen linken Ecke eine 1 erzeigen kann. Das Inverse zu 7 ist
    15, daher wird die erste Zeile mit 15 durchmultipliziert.

    Dann ist es leicht in der unteren Zeile aus dem linken Element eine 0 zu
    machen: $0 = 21\cdot 1+5\pmod{26}$.

    17 ist wieder eine Einheit, so dass eine 1 durch Multiplikation mit 23
    erzeugt werden kann: $23\cdot17\pmod{26} = 1$.

    Aus der 19 lässt sich jetzt wiederrum sehr leicht eine 0 erzeugen:
    $0=1\cdot7+19\pmod{26}$.
  \end{minipage}

  \begin{gather*}
    \det K = 7\cdot8 - 3\cdot5 \pmod{26} = 41\pmod{26} = 15 \\
    \det(K^{-1}) = 7
  \end{gather*}
\end{enumerate}

\subsection*{Aufgabe 2}
hund = 7~20~13~3\\
AFFE = 0~5~5~4

\begin{gather*}
  M \cdot \begin{pmatrix}7& 13\\20 & 3\end{pmatrix} =
     \begin{pmatrix}
       0& 5\\
       20& 3
     \end{pmatrix}\\
  M =
     \begin{pmatrix}
       15& 13\\4& 9
     \end{pmatrix} \cdot
     \begin{pmatrix}
       0& 5\\
       20& 3
     \end{pmatrix} =
     \begin{pmatrix}
       20& 19\\13& 23
     \end{pmatrix}
\end{gather*}

\subsection*{Aufgabe 3}
Diese Aufgabe war eigentlich nur ein Test, ob man in der Vorlesung aufgepasst
hat, weil die Antwort bereits in \autoref{sec:tausch} gegeben wurde.

Ob die Abbildung bijektiv ist oder nicht, hängt nicht von $b$ ab.
Es hängt allein von $a$ ab, ob zwei Zeichen~$x_{1},x_{2}$ durch das gleiche
Zeichen ($E(x_{1}) = E(x_{2})$) verschlüsselt werden.
\begin{gather*}
  ax_{1} + b \equiv_{k} ax_{2}+ b \quad\Leftrightarrow\quad
     ax_{1} \equiv_{k} ax_{2}
\end{gather*}

Haben $k$ und $a$ einen gemeinsamen Teiler~$\ggT(k,a)\ne1$, so ist die
Entschlüsselung der Null beispielsweise nicht mehr eindeutig, denn $E(0) =
0\cdot a = 0$ und
\begin{gather*}
  E\Bigl(\frac{k}{\ggT(k,a)}\Bigr) = \frac{k}{\ggT(k,a)} \cdot a \pmod{k}
     = k\cdot \underbrace{\frac{a}{\ggT(k,a)}}_{\in\Z_{k}, > 1} \pmod{k}
     = 0
\end{gather*}

Also muss $a$ teilerfremd zu $k$ sein, damit alle $\Phi_{a,b}$ bijektiv sind.
\help{Warum ist das hinreichend?}

\section{Blatt 3}

\subsection*{Aufgab 3}
Den hoechsten Organisationsstand erfuhr die Kryptologie in Venedig, wo sie in
Form einer staatlichen Buerotaetigkeit ausgeuebt wurde. Es gab
Schluesselsekretaere die ihr Buero im Dogenpalast hatten und fuer ihre
Taetigkeit rund zehn Dukaten im Monat bekamen. Es wurde dafuer gesorgt, dass
sie waehrend ihrer Arbeit nicht gestoert wurden. Sie durften ihre Bueros aber
auch nicht verlassen, bevor sie eine gestellte Aufgabe geloest hatten.

\clearpage
\pdfbookmark[0]{Index}{index}
\printindex

\end{document}
