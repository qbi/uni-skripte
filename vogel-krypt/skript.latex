% ToDo:
%   + Es sollte Befehle für Klartext und Chiffretext geben, damit die Texte im
%     gesamten Dokument gleich aussehen. z.\,B. \klartext=\texttt\uppercase
%     und \chiffretext=\texttt\lowercase; \MakeUppercase \MakeLowercase
%     \bstv = Buchstabe verschlüsselt
%     \bstu = Buchstabe unverschlüsselt
%     \textv = Text verschlüsselt
%     \textu = Text unverschlüsselt
%     \schlsl = Schlüssel

% Einige zusätzliche Informationen für rubber
%  rubber erkennt nicht, dass die Datei weg kann, daher sagen wir es ihm
% rubber: clean $base.thm
%  rubber soll nach Änderungen an der Datei nochmal bauen
% rubber: watch $base.thm
% rubber: makeidx.tool      xindy
% rubber: makeidx.language  german-din
% rubber: makeidx.modules   indexstyle.xdy
%
% scrreprt trifft am Besten die Bedürfnisse eines Skripts, das ganze wird
% zweiseitig (twoside), d.h. es wird zwischen linker und rechter Seite
% unterschieden, und wir verwenden zwischen den Absätzen einen Abstand
% von einer halben Zeile (halfparskip) und dafür keinen Absatzeinzug,
% wobei die letzte Zeile eines Absatzes zu min. 1/4 leer ist.

\documentclass[halfparskip*,german,draft,twoside]{scrreprt}

\usepackage[l2tabu]{nag}  % nag überprüft den Text auf verältete Befehle
                          % oder solche, die man nicht in LaTeX verwenden
                          % soll -- l2tabu-Checker in LaTeX
\usepackage{ifthen}
\usepackage{makeidx}
\usepackage[final]{graphicx}  % Für Grafiken
\usepackage{color}
\usepackage[draft=false,colorlinks,bookmarksnumbered,linkcolor=blue,breaklinks]{hyperref}

\usepackage[latin1]{inputenc}
\usepackage{ngerman}

\usepackage{lmodern}		% Latin Modern
\usepackage[T1]{fontenc}        % T1-Schriften notwendig für PDFs
\usepackage{textcomp}           % wird benötigt, damit der \textbullet
                                % für itemize in lmodern gefunden wird.

\usepackage[intlimits,leqno]{amsmath}
\usepackage[all,warning]{onlyamsmath}  % warnt bei Verwendung von nicht
                                       % amsmath-Umgebungen z.\,B. $$...$$
\usepackage{amssymb}     % wird für \R, \C,... gebraucht
\usepackage{fixmath}     % ISO-konforme griech. Buchstaben

\usepackage[amsmath,thmmarks,hyperref]{ntheorem} % für die Theorem-Umgebungen
                                                 % (satz, defini, bemerk)
\usepackage{paralist}    % besseres enumerate und itemize und neue
                         % compactenum/compactitem; s. texdoc paralist

\usepackage{svn}         % Zum Auswerten und ordentlichen Darstellen der
                         % SVN-Schlüsselwörter (s. vor \begin{document})
                         % dafür muss in SVN noch das Flag svn:keywords
                         % auf "LastChangedRevision LastChangedDate"
                         % gesetzt werden
\usepackage{ifpdf}       % Erkennung, ob PDF generiert wird; nützlich zur
                         % Unterscheidung bei Grafiken \input{XYZ.pdf_t}
\usepackage{ellipsis}    % Korrektur für \dots
\usepackage{fixltx2e}
\usepackage[final]{microtype} % Verbesserung der Typographie
\usepackage{nicefrac}
\usepackage{gauss}
\usepackage{fancyvrb}

% Damit auch die Zeichen im Mathemode in Überschriften fett sind
% <news:lzfyyvx3pt.fsf@tfkp12.physik.uni-erlangen.de>
\addtokomafont{sectioning}{\boldmath}

% nach dem Theoremkopf wird ein Zeilenumbruch eingefügt, die Schrift des
% Körpers ist normal und der Kopf wird fett gesetzt
\theoremstyle{break}
\theorembodyfont{\normalfont}
\theoremheaderfont{\normalfont\bfseries}
\theoremnumbering{arabic}

% Die folgenden Umgebungen werden einzeln nummeriert und am Ende jedes
% Kapitels zurückgesetzt
\newtheorem{bemerk}{Bemerkung}[chapter]
\newtheorem{defini}{Definition}[chapter]
\newtheorem{bsp}{Beispiel}[chapter]
\newtheorem{satz}{Satz}[chapter]
\newtheorem{lemma}{Lemma}[chapter]

% Die folgenden Theoremumgebungen bekommen keine Nummer
\theoremstyle{nonumberbreak}

\newtheorem{dogma}{Dogma}[chapter]
\newtheorem{fakt}{Fakt}[chapter]

\theoremheaderfont{\scshape}
\theorembodyfont{\normalfont}
% Das Zeichen am Ende eines Beweises
\theoremsymbol{\ensuremath{_\blacksquare}}
% \theoremsymbol{q.\,e.\,d.}
\newtheorem{proof}{Beweis:}

% Hier die Definition, wie \autoref die Umgebungen nennen soll, die mit
% \newtheorem definiert wurden
\newcommand*{\bemerkautorefname}{Bemerkung}
\newcommand*{\definiautorefname}{Definition}
\newcommand*{\bspautorefname}{Beispiel}
\newcommand*{\satzautorefname}{Satz}
\newcommand*{\lemmaautorefname}{Lemma}
\newcommand*{\faktautorefname}{Fakt}
% Zwischen Unter- und Unterunterabschnitten sollte nicht unterschieden
% werden.
\renewcommand*{\subsectionautorefname}{Abschnitt}
\renewcommand*{\subsubsectionautorefname}{Abschnitt}

\pagestyle{headings}

\newcommand*{\N}{\mathbb{N}}      % natürliche Zahlen
\newcommand*{\Z}{\mathbb{Z}}      % ganze Zahlen
\newcommand*{\F}{\mathbb{F}}      % endliche Ringe
\newcommand*{\FP}{\mathrm{FP}}    % Funktionen, die in Polynomialzeit
                                  % berechnet werden können

% Wenn irgendwo Unklarheiten zum Inhalt im Skript auftreten, können sie
% einfach mit \help{Ich verstehe das nicht} hervorgehoben werden. Dies
% macht es leichter sie alle zu finden und auch ganz einfach
% auszublenden, indem man den Befehl einfach leer definiert
\newcommand*{\help}[1]{\textcolor{green}{help: #1}}

% \todo ist das gleiche wie \help nur für offene Aufgaben
\newcommand*{\todo}[1]{\textcolor{red}{todo: #1}}

% Um wichtige Begriffe im Text überall gleich vorzuheben (gleiches
% Markup), sollte dieser Befehl verwendet werden. Das Argument wird
% automatisch als Indexeintrag verwendet. Dieser kann aber auch als
% optionales Argument selbst bestimmt werden.
\newcommand*{\highl}[2][]{\textbf{\boldmath{#2}}%
  \ifthenelse{\equal{#1}{}}{\index{#2}}{\index{#1}}%
}

% Definition für Xindy für die Trennung der einzelnen Abschnitte im
% Index. siehe auch die Datei indexstyle.xdy
\newcommand*{\indexsection}{\minisec}

% Um sicherzustellen, dass jeder Betrag-/jede Norm links und rechts die
% Striche bekommt, sind diese Befehle da. Damit kann man nicht die
% rechten Striche vergessen und es wird etwas übersichtlicher. (Vorschlag
% ist aus amsldoc) \abs[\big]{\abs{a}-\abs{b}} \leq \abs{a+b}
\newcommand*{\abs}[2][]{#1\lvert#2#1\rvert}
\newcommand*{\floor}[2][]{#1\lfloor#2#1\rfloor}

% Diese Befehle sind dafür gedacht, dass die Symbole für "genau dann wenn"
% im ganzen Dokument gleich aussehen. Außerdem erlaubt es eine schnelle
% Veränderung aller Stellen, falls der Prof. doch nicht mehr gdw nimmt,
% sondern \Leftrightarrow.
\newcommand*{\gdw}{\ifthenelse{\boolean{mmode}}%
			       {\mspace{8mu}gdw\mspace{8mu}}%
			       {$gdw$\xspace}}
\newcommand*{\gdwdef}{\ifthenelse{\boolean{mmode}}%
			       {\mspace{8mu}gdw_{def}\mspace{8mu}}%
			       {$gdw_{def}$\xspace}}

% Das original Epsilon sieht nicht so toll aus
\renewcommand*{\epsilon}{\varepsilon}
% ... und mancheinem gefällt auch das Phi nicht
\renewcommand*{\phi}{\varphi}
\renewcommand*{\tilde}{\widetilde}

% rubber: depend fmc.mp
\iffalse\includegraphics{fmc.1}\fi
% rubber: clean fmc.1 fmc.2 fmc.3 fmc.4 fmc.5 fmc.6 fmc.7 fmc.8 fmc.9 fmc.10
% rubber: clean fmc.11 fmc.12 fmc.13 fmc.14 fmc.15 fmc.16 fmc.17 fmc.18 fmc.19
% rubber: clean fmc.20 fmc.21 fmc.22 fmc.23 fmc.24 fmc.25 fmc.26 fmc.log
\newcommand*{\fmc}[1]{\startfmc#1\Endfmc}
\newcounter{Zeichen}
\newcommand*{\Endfmc}{}
\makeatletter
\newcommand*{\startfmc}[1]{%
  \ifx#1\Endfmc%
  \else%
    \setcounter{Zeichen}{\the\lccode`#1}%
    \ifthenelse{\theZeichen < 97 \OR \theZeichen>122}{#1}%
               {\addtocounter{Zeichen}{-96}%
                 \includegraphics{fmc.\theZeichen}%
               }%
    \expandafter\startfmc%
  \fi%
}
\makeatother

% Dr. Vogel gebraucht gern das Zeichen |->> für bijektive Abbildungen.
% <news:ehom5s$bk9$1@news.BelWue.DE> <news:ehqi2q$bb4$02$1@news.t-online.com>
\makeatletter
\newcommand*{\mapstoto}{%
  \mathrel{%
    \ifpdf
      \pdfliteral direct{%
        /Span<</ActualText<FEFF2905>>>BDC%
      }%
    \fi
    \mathrel{\mapstochar\twoheadrightarrow}%
    \ifpdf
      \pdfliteral direct{EMC}%
    \fi
  }%
}
\makeatother

\makeindex

\SVN $LastChangedRevision$
\SVN $LastChangedDate$

\newcounter{cnt}
\setcounter{cnt}{1}
\whiledo{\thecnt < 27}{%
  \DeclareGraphicsRule{.\thecnt}{\ifpdf mps\else eps\fi}{*}{}%
  \stepcounter{cnt}%
}

\DeclareMathOperator{\sgn}{sgn}          % Signum/Vorzeichen
\DeclareMathOperator{\ggT}{ggT}          % größter gemeinsamer Teiler
\DeclareMathOperator{\card}{card}        % Kardinalität

\begin{document}

\title{Kryptologie -- von einer Geheimwissenschaft zu einer Wissenschaft
  von den Geheimnissen}
\author{Dr.\, Jörg Vogel}
\date{WS 2006/07}
\maketitle

\clearpage
\chapter*{Vorwort}

\begin{itshape}
  Dieses Dokument wurde als Skript für die auf der
  Titelseite genannte Vorlesung erstellt und wird jetzt im Rahmen des
  Projekts
  "`\href{http://www.minet.uni-jena.de/~joergs/skripte/}
  {Vorlesungsskripte der Fakultät für Mathematik}
  \href{http://www.minet.uni-jena.de/~joergs/skripte/}{und Informatik}"'
  weiter betreut. Das
  Dokument wurde nach bestem Wissen und Gewissen angefertigt. Denoch
  garantiert weder der auf der Titelseite genannte Dozent, die Personen,
  die an dem Dokument mitgewirkt haben, noch die
  Mitglieder des Projekts für dessen Fehlerfreiheit. Für etwaige Fehler
  und dessen Folgen wird von keiner der genannten Personen eine Haftung
  übernommen. Es steht jeder Person frei, dieses Dokument zu lesen, zu
  verändern oder auf anderen Medien verfügbar zu machen, solange ein
  Verweis auf die Internetadresse des Projekts
  \url{http://www.minet.uni-jena.de/~joergs/skripte/}
  enthalten ist.

  Diese Ausgabe trägt die Versionsnummer~\SVNLastChangedRevision{} und ist vom
  \SVNDate{}. Eine neue Ausgabe könnte auf der Webseite des Projekts verfügbar
  sein.

  Jeder ist dazu aufgerufen Verbesserungen, Erweiterungen und
  Fehlerkorrekturen für das Skript einzureichen bzw. zu melden oder diese
  selbst einzupflegen -- einfach eine E-Mail an die
  \href{mailto:skripte@listserv.uni-jena.de}{Mailingliste
  \texttt{<skripte@listserv.uni-jena.de>}} senden. Weitere Informationen
  sind unter der oben genannten Internetadresse verfügbar.

  Hiermit möchten wir allen Personen, die an diesem Skript mitgewirkt
  haben, vielmals danken:
  \begin{itemize}
   \item \href{mailto:joerg@alea.gnuu.de}{Jörg Sommer
    \texttt{<joerg@alea.gnuu.de>}} (2006)
   \item \href{mailto:jens@kubieziel.de}{Jens Kubieziel
    \texttt{<jens@kubieziel.de>}} (2006)
   \item Michael Preis (2006)
  \end{itemize}
\end{itshape}

\clearpage
\pdfbookmark[0]{Inhaltsverzeichnis}{inhaltsverzeichnis}
\tableofcontents

\clearpage
\pdfbookmark[0]{Auflistung der Sätze}{theoremlist}
\chapter*{Auflistung der Theoreme}

\pdfbookmark[1]{Sätze}{satzlist}
\section*{Sätze}
\theoremlisttype{optname}
\listtheorems{satz}

\pdfbookmark[1]{Definitionen und Festlegungen}{definilist}
\section*{Definitionen und Festlegungen}
% \theoremlisttype{all}
\listtheorems{defini,festl}

\chapter{Einführung in die Kryptologie}

\begin{defini}[Kryptologie]
  \highl{Kryptologie} ist die Wissenschaft von der sicheren Übertragung
  (und Speicherung) von Nachrichten.

  Dabei unterscheidet man zwei Teilgebiete:
  \begin{itemize}
   \item die \highl{Kryptographie} als die Kunst des Verschlüsselns und
   \item die \highl{Kryptoanalyse} als die Kunst des Codebrechens.
  \end{itemize}
\end{defini}

Die Übertragung der Nachricht erfolgt über \highl{Kanäle}, wie z.\,B. Boten,
Kupferleitungen, Glasfasern oder drahtlose Verbindungen. Dabei kann es zu
verschiedenen Beeinträchtigungen kommen:
\begin{itemize}
 \item zufällige Störungen -- der Boote stürzt in eine Felsspalte
 \item systematische (physikalisch bedingte) Störungen --
 \item passive Beeinträchtigungen -- Abhören von Telefongesprächen,
  Auslesen von Speichermedien
 \item aktive Beeinträchtigungen -- fälschen von Nachrichten und Daten
\end{itemize}
Mit den ersten beiden Punkten beschäftigt sich die \highl{Kodierungstheorie}. Die
passiven und aktiven Beeinträchtigungen sind Gegenstand der Kryptologie.

Aus diesen Beeinträchtigungen ergeben sich Anforderungen an kryptologische
Verfahren:
\begin{itemize}
 \item \highl{Geheimhaltung} -- Lesen der Nachricht für Unbefugte möglichst
  schwierig zu machen
 \item \highl{Authentifizierung} -- Identitätsnachweis des Senders; Empfänger
  weiß, dass die Nachricht nicht von einem Unbefugten stammt
 \item \highl{Integrität} -- Nachricht wurde während der Übertragung nicht
  verändert
 \item \highl{Verbindlichkeit} -- Sender kann nicht leugnen, dass die Nachricht
  von ihm stammt
\end{itemize}

Im Laufe der Zeit hat sich das Anwendungsgebiet für Kryptologie gewandelt.
Früher wurde sie vorwiegend zur Geheimhaltung z.\,B. militärischer Anwendungen
eingesetzt, wärend heute durch den enormen Zuwachs der Kommunikation in
offenen Netzwerken Kryptologie auch verstärkt im zivilen Bereich eingesetzt
wird.

\section{Grundbegriffe}

Der \highl{Sender} --~in der Kryptologie wird dieser mit \highl{Alice}
bezeichnet~-- verschlüsselt seine \highl{Nachricht}\footnote{Nachricht: auch
\highl{Klartext} oder \highl{plain text} genannt} mit Hilfe eines
\highl[Schlüssel]{Schlüssels} unter Verwendung eines
\highl[Verschlüsselungsverfahren]{Verschlüsselungsverfahrens}%
\footnote{Verschlüsselungsverfahren: auch als \highl{Chiffrierung} oder
  \highl{encryption} bezeichnet} und erhält so einen \highl{Geheimtext}%
\footnote{Geheimtext: auch \highl{Chiffretext} oder \highl{Kryptogramm}
  genannt} für die Nachricht. Diesen sendet er dem Empfänger --~in der
Kryptologie wird dieser mit \highl{Bob} bezeichnet~--, der durch Anwendung
eines \highl[Entschlüsselungsverfahren]{Entschlüsselungsverfahrens}%
\footnote{Entschlüsselungsverfahren: auch als \highl{Dechiffrierung} oder
  \highl{decryption} bezeichnet} wieder die Nachricht rekonstruieren kann.
Die Übertragung des Geheimtexts und die damit verbundenen Probleme wie
Fehlererkennung und -korrektur sind nicht Gegenstand der Kryptologie. Mit
dieser Thematik beschäftigt sich die Codierungstheorie.

\begin{defini}[Kryptosystem]
  Ein \highl{Kryptosystem}~$\mathcal{S}$ ist ein Fünftupel
  $\mathcal{S}=(\mathcal{M}, \mathcal{C}, \mathcal{K}, E, D)$ bestehend aus:
  \begin{itemize}
   \item einer Menge von Nachrichten, die als \highl{Klartextraum}~$\mathcal{M}$
    ($\subseteq\Sigma^{\ast}$) bezeichnet wird; ein Element dieser Menge ist
    eine \highl{Nachricht}~$m\in\mathcal{M}$.

   \item dem \highl{Geheimtextraum}~$\mathcal{C}$ ($\subseteq\Gamma^{\ast}$),
    der Menge aller der verschlüsselten Botschaften~$c\in\mathcal{C}$,

   \item dem \highl{Schlüsselraum} $\mathcal{K}$, wobei jeder
    \highl{Schlüssel} $k\in\mathcal{K}$ ein Paar $k=(k_{e}, k_{d})$ ist, von
    dem $k_{e}$ zur Verschlüsselung und $k_{d}$ zur Entschlüsselung verwendet
    wird.

   \item einem \highl{Verschlüsselungsalgorithmus} $E\colon\mathcal{M}\times
    \mathcal{K}\rightarrow\mathcal{C}$ für den gilt $E(m, k_{e}) = c$,
    wobei für zwei unterschiedliche Nachrichten $m_{1}$ und $m_{2}$ gilt:
    $E(m_{1}, k_{e}) \ne E(m_{2}, k_{e})$ und

   \item einem \highl{Entschlüsselungsalgorithmus} $D\colon \mathcal{C}\times
    \mathcal{K}\rightarrow\mathcal{M}$ mit $D(c, k_{d}) = m$.
  \end{itemize}
\end{defini}

\begin{defini}
  Ein Kryptosystem $\mathcal{S}$ heißt \highl{symmetrisch}, falls $k_{e}=
  k_{d}$ (bzw. $k_{d}$ sich "`leicht"' (polynomiell) aus $k_{e}$ berechnen lässt).

  Ein Kryptosystem $\mathcal{S}$ heißt \highl{asymmetrisch}, falls die
  Kenntnis von $k_{e}$ praktisch nichts über $k_{d}$ aussagt.
\end{defini}

Aus diesen Festlegungen ergeben sich folgende Konsequenzen für die
Kommunikation zwischen Alice und Bob:
\begin{enumerate}
 \item Vor der Übertragung müssen sich beide über das
  Verfahren einigen.
 \item Viele Schlüssel sind eine notwendige Vorraussetzung (großer Schlüsselraum) für die
  Sicherheit eines Verfahrens.
 \item Vor der Übertragung müssen sie sich auf ein
  Schlüsselpaar $k=(k_{e},k_{d})$ einigen.
 \item Der Schlüssel $k_{d}$ muss geheim gehalten werden.
\end{enumerate}

Da für den Austausch des Schlüssels zwischen Alice und Bob eine sichere
Übertragung --~sozusagen eine verschlüsselte Verbindung~-- notwendig ist,
stellt sich die Frage, warum die beiden nicht gleich die Nachricht über diese
sichere Verbindung übertragen.
\begin{itemize}
 \item Im Allgemeinen ist die Nachricht wesentlich länger als der Schlüssel,
  d.\,h. der Schlüsselaustausch kann über andere (langsamere, aber sicherere)
  Kanäle als der Nachrichtenaustausch erfolgen. Alice lässt Bob das Kennwort
  durch einen Boten zukommen und der Austausch der Nachricht geschieht dann
  per E-Mail.

 \item Der Zeitpunkt der Schlüsselübergabe ist frei wählbar. Es können also bei
  einem persönlichen Treffen mehrere Schlüssel für späterere Verbindungen
  vereinbart werden.

 \item Mit demselben Schlüssel lassen sich mehrere Nachrichten verschlüsseln.
\end{itemize}

\begin{defini}[Kerkhoff'sche Prinzip]
  Das \highl{Kerkhoff'sche Prinzip} besagt, dass die \highl{Sicherheit} eines
  Kryptosystems nur von der Geheimhaltung des Schlüssels jedoch nicht von der
  Geheimhaltung des Algorithmus' abhängt.
\end{defini}

% 18.10.2006

\begin{bsp}[praktische Kryptographie]
  Der
  \href{http://de.wikipedia.org/wiki/Freimaurer-Alphabet}{\highl{Freimaurercode}}
  (zweite Zeile) arbeitet ohne Schlüssel. Jeder Buchstabe des Alphabets wird durch
  ein bestimmtes Geheimzeichen ersetzt. Damit ist der Freimaurercode kein
  Kryptosystem, da das Kerkhoff'sche Pinzip verletzt ist: Die Sicherheit
  des Kryptosystems hängt von der Geheimhaltung des Algorithmus' ab.
  \begin{center}\ttfamily\large
    dieser satz ist geheim\\
    \fmc{dieser~satz~ist~geheim}\\
    UZVJVI JRKQ ZJK XVYVZD\\
    TFZZGR EDFY ABX IFFHXY
  \end{center}

  Beim \highl{Caesarcode} (dritte Zeile) wird jeder Buchstabe des Alphabets für sich
  durch den Buchstaben, der $x$ Positionen weiter hinten steht.
  $x\in\{1,2,\dotsc,25\} = \mathcal{K}$ ist der Schlüsel dieses
  Kryptosystems -- im obigen Beispiel ist $x=17$. Jedoch ist diese Art der
  Verschlüsselung nicht sicher. Dazu später mehr.

  Beim \highl{One-Time-Pad} (vierte Zeile) ist ähnlich dem Caesarcode, jedoch
  wird hierbei (unabhängig und gleichverteilt) für jedes einzelne Zeichen der
  Nachricht eine Position $x\in\{0,1,\dotsc,25\}$ gewählt, um die dieses
  verschoben wird. Der Schlüssel für eine Nachricht $m=(m_{1},m_{2},\dotsc,
  m_{n})$ ist also ein Tupel $c=(x_{1},x_{2},\dotsc, x_{n})$ der Länge~$n$.
  Dieses Kryptosystem schützt sich nicht nur durch den großen Schlüsselraum
  $26^{n}$, sondern auch dadurch, dass jeder beliebige Text mit dem geeigneten
  Schlüssel erzeugt werden kann.
\end{bsp}

Zur Einstufung einer \highl{Kryptoanalyse} trifft man die folgende qualitative
Unterscheidungen:
\begin{itemize}
  \item \highl{vollständiges Aufbrechen}\footnote{engl. total break} heißt, dass der Schlüssel $k_{d}$
  entdeckt wird, woraufhin jede Nachricht~$m$, die mit $k_{e}$ verschlüsselt
  wird, entschlüsselt werden kann.

 \item \highl[Deduktion!global]{globale Deduktion}\footnote{engl. global
   deduction} bedeutet, dass ohne
  Kenntniss von $k_{d}$ eine zu $D(\_, k_{d})$ äquivalente Übersetzung
  gefunden wird.

 \item Als \highl[Deduktion!lokal]{lokale Deduktion}\footnote{engl. instance or
   local deduction} bezeichnet man das Finden
  eines Klartextes für einen einzelnen Chiffretext.
\item \highl{Informationsdeduktion}\footnote{information deduction} bedeutet,
  dass einige Informationen über den Schlüssel oder den Klartext gewonnen werden
  können.
\end{itemize}

Ebenso gibt es eine Unterscheidung der verschiedenen Arten eines
\highl[Angriff]{Angriffs} auf ein Kryptosystem:
\begin{description}
 \item[Cyphertext-Only-Attack:] Der Kryptoanalytiker verfügt über eine
  gewisse Menge von Geheimtexten.

 \item[Known-Plaintext-Attack:] Für einen gewissen Chiffretext ist der
  Klartext bekannt.

 \item[Chosen-Plaintext-Attack:] Für einen beliebigen Klartext ist es
  möglich, sich den zugehörigen Chiffretext zu besorgen. (Typisch für
  Public-Key-Verfahren)

  \item[Adaptive-chosen-plaintext-Attack] Spezialfall der obigen
  Attacke. Hier wählt der Kryptoanalytiker einen Klartext basierend
  auf dem Ergebnis der vorigen Verschlüsselung.

  \item[Chosen-Ciphertext-Attack] Verschiedene Chiffrate können
  entschlüsselt werden und es besteht Zugriff zum entschlüsselten Text.

  \item[Chosen-Key-Attack] Man hat Wissen über die Beziehungen
  verschiedener Schlüssel untereinander (i.\,d.\,R. nicht praktisch
  relevant)

 \item[Rubber-Hose-Cryptanalysis] Angriff durch Gewalt/Erpressung/Entführung

 \item[Brute-Force-Attack:] Alle möglichen Schlüssel austesten. Dieses
  Verfahren sollte das effektivste sein.
\end{description}

Ebenso wie Sender und Empfänger durch spezielle Namen in der Krypologie
gekennzeichnet werden, verwendet man auch für einen \highl{Angreifer} einen
speziellen Namen: \highl{Eve} heißt der Angreifer, der jedwede KOmmunikation
mitlesen kann und mit \highl{Mallory} bezeichnet man den Angreifer, der auch
Daten verändern kann.

Abhängig von der \highl{Sicherheit} des Ver-/Entschlüsselungsverfahrens kann
man Kryptosysteme in die Kategorien "`uneingeschränkt sicher"' (z.\,B.
One-Time-Pad), "`praktisch sicher"' (in praktikabler Zeit keine Lösung; die
Tageszeitung von Morgen erst nächste Woche entschlüsseln) und "`unsicher"'
(z.\,B. Caesarcode) einteilen.

Derzeit ist das One-Time-Pad das einzige bekannte, uneingeschränkt sichere
Kryptoverfahren. In der Praxis findet es hauptsächlich im militärischen Bereich
und in hochsicheren Umgebungen Anwendung.

Alle weiteren Kryptosysteme sind mit einer Ciphertext-Only-Attacke angreifbar.
Man probiert einfach jeden möglichen Schlüssel und prüft, ob der resultierende
Klartext eine Bedeutung hat. Eine derartige Attacke nennt man \highl{Brute
Force}, da diese nur mit roher Gewalt (Durchtesten aller Kombinationen)
funktioniert.

\subsection{Beispiel einer praktischen Kryptoanalyse}
Bedeuten "`viele"' Schlüssel "`hohe"' Sicherheit? \textit{Ansatz}:
Anstelle der Verschiebung der Buchstaben (beim Caesarcode) betrachten wir
eine Permutation der Buchstaben. -- Diese Zuordnung nennt man
\highl{monoalphabetisch}: Jedem Buchstaben des Klartexts wird ein
Zeichen des Chiffretexts zugeordnet.

Die Klartextbuchstaben: a b c d \dots x y z\\
Permutation (der Schlüssel): V J C E \dots A H D

Wieviele Schlüssel gibt es? $26! = 403\,291\,461\,126\,605\,635\,584\,000\,000$

Trotz dieses großen Schlüsselraums ist es möglich die Verschlüsselung zu
brechen.

\highl{Häufigkeitsanalyse:}
\begin{enumerate}[1.\,{Schritt:}]
 \item Buchstaben zählen:
  \texttt{C}: 62-mal, \texttt{Z}: 31-mal, \texttt{T}: 29-mal, \texttt{A}:
  27-mal, \texttt{F}: 22-mal, \texttt{L}: 20-mal, \texttt{J}: 19-mal, \dots

  \begin{table}
    \centering
    \begin{tabular}{cc*{3}{||cc}}
      Bst. & Wsk. & Bst. & Wsk. & Bst. & Wsk. & Bst. & Wsk.\\
      \hline
      E & 17,40\,\% & D & 5,08\,\% & O & 2,51\,\% & V & 0,67\,\%\\
      N & 9,78\,\%  & H & 4,76\,\% & B & 1,89\,\% & ß & 0,31\,\%\\
      I & 7,55\,\%  & U & 4,35\,\% & W & 1,89\,\% & J & 0,27\,\%\\
      S & 7,27\,\%  & L & 3,44\,\% & F & 1,66\,\% & Y & 0,04\,\%\\
      R & 7,00\,\%  & C & 3,06\,\% & K & 1,21\,\% & X & 0,03\,\%\\
      A & 6,51\,\%  & G & 3,01\,\% & Z & 1,13\,\% & Q & 0,02\,\%\\
      T & 6,15\,\%  & M & 2,53\,\% & P & 0,79\,\% & \\
    \end{tabular}
    \parbox{12cm}{
      \caption{Häufigkeitsverteilung der Buchstaben der deutschen
        Sprache. Die Buchstaben ä, ö, ü wurden wie ae, oe, ue gezählt.
        \textit{Quelle:
        \href{http://de.wikipedia.org/wiki/Buchstabenh\%C3\%A4ufigkeit}%
             {Wikipedia}}}}
    \label{tab:buchswsk}
  \end{table}

 \item Häufige Buchstaben ersetzen: \texttt{C} entspricht
  \texttt{e}.

  Da die Zeichenfolge \texttt{ZZ} vorkommt, ist eine weiterer Ansatz,
  dass das \texttt{Z} dem \texttt{n} entspricht

  Aus den Teilen \texttt{CHZ} (\texttt{eHn}) und \texttt{CHZCZ}
  (\texttt{eHnen}) kann man schließen, dass das \texttt{H} dem \texttt{i}
  entspricht.

  Auffällig ist die Häufung des Wortes \texttt{CT} (\texttt{eT}). Dies
  könnte \texttt{er} oder \texttt{es} sein.

  Ebenso fällt das Wort \texttt{LCT} auf. Möglich: \texttt{der} oder
  \texttt{des}. Da "`der"' häufiger in deutschen Texten vorkommt,
  verwenden wir \texttt{r} für \texttt{T} und \texttt{d} für \texttt{L}.

 \item Lücken schließen:
  \begin{itemize}
   \item \texttt{iUn} ist sehr wahrscheinlich \texttt{ihn}; \texttt{U}
    entspricht \texttt{h}.

   \item \texttt{eJ} ist nicht \texttt{er} oder \texttt{ei} (da
    \texttt{r} und \texttt{i} schon vergeben), also \texttt{es};
    \texttt{J} entspricht \texttt{s}

   \item \texttt{dAJJ} ist \texttt{dass}; \texttt{A} ist \texttt{a}

   \item \texttt{UAFFe} ist \texttt{haFFe}, also \texttt{hatte};
    \texttt{F} ist \texttt{t}

   \item Erster Teilsatz: "`es hatte ein Wann einen eseN,"'; Aus dem
    Kontext folgt: \texttt{W} entspricht \texttt{m} und \texttt{N} ist
    \texttt{e}.

   \item weiter: "`der sDhOn LauGe Sahre die saeDVe"'; \texttt{D}
    entspricht \texttt{c}, \texttt{O} ist \texttt{o}, \texttt{G} ist
    \texttt{g} und \texttt{S} ist \texttt{j} und \texttt{V} ist \texttt{k}.
  \end{itemize}
\end{enumerate}

% 23. Okt. 2006

\section{Klassische symmetrische Verfahren}

symbolisch: Zwei identische (daher symmetrisch) Schlüssel -- einer beim
Empfänger, einer beim Sender --, die beide eine Schatzkiste öffnen.

2 Unterscheidungsmerkmale:
\begin{enumerate}
 \item \highl{Substitution} vs. \highl{Translation}
  \begin{description}
   \item[Substitution]
    \begin{itemize}
     \item jeder Buchstabe wird durch ein Geheimtextalphabet
      verschlüsselt.
     \item jeder Buchstabe an seinem Platz
    \end{itemize}

   \item[Translation]
    \begin{itemize}
     \item jeder Buchstabe seine Gestalt
     \item die Buchstaben ändern ihre Position
    \end{itemize}
  \end{description}

  heute: Verallgemeinerung durch Kombination beider "`Urformen"'.

 \item \highl{Stromchiffre} vs. \highl{Blockchiffre}
  \begin{description}
   \item[Stromchiffren]
    \begin{itemize}
     \item jeder Buchstabe wird einzeln für sich verschlüsselt

     \item häufig wird für eine Nachricht $m=m_{1}m_{2}\dotso m_{n}$ und
      einen Anfangsschlüssel $k$ ein "`Strom von Schlüsseln"'
      $k_{1},k_{2},\dotsc, k_{n}$ erzeugt.
    \end{itemize}

   \item[Blockchiffren]
    \begin{itemize}
     \item Aufteilung des Klartextes in (längere) Blöcke, die
      verschlüsselt werden
    \end{itemize}
  \end{description}
\end{enumerate}

\chapter{Substitionen}

Substitutionen werden unterschieden als:
\begin{enumerate}
 \item \highl{monoalphabetisch}: jeder Buchstabe des Klartextalphabets
  wird stets durch denselben Buchstaben des Geheimtextalphabets ersetzt

 \item \highl{polyalphabetisch} sonst
\end{enumerate}

\section{Monoalphabetische Substitutionen}

O.\,B.\,d.\,A. entspricht das Klartextalphabet $\Sigma$ dem Geheimtextalphabet $\Gamma$.
Wir legen uns weiter auf das Beispielalphabet $\{a,b,c,\dotsc,x,y,z\}$ fest
und schreiben es in der Form $X=\{0,1,2,\dotsc,\linebreak[1] 23,24,25\}$. Dann gilt:
$\abs{X} = 26$. Für $\abs{X}=n$ denken wir uns $X=\{0,1,2,\dotsc, n-2,\linebreak[1] n-1\}$.

\subsection{Verschlüsselungsverfahren}

Eine \highl{Verschlüssung} in diesem Rahmen ist eine Permution $\pi\colon X
\mapstoto X$ (Schlüssel). Aus einer Nachricht $m=m_{1}m_{2}\dotso m_{k}$ wird
der Geheimtext $c=\pi(m_{1})\pi(m_{2})\dotso \pi(m_{k})$. Es gibt hier $n!$
verschiedene Schlüssel, aber wir wissen bereits, dass dieses Verfahren
krypographisch auf Grund der \highl{Häufigkeitsverteilung} auch bei
\highl{Ciphertext-Only-Attakten} unsicher ist.

\subsection{Verschiebechiffre (Caesar)}

Die \highl{Verschiebechiffren} --~auch \highl{Caesar-Chiffre} genannt~-- sind
die einfachste Form der monoalphabetischen Substitution. Jeder Buchstabe wird
durch seinen $i$.~Nachfolger ersetzt, wobei man wieder bei A beginnt, wenn man
Z überschreitet.

Anschaulich kann man sich eine Verschlüsselungsvorschrift so vorstellen, dass
unter die Buchstaben~A bis~Z die Buchstaben beginnend mit dem $i$.~Buchstaben
bis~Z und weiter von A bis zum $(i-1)$.~Buchstaben stehen. Jeder Buchstabe des
Klartextes wird durch den Buchstaben, der unter ihm in der zweiten Zeile
steht, ersetzt.

Mathematisch ausgedrück, kodiert man die Buchstaben~A bis~Z mit den Zahlen~0
bis~25 und ordnet jedem Buchstaben den durch die Abbildung $x\mapsto
x+i\pmod{26}$ beschriebenen Buchstaben zu.

Der Schlüssel für die Verschlüsselung ist dabei $i\in\{0,1,\dotsc,25\}$, die
Anzahl der Positionen, um die der Buchstabe verschoben wird.

Das Verfahren hat den Nachteil, das nur wenige ($n$) Schlüssel verfügbar sind
und das die Verschlüsselung gebrochen ist, wenn \textit{ein} Buchstabe übersetzt
ist.

\subsection{Tauschchiffren}
\label{sec:tausch}

\highl{Tauschchiffren} sind eine Verallgemeinerung der Verschiebechiffren. Die
Buchstaben werden ebenfalls durch
Zahlen kodiert, mit denen dann gerechnet wird. Jedes Zeichen~$x\in
\{0,\dotsc,n-1\}$ wird durch die affinlineare Abbildung $x\mapsto x\cdot
a+b\pmod{n}$ in das Geheimzeichen überführt. Der Schlüssel ist dabei das Paar
$(a,b)\in \{0,\dotsc,n-1\}^{2}$.
Bei den Verschiebechiffren ist $b=0$.

Damit die Entschlüsselung möglich ist, muss die Abbildung bijektiv sein. Dazu
müssen $a$ und $n$ teilerfremd sein. Es gibt also $\phi(n)$\footnote{Eulersche
$\phi$-Funktion; siehe \autoref{sec:restklassen}} Möglichkeiten $a$ zu wählen
und insgesamt $\phi(n)\cdot n$ Schlüssel $(a,b)$.

Ein kurzes Gegenbeispiel, um das Problem zu verdeutlichen: Wählt man $n=26,
a=13$ und $b=0$, so wird das Zeichen~2 als $E(2) = 2\cdot 13+0 \pmod{26} = 0$
als auch das Zeichen~0 als $E(0) = 0 \cdot 13 +0 \pmod{26}$ verschlüsselt.
Eine Entschlüsselung des Zeichens~0 ist also nicht möglich.

\begin{bsp}
  Der Klartext "`text"' wird mit dem Schlüssel~$(5,13)$ auf den Geheimtext
  "`EHYE"' abgebildet.
  \begin{center}
    \begin{tabular}{c|cc|c}
      Buchstabe& Codierung~$x$& $x\cdot 5+13$& Decodierung\\
      \hline
      t& 19& 4& E\\
      e& 4& 7& H\\
      x& 23& 24& Y\\
      t& 19& 4& E
    \end{tabular}
  \end{center}
\end{bsp}

Die Nachteile der Tauschchiffren sind:
\begin{itemize}
 \item Verschlüsselung ist gekackt, wenn \textit{zwei} Buchstaben übersetzt
  sind und
 \item Häufigkeitsverteilung der natürlichen Sprache bleibt erhalten.
\end{itemize}

Die \highl{Tauschchiffren} werden in einer allgemeineren Form nochmal im
\autoref{sec:afflin} besprochen.

\section{Homophone Substitutionen}

\highl{Homophone Substitutionen} versuchen die strukturelle Schwäche der
monoalphabetischen Verschlüsselung, die durch die Häufigkeitsverteilung
der Buchstaben bei natürlichen Sprachen gegeben ist, aufzuheben.

Dazu führt man ein \textit{neues} und \textit{größeres} Geheimtextalphabet $Y$
und eine Abbildung $f\colon X\mapsto \mathfrak{P}(Y)$ ein, wobei verschiedene
Buchstaben disjunkten Teilmengen entsprechen. Für eine Nachricht
$m=m_{1}m_{2}\dotso m_{k}$ ist der Geheimtext $c=c_{1}c_{2}\dotso c_{k}$,
wobei $c_{i}$ zufällig aus $f(m_{i})$ gewäht wird. (Italien um 1400).

\begin{bsp}
  Für das Klartextalphabet $X=\{a,b,c\}$, wobei die Buchstaben mit den
  Wahrscheinlichkeiten 0,5\,\%, 0,35\,\% und 0,15\,\% vorkommen, verwenden wir das
  Geheimalphabet $Y=\{0,1,\dotsc,7\}$. Dazu definieren wir die Abbildung $f$
  wie folgt
  \begin{gather*}
    f(x) =
       \begin{cases}
         \{0, 3, 4, 7\} &\colon x= a\\
         \{1, 5, 6\} &\colon x=b\\
         \{2\} &\colon x=c
       \end{cases}
  \end{gather*}

  Der Buchstabe $b$ wird also durch die drei Zeichen 1, 5 und 6 codiert. Das
  Wort cbba könnte z.\,B. als 2514 oder 2663 verschlüsselt werden.
\end{bsp}

Der Vorteil einer solchen homophonen Substitution besteht darin, dass die
Häufigkeitsverteilung der Klartextbuchstaben zerstört wird, wenn für alle
$x\in X$, wobei $p(x)$ die relative Häufigkeit ist, mit der der Buchstabe $x$
in Texten auftritt, $f(x)$ so gewählt wird, dass $\frac{p(x)}{\abs{f(x)}}$ für
alle $x$ annähernd gleich ist!

Der Effekt des Ganzen ist, dass im Geheimtext alle Buchstaben des
Geheimtextalphabets~$Y$ etwa gleichwahrscheinlich auftreten!

\begin{bemerk}
  Es gibt ein homophones Verschlüsselungsverfahren mit folgender Eigenschaft:
  Für jeden Geheimtext~$c$ gibt es mindestens zwei verschiedene Schlüssel, die
  $c$ in zwei verschiedene, sinnvolle Klartexte überführen.
\end{bemerk}

\begin{table}
  \centering
  \begin{tabular}{c|*{6}{c}}
     & $x_{1}$ & $x_{2}$ & \dots & $x_{i}$ & \dots & $x_{n}$\\
    \hline
    $x_{1}$ & $y_{\frac{n^{2}}{9}}$ & $y_{\frac{7n^{2}}{8}}$ &
       \dots & $y_{\frac{n^{2}}{4}}$ & \dots & $y_{\frac{n^{2}}{2}}$\\
    $x_{2}$ & $y_{n^{2}}$ & $\ddots$\\
    \vdots &\\
    $x_{j}$ &\\
    \vdots & & & & & $\ddots$ & \vdots\\
    $x_{n}$ & & & & & \dots & $y_{\frac{n^{2}}{12}}$
  \end{tabular}
  \caption{Zuordnung von $n$ Zeichen des Klartextalph. auf $n^{2}$
    Zeichen des Geheimalph.}
  \label{tab:1}
\end{table}

Wie funktioniert dies? Das Klartextalphabet sei $X$ (mit $\abs{X}=n$) und
$Y$ (mit $\abs{Y}=n^{2}$) das Geheimtextalphabet. Der Schlüsselraum wird
beschrieben durch eine $n\times n$-Matrix. Die Zeilen und Spalten werden mit
den Buchstaben aus $X$ indiziert und die Eintragungen sind die (zufällig
angeordneten) Buchstaben von $Y$. Siehe \autoref{tab:1}. Wir definieren zwei
Abbildungen:
\begin{align*}
  f_{1}(x_{j}) &= \{ y\in Y\colon y \text{~steht in der $j$. Zeile} \}\\
  f_{2}(x_{i}) &= \{ y\in Y\colon y \text{~steht in der $i$. Spalte} \}
\end{align*}

Es sei $m=m_{1}m_{2}\dotso m_{k}$ der zu verschlüsselnde Klartext und
$l'=l_{1}'l_{2}'\dotso l_{k}'$ ein weiterer sinnvoller Klartext gleicher Länge.

Als Verschlüsselung für $m_{i}$ verwenden wir den Eintrag in der Matrix, der
im Schnittpunkt von $m_{i}=x_{r}$ und $l_{i}=x_{s}$ ($r$-ter Zeile und $s$-ter
Spalte) liegt.
\begin{gather*}
  m_{i}\mapsto c_{i}\in f_{1}(m_{i}) \cap f_{2}(l_{i})
\end{gather*}

Ein \highl{Brute-force-Angriff} bleibt bei solch einer Verschlüsselung
prinzipell wirkungslos, weil jeder Geheimtext in zwei verschiedene,
\textit{sinnvolle} Klartexte übersetzt werden kann!

Jedoch bleibt weiterhin der Nachteil bestehen, dass für alle $x\in X$ ist
$\abs{f(x)}$ gleich groß ist. Damit die Forderung, dass $\frac{p(x)}%
{\abs{f(x)}}$ für alle $x$ annähernd gleich ist, verletzt. Aber die Idee ist,
dass der Angreifer nicht sagen kann, welcher der beiden konkurrierenden
Klartexte der richtige ist.

% 25. 10. 2006

\begin{bsp}
  Das Klartextalphabet $X$ sei das deutsche Alphabet und wir wählen als
  Geheimtextalphabet $Y=\{00, 01, \dotsc, 10,11,\dotsc,99\}$
  ($\abs{Y}=100$). Die Zuordnung $f\colon X\rightarrow
  \mathfrak{P}(Y)$ wählen wir so, dass gilt: Für alle Buchstaben $x\in X$ ist $\abs{f(x)}\approx
  p(x)\cdot 100$.

  In der Tabelle mit Häufigkeiten der Buchstaben \autoref{tab:buchswsk} sehen
  wir, dass z.\,B. \texttt{c} mit der Wahrscheinlichkeit 3,06\,\% auftritt.
  Also wählen wir zufällig für \texttt{c} drei Zeichen aus $Y$, z.\,B. $07, 23, 42$.
\end{bsp}

\subsection{Ansatz zur Kryptoanalyse einer homophonen Verschlüsselung}

Eine weitere Idee für einen Angriff ist andere Unregelmäßigkeiten --~neben der
Häufigkeitsverteileung der Buchstaben~-- in der deutschen Sprache zu finden.
Dazu betrachten wir sogenannte \highl{Digramme} (Zweierfolgen von Buchstaben)
in Texten. Dafür gibt es insgesamt $2^{26}$ mögliche Paarungen. Beispiele für
Digramme sind \textit{en} und \textit{er}, die mit einer Wahrscheinlichkeit
von ca.~4\,\% in deutschen Texten auftreten. Das Digramm \textit{ch} tritt mit
einer Wahrscheinlichkeit von ca.~2,75\,\% und die Digramme \textit{de},
\textit{te}, \textit{nd}, \textit{ei}, \textit{ie}, \textit{es}, \textit{in}
treten mit der Wahrscheinlichkeit von ca.~2\,\% auf.

Damit haben wir bereits eine Anomalie gefunden. Wärend die Buchstaben
\textit{e} und \textit{n} häufig auftreten und auch das Digramm aus beiden
\textit{en} häufig auftritt, ist es im Fall von \textit{c}, \textit{h} und
\textit{ch} nicht so. Die einzelnen Buchstaben sind recht selten (siehe
\autoref{tab:buchswsk}), das Digramm jedoch tritt sehr häufig auf.

Ausgangspunkt: Verschlüsselung von \glq{}c\grq{}. Es $\abs{f(c)} =k$
(z.\,B. $k=3$) Dann müssen (etwa) folgende Relationen erfüllt sein:
$\abs{f(\mathtt{e})}\approx 6k, \abs{f(\mathtt{n})} \approx 3k,
\abs{f(\mathrm{i})} \approx 2\mathord{,}5k, \abs{f(\mathrm{r})} \approx
2\mathord{,}5k$

"`en"' wird auf $6k\cdot 3k = 18k^{2}$ verschiedene Weisen verschlüsselt.
"`ch"' wird auf $k\cdot 1\mathord{,}5k = 1\mathord{,}5k^{2}$ verschiedene Weisen verschlüsselt.

Ein Digramm, dass "`en"' verschlüsselt, tritt mit einer Häufigkeit von
$\frac{4\,\%}{18}\approx 0\mathord{,}25\,\%$ auf. Für "`ch"' ist die Häufigkeit
$\frac{2\mathord{,}5\,\%}{1\mathord{,}5\,\%}\approx 1\mathord{,}6\,\%$.

Dies ist ein Ansatz zunächst die Verschlüsselung für \textit{c} und
\textit{h} zu knacken. Vorraussetzung für einen solchen Angriff ist aber
ein wirklich langer Geheimtext!

\section{Polyalphabetische Verschlüssung}

Polyalphabetische Verschlüssung hat ebenfalls das Ziel, die Häufigkeit
der Buchstaben zu verwischen. Ein prominentes Beispiel ist
\highl{Vigenère-Chiffre} von dem franz. Diplomat Blaise Vigenère (16.\,Jh.),
die erst im 19.\,Jahrhundert gebrochen wurde.

\begin{table}
  \centering
  \begin{minipage}{14cm}
    \ttfamily\footnotesize
    ~~~%
    \setcounter{cnt}{1}%
    \whiledo{\thecnt < 27}{%
      \alph{cnt}~~%
      \stepcounter{cnt}%
    }\\
    \newcounter{cntline}\setcounter{cntline}{1}%
    \newcounter{cntcol}%
    \setcounter{cnt}{1}%
    \whiledo{\thecntline < 27}{%
      \ifthenelse{\thecnt > 26}{\addtocounter{cnt}{-26}}{}%
      \alph{cnt}~~%
      \setcounter{cntcol}{1}%
      \whiledo{\thecntcol < 27}{%
        \ifthenelse{\thecnt > 26}{\addtocounter{cnt}{-26}}{}%
        \Alph{cnt}~~%
        \stepcounter{cnt}%
        \stepcounter{cntcol}%
      }\\
      \stepcounter{cnt}%
      \stepcounter{cntline}%
    }
  \end{minipage}
  \caption{Das Vigenère-Quadrat.}
  \label{tab:vig}
\end{table}

Die Idee der Vigenère-Chiffre ist, dass jeder Buchstabe mit einer anderen
Caesar-Chiffre verschlüsselt wird, aber nicht zufällig, sondern strukturiert.
Mit Hilfe eines Schlüsselworts.

\begin{bsp}
  Als Schlüsselwort nehmen wir "`ALLGAEU"' und als Klartext "`emmentaler"'.

  \texttt{emmentaler}\\
  \texttt{ALLGAEUALLGAEU}\\
  \texttt{EXXKNXULPC}

  Verschlüsselung ist einfach.
\end{bsp}

\begin{bemerk}
  Wir sehen folgendes in dem Beispiel: "`e"' wird zu "`E"', "`K"' und
  "`P"'. Umgekehrt entsteht "`X"' aus "`m"' und "`t"'.

  Das ist eine neue Situation.
\end{bemerk}

\subsection{Formale Beschreibung}

zunächst allgemein: ein Klartextalphabet $X$ mit $\abs{X}=n$ (z.\,B.
$n=26$) und $d$ Geheimtextalphabete $Y_{0}, Y_{1}, \dotsc, Y_{d-1}$. Dazu
$d$ bijektive Abbildungen $f_{i}\colon X \mapstoto Y_{i}$
($i=0,\dotsc,d-1$) und eine surjektive Abbildung $h\colon\N\mapsto
\{0,1,\dotsc,d-1\}$ ($h(x)=x\pmod{d}$).

Klartext: $m=m_{1}m_{2}\dotso m_{t}$ ($m_{j}\in X$)\\
Geheimtext: $c= f_{h(1)}(m_{1}) f_{h(2)}(m_{2}) \dotso f_{h(t)}(m_{t}) =
c_{1} c_{2}\dotso c_{t}$\\
Schlüssel: ist bestimmt durch $h$ und $f_{0}, f_{1}, \dotsc, f_{d-1}$. Es
wird der "`Schlüsselstrom"' $f_{h(1)}, f_{h(2)}, \dotsc, f_{h(t)}$
erzeugt. Daher \highl{Stromchiffre}.

jetzt für Vigenère: $X=\{0,1,\dotsc,n-1\}$ und $n=26$
$Y_{0}=Y_{1}=\dotsb= Y_{d} = X$. Dabei ist $d$ die Länge des
Schlüsselworts. $h(x) = x\pmod{d}$ (für jede Position $x\in\N$).
$f_{i}(a) = a+ j_{i}\pmod{n}$ (für $a\in X$) für festes $j_{i}\in X$.
Der Schlüssel ist dabei $j_{0},j_{1},j_{2},\dotsc$.

Effekt: Unterschiedliche Buchstabenhäufigkeiten werden ausgeglichen!

Und weil's so schön war, noch ein
\begin{bsp}
  Statt dem Alphabet $\{a, b, c, \dotsc, x,y,z\}$ verwenden wir
  $X=\{0,1,\dotsc,25\}$. Als Schlüsselwort nehmen wir "`KRYPTO"' ($d=6$
  mit sechs verschidenen Buchstaben) als $10,17,24,15,19,14 =
  j_{0},j_{1}, j_{2}, j_{3}, j_{4}, j_{5}$. Klartext:
  "`kommemorgennicht"' = $10,14,12,12,04,12,14,17,06,04,13,13,08,02,07,19$

  Wir machen uns eine Tabelle.
  \begin{tabular}{l*{6}{|c}|}
    Schlüsselwort & 10 & 17 & 24 & 15 & 19 & 14\\
    \hline
    1.\,Zeile     & 10 & 14 & 12 & 12 & 04 & 12\\
                  & 20 & 05 & 10 & 01 & 23 & 00\\
    \hline\hline
    3.\, Zeile    & 14 & 17 & 06 & 04 & 13 & 13\\
                  & 24 & 08 & 04 & 19 & 06 & 01\\
    \hline\hline
    5.\,Zeile     & 08 & 02 & 07 & 19\\
                  & 18 & 19 & 05 & 08
  \end{tabular}

  Geheimtext: UFKBXAYIETGBSTFI
\end{bsp}

% 2006-10-30

\subsection{Analyse der polyalphabetischen Verschlüsselung}

Der Angriffspunkt bei der polyalphabetischen Verschlüsselung ist die
Periodizität. Bei einer Periodenlänge~$d$ bezeichnet man als einen
\highl{Teiltext} die Buchstabenfolge an den Positionen $k+nd$ für
$1\leq k \leq d$ und $n\in\N_{0}$. Wenn man den Text in Form einer Tabelle mit
der Breite der Schlüsselwortlänge aufschreibt, dann ist jede Spalte von oben
nach unten gelesen ein Teiltext.

Obwohl die Teiltexte keine sinnvollen Texte sind, stellt sich bei "`langen"'
Teiltexten die gleiche Häufigkeitsverteilung der Buchstaben wie bei einem
richtigen Text ein. Innerhalb der Spalten findet man also eine
Buchstabenhäuigkeit wie bei einem natürlichen Text.

Die einzelnen Teiltexte sind also monoalphabetisch verschlüsselt. Man kann
also im ersten Schritt die Schlüssellänge bestimmen und im zweiten Schritt die
monoalphabetischen Teiltexte mit Hilfe der Häufigkeitsanalyse entschlüsseln.

\subsubsection{Brute-force-Angriff auf polyalphabetische Verschlüsselung}

Aus Erfahrung weiß man, wenn ein Geheimtext, der durch polyalphabetische
Verschlüsselung entstanden ist, mit einem Schlüssel der falschen Länge
entschlüsselt wird, ist die Häufigkeitsverteilung nivelliert. Man kann also
systematisch $d=1,2,3,\dotsc$ durchprobieren bis man für den entschlüsselten
Text eine natürliche Verteilung der Buchstaben gefunden hat.

Dies Funktioniert nur für kleine $d$!

\subsubsection{Kasiski-Test}\index{Kasiski-Test}

Diese Möglichkeit, die Länge des Schlüsselworts für einen polyalphabetisch
verschlüsselten Text zu bestimmen, wurde 1854 von Charles Babbage entdeckt,
aber nach Kasiski benannt, der sie das erste Mal veröffentlichte.

Wenn man die polyalphabetische Verschlüsselung betrachtet, fällt auf, dass
Buchstabenfolgen, die sich im Abstand eines Vielfachen der Periodenlänge
wiederholen, auf das gleiche Muster im Geheimtext abgebildet werden. Häufig
auftretenden Buchstabenkombinationen werden also an mehreren Stellen im Text
auf die gleiche Weise verschlüsselt.

Beispiele für solche Muster können die Artikel der, die, das, ein oder eine
sein, die häufig in einem Text vorkommen und somit auch wiederholt in der
gleichen Spalte bei der Verschlüsselung beginnen.

Findet man also in einem Geheimtext Muster, die Länger als zwei Zeichen sind
und mehrfach auftreten, so können dies Buchstabenfolgen sein, die auf die
gleiche Weise verschlüsselt wurden. Die Länge des Schlüsselworts muss also ein
Teiler des Abstands der Wiederholungen des Musters sein.

Man kann mit mehreren Mustern und anhand ihrer Struktur (längere Muster sind
eher das Ergebnis eines Musters im Klartext als eine zufällig Wiederholung im
Geheimtext) eine (oder ein paar) Vermutungen über die Schlüssellänge finden.

\subsubsection{Friedman-Test}\index{Friedman-Test}

Von William Friedman (1891--1969) stammt die Idee, die Periodenlänge mit Hilfe
statistischen Methoden zu bestimmen. Die entscheidende statistische
Größe dabei ist der Koinzidenzindex~$I(t)$ für einen Text~$t$.

Für ein Alphabet $A=\{a_{1},\dotsc, a_{n}\}$ (mit $\abs{A}=n$) und einen
Text~$t$ der Länge~$l$ ist der \highl{Koinzidenzindex}~$I(t)$ die
Wahrscheinlichkeit dafür, dass an zwei zufällig gewählten Positionen in dem
Text der selbe Buchstabe steht.

Es sei $l_{i}$ die absolute Häufigkeit (Anzahl der Vorkommen) des
Buchstabens~$a_{i}$ im Text, d.\,h. $l=\sum_{i=1}^{n} l_{i}$. Für einen Text
der Länge~$l$ gibt es $\binom{l}{2}$ zufällig gewählte Zweiermengen von
Positionen. Die Anzahl der Mengen von zwei zufällig gewählten Positionen mit
gleichen Buchstaben beträgt
\begin{gather*}
  \sum_{i=1}^{n} \binom{l_{i}}{2} = \sum_{i=1}^{n} \frac{l_{i}(l_{i}-1)}{2}
\end{gather*}

Damit ergibt sich die Wahrscheinlichkeit, dass an zwei zufällig gewählten
Positionen zwei gleiche Buchstaben im Text~$t$ stehen:
\begin{align}
  I(t) &= \sum_{i=1}^{n} \frac{\binom{l_{i}}{2}}{\binom{l}{2}}
     = \sum_{i=1}^{n} \frac{l_{i}(l_{i}-1)}{l(l-1)}
     = \sum_{i=1}^{n} \frac{l_{i}^{2}}{l(l-1)}
     - \sum_{i=1}^{n} \frac{l_{i}}{l(l-1)} \notag\\
  &= \frac{l}{l-1} \sum_{i=1}^{n} \Bigl(\frac{l_{i}}{l}\Bigr)^{2} -
     \frac{1}{l-1} \label{eq:koinzi}
\end{align}

Für einen hinreichend großen Text, d.\,h. $l\rightarrow\infty$, in deutscher
Sprache~$t_{d}$ mit den Buchstabenhäufigkeiten aus \autoref{tab:buchswsk}
ergibt sich ein \highl{Koinzidenzindex}~$I_{d} := I(t_{d}) \approx 0\mathord{,}0762$.

Der Koinzidenzindex für einen hinreichend großen Zufallstext~$t_{z}$ der
Länge~$l$, bei dem alle Buchstaben gleichhäufig auftreten $l_{1}=l_{2}=\dotsb=
l_{n}$, ist
\begin{gather*}
  I(t_{z}) = \frac{l}{l-1} \sum_{i=1}^{n} \Bigl(\frac{1}{n}\Bigr)^{2} - \frac{1}{l-1}
     = \frac{l}{l-1} \frac{1}{n} - \frac{1}{l-1}
     \xrightarrow{l\rightarrow\infty} \frac{1}{n}
\end{gather*}
Legt man ein Alphabet mit 26~Buchstaben zugrunde, ergibt sich so ein
\highl{Koinzidenzindex}~$I_{z} := \frac{1}{26} \approx 0\mathord{,}0385$.

\begin{bemerk}
  Der entscheidende Fakt für den Friedman-Test, der einen Angriff auf die
  Verschlüsselung ermöglicht, ist, dass die Wahrscheinlichkeit an zwei
  zufällig gewählten Positionen denselben Buchstaben zu finden, in deutschen
  Texten (und Texten anderer natürlicher Sprachen) etwa doppelt so groß wie in
  Zufallstexten ist.
\end{bemerk}

In einem Geheimtext~$c$ der Länge~$l$, der das Ergebnis einer
polyalphabetischen Verschlüsselung mit Periode~$d$ ist, sind die Buchstaben in
einem Teiltext ($k, d+k, 2d+k,\dotsc$) entsprechend der Buchstabenhäufigkeit
der Spache verteilt. Zwischen den Teiltexten (d.\,h. von einer Spalte zu einer
anderen) sind die Buchstaben jedoch zufällig verteilt. (Eigenschaft der
polyalphabetischen Verschlüsselung.)

% Wählt man zufällig zwei Positionen in einem Teiltext, so trifft man mit einer
% Wahrscheinlichkeit von $I_{d}$ auf zwei gleiche Buchstaben. Wählt man zufällig
% zwei Positionen aus dem gesamten Geheimtext, so ist die Wahrscheinlichkeit für
% zwei gleiche Buchstaben $I_{z}$.

Die Teiltexte haben die Länge~$\frac{l}{d}$. Also gibt es
\begin{gather*}
  d\cdot \binom{\frac{l}{d}}{2} = \frac{l(l-d)}{2d}
\end{gather*}
zufällige Paare in ein und demselben Teiltext über alle Teiltexte. Für die
zufälligen Paare in unterschiedlichen Teiltexten bleiben
\begin{gather*}
  \frac{1}{2} \cdot l\cdot (l-\frac{l}{d}) = \frac{l^{2}(d-1)}{2d}
\end{gather*}
Möglichkeiten. ($l$ Möglichkeiten für die erste Position; $l-\frac{l}{d}$
Möglichkeiten für die zweite Position in den anderen Spalten; $\frac{1}{2}$
da es kein geordnetes Ziehen ist)

% 2006-11-01

Damit ist die Wahrscheinlichkeit im gesamten Geheimtext~$c$ an zwei zufällig
gewählten Positionen die gleichen Buchstaben zu finden
\begin{gather}
  \label{eq:koinzi_poly}
  I(c) =
     \frac{\frac{l(l-d)}{2d}\cdot I_{z} + \frac{l^{2}(d-1)}{2d}\cdot I_{d}}%
          { \frac{l(l-1)}{2} }
\end{gather}

Da man den Koinzidenzindex~$I(c)$ für den verschlüsselten Text mit der
\autoref{eq:koinzi} bestimmen kann, kann man so einen Schätzwert für die
Periodenlänge~$d$ der Verschlüsselung aus \autoref{eq:koinzi_poly} ableiten.
\begin{gather*}
  d = \frac{l(I_{d}-I_{z})}{I_{d} - lI_{z} +(l-1)I(c)}
\end{gather*}

Diese Schätzung kann man mit den Ergebnissen aus einem Kasiski-Test oder einem
Brute-Force-Angriff vergleichen, um die Möglichkeiten für die wahre
Periodenlänge genauer einzuschränken.

\subsection{Möglichkeiten der Verteidigung gegen die Analyse}

Ausgangspunk: Die oben formulierten Tests funktionieren nur für kleine
Periodenlängen ($d\ll l$)! Deshalb: 1) Betrachten von großen Periodenlängen,
technische Realisierung in der \highl{ENIGMA} -- 1920 deutsches Patent mit
drei Rotoren: Periodenlänge $26^{3}$, Einsatz im Krieg mit fünf Rotoren:
Periodenlänge $26^{5}$.

2.\,Ansatz: nicht periodische Verschlüsselung: a) mit einem
"`Schlüsselroman"', d.\,h. aus einem vorher gewählten Buch wird ein Text
ausgewählt -- Schlüssel ist dann (Seite, Zeile, Buchstabe). Aber dann
funktioniert wieder die Häufigkeitsanalyse, weil der Roman wieder die
Charakteristik einer natürlichen Sprache hat. (in diese Kategorie fällt auch
das anhängen des Klartextes an das Schlüsselwort.)

b) mit Zufallstexten, führt wieder zu \highl{One-Time-Pad} und damit zum
absolut sicheren Code -- aber unpraktikabel.

\chapter{Transpositionen}

Klartextbuchstaben bleiben Klartextbuchstaben, ändern aber ihr Position. Die
Häufigkeitsanalyse von Buchstaben als Angriff ist wirkungslos, da der Text nur
permutiert wurde. (Aber Digramme sind ein Versuch wert!)

Verschiedene Ansätze der Verschlüsselung:
\begin{itemize}
 \item \highl{Blocktransposition}: Klartext wird in Blöcker einer festen
  Länge~$k$ eingeteilt. Diese Blöcke werden derselben Permutation~$\pi$
  unterworfen. Beispiel: $a_{i_{1}}a_{i_{2}}\dotso a_{i_{k-1}}a_{i_{k}} =
  a_{i_{\pi(1)}} a_{i_{\pi(2)}}\dotso a_{i_{\pi(k-1)}}a_{\pi(i_{k})}$.

  Analyse:
  \begin{enumerate}[1.\,{Schritt}]
   \item Rate/Bestimme die Blocklänge~$k$
   \item Erzeuge durch geegnete Permutationen bekannte Anagramme. teste an
    anderen Blöcken
  \end{enumerate}
  Dies funktioniert sehr gut.

 \item \highl{Spaltentransposition}:
  \begin{enumerate}
   \item Klartext wird zeilenweise in ein Rechteck der Breite~$k$ eingelesen
    (Höhe hängt von der Länge~$l$ des Klartexts ab)
   \item permutiere die $k$~Spalten (wie oben)
   \item Lies den Geheimtext spaltenweise aus (Im Unterschied zur
    Blocktransposition, wo der Geheimtext zeilenweise ausgelesen wird.)
  \end{enumerate}
\end{itemize}

\begin{bemerk}
  Wenn für die Spaltentransposition die Identität als Permutation verwendet
  wird, hat man die \highl{Gartenzaunchiffre}.
\end{bemerk}

\begin{bsp}
  Klartext:
  \begin{verbatim}
  krypto  rptoky
  logieu  oieulg
  nddate  datend
  nsiche  scheni
  rheita  hitare
  \end{verbatim}
  Das letzte \textit{a} ist Füllmaterial, $k=6, \pi = (1, 5, 3, 6, 4, 2)$

  Text für Blockchiffre: "`rodsh\,piaci\,tetht\,oueea\,ygdie"'
\end{bsp}

Analyse:
\begin{enumerate}[1.\,{Schritt}]
 \item Schätze die Spaltenzahl~$k$, Teiler der Gesamtlänge~$l$
 \item Bestimmung benachbarter Spalten (suche nach Anagrammen)
\end{enumerate}

\begin{bsp}
  Die erste Zeile für $k=11$ enthält zu viele Konsonanten und die letzte Zeile
  zu viele Vokale für einen deutschen Text.

  Idee: 1. und letzte Spalte liegen nebeneinander, da auf ein \textit{c} sehr
  of ein \textit{k} oder ein \textit{h} folgt.

  Die sechse Spalte kommt vor die erste und dann können wir das Wort in der
  ersten Zeile erraten "`zwei"': 3., 5., 1. 6. 2. 4.
\end{bsp}

% 13.11.06

\chapter{Blockchiffren}
\section{Allgemeines}

Wir bleiben zunächst noch bei den symmetrischen Verschlüsselungsverfahren und
versuchen durch eine Vergrößerung des Schlüsselraums die Verfahren sicherer zu
machen. Im Folgenden beschränken wir uns auf (rechnerfreundliche) Bitfolgen,
d.\,h. wir arbeiten mit Teilmengen von $\Z_{2}^{n}$.

\begin{defini}[Blockchiffre]
  Bei einer \highl{Blockchiffre} wird der Klartext in Blöcke einer frei
  wählbaren, aber festen Länge~$n$ (z.\,B. 32, 64 oder 128~Bit) zerlegt. Diese
  wird als \highl{Blocklänge} bezeichnet. Eine Verschlüsselungsfunktion~$f$
  erzeugt unter Verwendung eines Schlüssels Geheimtextblöcke der
  \textit{gleichen} Länge.
\end{defini}

Damit eine Entschlüsselung des Textes möglich ist, muss die Verschlüsselung
bijektiv seien und da sie von $\Z_{2}^{n}$ auf $\Z_{2}^{n}$ abbildet, ist sie
eine Permutation der $2^{n}$ möglichen Blöcke. Es gibt also $2^{n}!$
mögliche Funktionen zur Verschlüsselung.

Ein kleines Gedankenspiel: Für die Blocklänge~$n=64$ gibt es $2^{64}!$
mögliche Verschlüsselungen und damit genau soviele Schlüssel. Um einen solchen
Schlüssel abspeichern zu können, benötigt man $l=\log_{2}(2^{64}!)$~Bit.
Mit Hilfe der Stirling-Formel kann man die Größe eines solchen Schlüssels
abschätzen:
\begin{align*}
  2^{n}! &\approx \sqrt{2\pi\cdot 2^{n}} \cdot
     \Bigl(\frac{2^{n}}{e}\Bigr)^{2^{n}}\\
  l &\approx \log_{2} \big(\sqrt{2\pi} \cdot 2^{32} \cdot
     \Big(\frac{2^{64}}{e}\Big)^{2^{64}} \big)
     \approx 64 \cdot 2^{64} = 2^{6+64}
\end{align*}
Es würden also zum Abspeichern \textit{eines} Schlüssels für eine Nachricht
$\frac{1}{8}\cdot 2^{20}\approx 10^{5}$~Pebibyte benötigt. In der Praxis kann
man also nur mit "`kleinen"' Teilmengen des Schlüsselraums arbeiten.

Für affin lineare Chiffren werden beispielsweise $\{0,1\}$-Matrizen vom Typ
$64\times 64$ verwendet, deren Determinante~1 ist. Die Darstellung des
Schlüssels ist also mit mit weniger als $64\cdot64 = 2^{12}$~Bit (im
Vergleich zu $2^{70}$~Bit) möglich.

Die Hintereinanderschaltung von \textit{verschiedenen} Blockchiffren führt zu
einer Erhöhung der Sicherheit. Oft realisiert man eine abwechselnde Folge von
Substitutionen und Transpositionen mit dem Ziel die folgenden beiden
\highl{Eigenschaften der Verschlüsselung}, die auf Claude Shannon, den
Begründer der Informationstheorie, zurückgehen, zu erreichen:
\begin{itemize}
 \item \highl{Diffusion}: Änderung eines Klartextbits bewirkt die
  Änderung von vielen Bits des Geheimtexts -- Nachteil: kleine Fehler
  (Tippfehler) ändern den Text stark.
 \item \highl{Konfusion}: Jedes Bit des Chiffretextes hängt von mehr als einem
  Bit des Schlüssels ab.
\end{itemize}

% Einschub, kam nie in der Vorlesung dran

\subsection{Blockverknüpfungsmodi}

Bei der Verschlüsselung können gleiche Blöcke gleich verschlüsselt werden
--~in Analogie zur monoalphabetischen Verschlüsselung~-- oder sie werden in
Abhängigkeit von ihrer Position im Klartext auf verschiedene Weise
verschlüsselt --~in Analogie zur polyalphabetischen Verschlüsselung.

\begin{figure}
  \begin{minipage}[t]{.45\linewidth}
    \input{ecb.pdf_t}
    \caption{Electronic Code Book}
    \label{fig:ecb}
  \end{minipage}%
  \begin{minipage}[t]{.55\linewidth}
    \input{cbc.pdf_t}
    \caption{Cipher Block Chaining}
    \label{fig:cbc}
  \end{minipage}%
\end{figure}

Die erste Variante bezeichnet man als Electronic Code Book Mode (\highl{ECB}).
Jeder Block wird unabhängig von seiner Position mit Hilfe des Schlüssels durch
die Funktion~$f$ in einen Geheimtextblock überführt. \autoref{fig:ecb}
\begin{align*}
  c_{i} &= E_{K}(m_{i})& m_{i} &= D_{K}(c_{i})
\end{align*}

Dies hat den Vorteil, dass die Verschlüsselung aller Blöcke parallel ablaufen
kann. Jedoch bleiben die Anomalien des Klartextes (häufigeres Auftreten
bestimmter Blöcke) erhalten. Da sich Änderungen an einem Klartext- oder
Chiffretextblock nur auf genau einen Klartext bzw. Chiffretextblock auswirken,
könnte ein Angreifer gezielt Daten verändern, ohne dass es bemerkt wird.
Jedoch bietet dieser Umstand auch die Möglichkeit einzelne Blöcke gezielt zu
entschlüsseln oder zu verändern, ohne die ganze Nachricht entschlüsseln zu
müssen. Für eine Dateiverschlüsselung z.\,B. könnte gezielt der neue
Klartextblock verschlüsselt und in dem Geheimtext ersetzt werden.

Beim Cipher Block Chaining Mode (\highl{CBC}) wird der Klartextblock vor der
Verschlüsselung mit dem Ergebnis der Verschlüsselung des vorherigen Blocks
verknüpft, um für gleiche Klartextblöcke unterschiedliche Geheimtextblöcke zu
erzeugen. Dies bringt jedoch die Nachteile mit sich, dass die Verschlüsselung
der Blöcke nicht mehr parallel ablaufen kann und dass bei einer Änderung eines
Klartextblocks alle folgenden Geheimtextblöcke neu berechnet werden müssen.
\autoref{fig:cbc}
\begin{align*}
  c_{i} &= E_{K}(m_{i}\oplus c_{i-1}) & m_{i} &= D_{K}(c_{i}) \oplus c_{i-1}
\end{align*}

Eine Veränderung des $r$.~Geheimtextblocks ändert nur den $r$. und den
folgenden Klartextblock:
\begin{align*}
  D_{K}(\tilde{c_{r}}) \oplus c_{r-1} &\ne m_{r}\\
  D_{K}(c_{r+1}) \oplus \tilde{c_{r}} &\ne m_{r+1}\\
  D_{K}(c_{r+2}) \oplus c_{r+1} &= m_{r+2}
\end{align*}

\begin{figure}
  \centering
  \input{cfb.pdf_t}
  \caption{Cipher Feedback}
  \label{fig:cfb}
\end{figure}

Cipher Feedback Mode (\highl{CFB}) ist ähnlich zu CBC. Der voherige
Geheimtextblock wird verschlüsselt und dieses Ergebnis mit dem Klartextblock
verknüpft, um Anomalien im Klartext auszugleichen. \autoref{fig:cfb}
\begin{align*}
  c_{i} &= E_{K}(c_{i-1}) \oplus m_{i} & m_{i} &= E_{K}(c_{i-1}) \oplus c_{i}
\end{align*}

Die Verschlüsselungsfunktion~$f$ muss nicht umkehrbar sein, da man zur
Entschlüsselung ebenfalls die Verschlüsselungsfunktion verwendet.

\begin{figure}
  \centering
  \input{ofb.pdf_t}
  \caption{Output Feedback}
  \label{fig:ofb}
\end{figure}

Für den Output Feedback Mode (\highl{OFB}) wird aus einem Initialwert eine
Folge von verschlüsselten Blöcken generiert, die mit den Klartextblöcken
verknüpft, die Geheimtextblöcke ergeben. \autoref{fig:ofb}
\begin{align*}
  c_{i} &= m_{i} \oplus s_{i} & m_{i} &= c_{i}\oplus s_{i} & s_{i} &=
     E_{K}(s_{i-1})
\end{align*}

Dies bringt zwei Vorteile mit sich: Zum Einen kann eine solche Folge schon
vorgeneriert werden, wodurch die eigentliche Verschlüsselung, bei Vorliegen
des Klartextes, sehr schnell geht. (Vorteilhaft z.\,B. bei Streaming) Zum
Anderen kann ein Klartextblock direkt ausgetauscht werden, ohne dass man die
folgenden Blöcke oder die verschlüsselte Folge neu berechnen muss:
$\tilde{c_{i}} = c_{i} \oplus m_{i} \oplus \tilde{m_{i}}$.

\begin{table}
  \centering
  \begin{tabular}{l|cccc}
    mode& Schreibzugriff & Manipulation zerstört \dots& Anomalien im Text\\
    \hline
    ECB& wahlfrei& diesen Block& unverändert\\
    CBC& linear& aktuellen u. nächsten Block& verwischt\\
    CFB& linear& aktuellen u. nächsten Block& verwischt\\
    OFB& wahlfrei& diesen Block& verwischt
  \end{tabular}
  \caption{Übersicht der Eigenschaften von ECB, CBC, CFB und OFB}
\end{table}

% 6.11.06

\section{Einschub: Crashkurs über Restklassenringe und Matrizen darüber}
\label{sec:restklassen}

Zwei Zahlen~$a,b\in\Z$ sind zueinander \highl{äquivalent modulo~$k$}, wenn sie
\help{Sagt man äquivalent modulo k oder kongruent modulo k?}
bei der Division durch $k$ den gleichen Rest ($0\leq r<k$) lassen:
\begin{gather*}
  a\equiv_{k} b \text{~oder~} a\equiv b\pmod{k}
     \quad \gdwdef\quad \exists l\in\Z\colon a-b= l\cdot k
\end{gather*}

Das zerlegt die ganzen Zahlen in genau $k$~\highl{Restklassen} $[a]_{k}$. Die
Menge dieser Restklassen bezeichnet mal als \highl{Faktormenge}~$\Z_{k}$.
\begin{align*}
  [a]_{k} &= \{a+lk\colon l\in\Z\} = a+k\cdot\Z
     &&\text{für~} a\in\{0,\dotsc,k-1\} \\
  \Z_{k} &:= \nicefrac{\Z}{\equiv_{k}}
     = \{ [0]_{k}, [1]_{k}, \dotsc, [k-1]_{k} \}
\end{align*}
Als Kurzschreibweise verwendet man $\Z_{k} = \{0,1,2,\dotsc,k-1\}$.

Auf dieses Restklassensystem kann man die Addition und Multiplikation auf
folgende Weise übertragen:
\begin{align*}
  [a]_{k} + [b]_{k} &:= [a+b]_{k} &&\text{Nullelement:~}[0]_{k}\\
  [a]_{k} \cdot [b]_{k} &:= [a\cdot b]_{k} &&\text{Einselement:~}[1]_{k}\\
\end{align*}

Für jedes $[a]_{k}$ existiert ein \highl{inverses Element bzgl. Addition}
$-[a]_{k} := [-a]_{k} = [k-a]_{k}$. Ein Element $[a]_{k}$ heißt
\highl{Einheit} des Restklassensystems \gdwdef es existiert ein $[b]_{k}$, so dass
$[a]_{k} \cdot [b]_{k} = [1]_{k}$. In diesem Fall heißt $[b]_{k}$
\highl{inverses Element bzgl. Multiplikation} zu $[a]_{k}$.

Die Eulersche $\phi$-Funktion $\phi(k)$ ist die Anzahl der Mengen $a,b\in
\{0,\dotsc,k-1\}$, für die gilt $\ggT(a,b)=1$. Also gibt es in $\Z_{k}$
genau $\phi(k)$ Einheiten, da $[a]_{k}$ eine Einheit ist \gdw ein $[b]_{k}$
mit $[a]_{k}\cdot [b]_{k} = [a\cdot b]_{k} = [1]_{k} = 1+k\Z$ existiert,
d.\,h. es gibt ein $b$ und ein $l$, so dass $ab= 1+kl$, also $ab-kl=1$. Dies
gilt \gdw $\ggT(a,b)=1$.

Falls $k=p$ eine Primzahl ist, dann gibt es $\phi(p)=p-1$ Einheiten und
$\Z_{p}$ ist ein Körper.
\begin{gather*}
  \phi(k) = k\prod_{p\mid k} \Bigl(1-\frac{1}{p}\Bigr)
\end{gather*}

Die algebraische Struktur $\Z_{k} = [\Z_{k},+,\cdot]$ mit dem
Nullelement~$[0]_{k}$ und dem Einselement~$[1]_{k}$ bezeichnet mal als
\highl{kommutativen Ring}.

In der Krypologie wird häufig mit dem Restklassenring modulo~$26$ gearbeitet:
$\Z_{26} = \{0,1,\dotsc,25\}$. Im Grunde sind alle endlichen Alphabete
kommutative Ringe, was den Vorteil hat, dass man mit Buchstaben rechnen kann.
Dies haben wir bereits bei der Caesar-Chiffre ausgenutzt.

Der Ring $\Z_{26}$ hat genau 12~Einheiten, da $\phi(\abs{\Z_{26}}) =
\phi(2\cdot13) = \phi(2)\cdot\phi(13) = 1\cdot12$. Diese sind:
$1,3,5,7,9,11,15,17,19,21,23,25$.

Wir betrachten $n\times n$-Matrizen, deren Einträge Elemente
aus einem beliebigen kommutativen Ring~$[R,+\cdot]$ sind.
\begin{gather*}
  R^{n\times n} := \bigl\{ \begin{pmatrix}
                       r_{11} & r_{12} & \dotso & r_{1n}\\
                       r_{21} & r_{22} & \dotso & r_{2n}\\
                       \vdots & \vdots & & \vdots\\
                       r_{n1} & r_{n2} & \dotso & r_{nn}
                     \end{pmatrix}
                    \colon r_{ij}\in R, 1\leq i,j \leq n\bigr\}
\end{gather*}
Die Matrizenaddition und -multiplikation ist dabei wie üblich.

In der Kryptologie betrachten wir speziell die Matrizen $\Z_{k}^{n\times n}$.

Als \highl[Zeilenvektor]{Zeilen-} (\autoref{eq:zeilenvek}) bzw.
\highl[Spaltenvektor]{Spaltenvektoren} (\autoref{eq:spaltenvek}) bezeichnet
man Matrizen der folgenden Form:
\begin{align}
  R^{1\times n} &= \{ \begin{pmatrix}b_{1} & b_{2} & \dotso & b_{n}\end{pmatrix}
                    \colon b_{i}\in R, 1\leq i \leq n\}\label{eq:zeilenvek}\\
  R^{n\times1} &= \{ \begin{pmatrix}b_{1} & b_{2}&\dotso&b_{n}\end{pmatrix}^{T}
                    \colon b_{i}\in R, 1\leq i \leq n\}\label{eq:spaltenvek}
\end{align}

Als eine \highl{Permutation}~$\sigma$ bezeichnet man eine Umordnung der
Elemente eine Menge. Mit $S_{n}$ bezeichnet man die Menge der Permutationen
einer Menge mit $n$~Elementen.
\begin{gather*}
  S_{n} = \bigl\{ \sigma\colon \sigma\colon \{1,\dotsc,n\} \rightarrow
     \{1,\dotsc,n\} \bigr\}
\end{gather*}

Für eine Permutation~$\sigma\in S_{n}$ bezeichnet man ein Paar
$(i,j)\in\{1,\dotsc,n\}^{2}$ als Fehlstand,
wenn $i<j$ und $\sigma(i)<\sigma(j)$ gilt.

Die \highl{Determinante} einer quadratischen Matrix~$A\in R^{n\times n}$
($A=(a_{ij})_{n\times n}$ mit $a_{ij}\in R$) kann man auf zwei Weisen berechnen.

Die Formel von Leibniz für die Determinante einer Matrix lautet:
\begin{gather*}
  \det A := \sum_{\sigma\in S_{n}} \sgn(\sigma) \cdot
     \prod_{i=1}^{n} a_{i\sigma(i)}\\
  \sgn(\sigma) = \begin{cases}
                   +1 &:\text{die Anzahl der Fehlstände ist gerade}\\
                   -1 &:\text{die Anzahl der Fehlstände ist ungerade}
                 \end{cases}
\end{gather*}

\begin{bsp}
  Die Determinante einer $1\times1$-Matrix~$A=(a_{11})$ ist $\det A = a_{11}$,
  da die einzig mögliche Permutation~$\sigma=
  (\begin{smallmatrix}1\\1\end{smallmatrix})$ das Vorzeichen~$+1$ hat.
  \begin{gather*}
    \det A = \sum_{\sigma\in S_{1}} \sgn(\sigma) \cdot \prod_{i=1}^{1}
       a_{i\sigma(i)} = \sum_{\sigma\in S_{1}} \sgn(\sigma) a_{11}
  \end{gather*}

  Für eine $2\times2$-Matrix~$A$ gibt es zwei Permutationen~$\sigma_{1},
  \sigma_{2}\in S_{2}$:
  \begin{gather*}
    \sigma_{1}=\begin{pmatrix}1&2\\1&2\end{pmatrix},\; \sgn(\sigma_{1})=+1
       \qquad
       \sigma_{2}=\begin{pmatrix}1&2\\2&1\end{pmatrix},\; \sgn(\sigma_{2})=-1
  \end{gather*}
  Entsprechend ergibt sich die Determinante als
  \begin{align*}
    \det A &= \sum_{\sigma\in S_{2}} \sgn(\sigma) \cdot
       \prod_{i=1}^{2} a_{i\sigma(i)}
       = \sum_{\sigma\in \{\sigma_{1},\sigma_{2}\}} \sgn(\sigma) \cdot
       a_{1\sigma(1)}\cdot a_{2\sigma(2)}\\
    &= \sgn(\sigma_{1}) \cdot a_{1\sigma(1)} \cdot a_{2\sigma(2)} +
       \sgn(\sigma_{2}) \cdot a_{1\sigma(1)} \cdot a_{2\sigma(2)}
       = a_{11} a_{22} - a_{12}a_{21}
  \end{align*}
\end{bsp}

Die andere Möglichkeit ist das Verfahren von Laplace, bei dem nach einer Zeile
oder Spalte entwickelt wird:
\begin{gather*}
  \det A = \sum_{j=1}^{n} (-1)^{i+j} a_{ij} A_{ij}
\end{gather*}
wobei $A_{ij}$ diejenige Matrix ist, die durch Streichen der $i$.~Zeile und
$j$.~Spalte aus $A$ entsteht.

Eine Matrix $A$ besitzt eine zu ihr \highl{Inversematrix}~$A^{-1}$, d.\,h. es gilt
\begin{gather*}
  A\cdot A^{-1} = A^{-1}\cdot A = E_{n} =
     \left(\begin{smallmatrix}
       1\\
       & 1 & & \text{\Large \smash{0}}\\
       & & \ddots\\
       & \text{\Large \smash{0}} & & 1\\
       & & & & 1\
     \end{smallmatrix}\right)_{n\times n}
\end{gather*}
\gdw die Determinante~$\det A$ ein inverses Element in $[R,+,\cdot]$ besitzt \gdw
$\det A$ eine Einheit des Rings $[R,+,\cdot]$ ist.

Dabei gilt: $A^{-1}= (\det A)^{-1} B$, wobei $(b_{ij})=(-1)^{i+j}\cdot
\det A_{ij}$.

\section{Affinlineare Blockchiffren}
\label{sec:afflin}

Die Zeichen des Klartexts werden durch Elemente aus $\Z_{k}$ codiert und der
Klartext wird in Blöcke der Länge~$n$ eingeteilt, die einzeln nach demselben
Schema verschlüsselt werden.

Der Schlüssel ist ein Paar $(A,b)$, wobei $A\in\Z_{k}^{n\times n}$ und
$b\in\Z_{k}^{1\times n}$ ist. Zur Verschlüsselung eines
Blockes~$m=(\begin{smallmatrix}m_{1}& \dotso& m_{n}\end{smallmatrix})
\in\Z_{k}^{1\times n}$ wird die lineare Abbildung
\begin{gather*}
  c = m\cdot A+b
\end{gather*}
verwendet. Diese Verschlüsselung ist weder eine Substitution (ein Eintrag
$c_{i}$ hängt im Allgemeinen von allen $m_{1},\dotsc, m_{n}$ ab) noch keine
Transposition.

Aber nicht alle Verschlüsselungen dieser Art sind auch eindeutig, d.\,h. eine
Entschlüsselung ist möglich. Dafür muss zu der Matrix~$A$ die inverse
Matrix~$A^{-1}$ existieren, was genau dann der Fall ist, wenn $\ggT(\det A,
k)=1$, also die Determinante von $A$ eine Einheit von $\Z_{k}$ ist.

Die Entschlüsselung erfolgt dann mit der Abbildung
\begin{gather*}
  m=(c-b)A^{-1}
\end{gather*}

Der Spezialfall $b=0$, also $c=m\cdot A$, ist die \highl{Hill-Chiffre} (1929)
und der Spezialfall $A=E_{n}$, also $c=m+b$, ist die
\highl{Vigenère-Verschlüsselung} mit dem Schlüsselwort~$b$.

Man kann auch eine \highl{Blocktransposition} als eine affinlineare
Abbildung beschreiben. Die für die Blocktransposition genutzte Permutation
von $\{1,\dotsc,n\}$ sei $\sigma$. Mit $b=0$ und der Matrix~$P_{\sigma} =
(p_{ij})_{n\times n}$ mit
\begin{gather*}
  p_{ij} =
     \begin{cases}
       0 & \sigma(i) \ne j\\
       1 & \sigma(i) = j
     \end{cases}
\end{gather*}
ergibt sich der erwünschte Effekt, dass
\begin{gather*}
  \begin{pmatrix} m_{1}& m_{2} & \dotso & m_{n} \end{pmatrix}
     \cdot
     P_{\sigma} =
     \begin{pmatrix}
       m_{\sigma(1)}& m_{\sigma(2)} & \dotso & m_{\sigma(n)}
     \end{pmatrix}
\end{gather*}
und es gilt $P_{\sigma}^{-1} = P_{\sigma^{-1}}$.

% 8.11.06

\subsection{Kryptoanalyse affinlinearer Blockchiffren}

Sind $n+1$ Klartextblöcke~$m_{0},\dotsc,m_{n}$ und die dazugehörigen
Geheimtextblöcke~$c_{0},\dotsc, c_{n}$ bekannt --~eine
\highl{known-plaintext-attack}~--, kann man folgende zwei Matrizen definieren:
\begin{align*}
  M &=
     \begin{pmatrix}
       m_{1}-m_{0}\\
       \vdots\\
       m_{n}-m_{0}
     \end{pmatrix}_{n\times n}
     & C &=
     \begin{pmatrix}
       c_{1}-c_{0}\\
       \vdots\\
       c_{n}-c_{0}
     \end{pmatrix}_{n\times n}
\end{align*}

Es gilt also
\begin{gather*}
  C =
     \begin{pmatrix}
       c_{1}-c_{0}\\
       \vdots\\
       c_{n}-c_{0}
     \end{pmatrix} =
     \begin{pmatrix}
       (m_{1}A+b) - (m_{0}A+b)\\
       \vdots\\
       (m_{n}A+b) - (m_{0}A+b)\\
     \end{pmatrix} =
     \begin{pmatrix}
       (m_{1}-m_{0})A\\
       \vdots\\
       (m_{n}-m_{0})A\\
     \end{pmatrix} =
     M\cdot A
\end{gather*}

Wenn $\det M$ eine Einheit in $\Z_{k}$ ist, dann existiert auch $M^{-1}$.
Hieraus folgt dann $A=M^{-1}C$ und weiter $b= c_{0}-m_{0}A$.

\begin{bemerk}
  Dies kommt nicht zu selten vor, dass $\det M$ eine Einheit ist, denn es gilt:
  \begin{gather*}
    \limsup_{k\rightarrow\infty} \frac{\phi(k)}{k} = 1
       \qquad\text{und}\qquad
       \lim_{k\rightarrow\infty} \frac{\phi(k)}{k^{1-\delta}} = \infty
  \end{gather*}
  für $\delta>0$.

  Für $\Z_{26}$ gibt es z.\,B. $\phi(26)=12$~Einheiten.
\end{bemerk}

\begin{bemerk}
  In einer halbgeordneten Menge kann man definieren:
  \begin{gather*}
    \limsup_{k\rightarrow\infty} x_{k} = \inf\{ \sup\{ x_{l}\colon l\geq
       k\}\colon k\in\N\}
  \end{gather*}
  In vollständigen Verbänden existiert stets der Limes superior und Limes
  inferior und es gilt $\liminf_{k\rightarrow\infty} x_{k} \leq
  \limsup_{k\rightarrow\infty} x_{k}$.
\end{bemerk}

Für \highl{Hill-Chiffren} (d.\,h. $b=0$) genügen $n$~Paare $(m_{j},c_{j})$, da
die Matrix~$C$ nicht als $(c_{i}-c_{0})$ definiert werden muss, um den Anteil
von $b$ zu eleminieren. Damit können auch für die Matrix~$M$ direkt die
Klartextblöcke verwendet werden.

\begin{bsp}
  Es sei $k=26$ und $n=2$. Der Klartext sei "`HERBST"' und der Geheimtext sei
  "`SOMMER"'. Die Aufgabe ist den Schlüssel $(A,b)$ zu bestimmen.

  Der Klartext "`HERBST"' wird durch $\underbrace{7~4}_{m_{0}}~
  \underbrace{17~1}_{m_{1}}~ \underbrace{18~19}_{m_{2}}$ und der Geheimtext
  "`SOMMER"' durch $\underbrace{18~14}_{c_{0}}~
  \underbrace{12~12}_{c_{1}}~ \underbrace{4~17}_{c_{2}}$ codiert.

  Damit kann man nun die Matrizen~$M$ und $C$ bestimmen:
  \begin{gather*}
    M =
       \begin{pmatrix}
         m_{1}-m_{0}\\
         m_{2}-m_{0}
       \end{pmatrix}
       =
       \begin{pmatrix}
          17-7 & 1-4\\
          18-7 & 19-4
       \end{pmatrix}
       =
       \begin{pmatrix}
          10 & 23\\
          11 & 15
        \end{pmatrix}\\
    C =
       \begin{pmatrix}
         c_{1}-c_{0}\\
         c_{2}-c_{0}
       \end{pmatrix}
       =
       \begin{pmatrix}
         12-18& 12-14\\
         4-18& 17-14
       \end{pmatrix}
       =
       \begin{pmatrix}
         20 & 24\\
         12 & 3
       \end{pmatrix}
  \end{gather*}
  \textit{(Beachte: Die Elemente sind aus $\Z_{26}$, immer den Rest der
  Division durch 26 verwenden.)}

  Nun kann man die Determinante von $M$ bestimmen und da diese eine Einheit
  ist, existiert $M^{-1}$.
  \begin{gather*}
    \det M =
       \begin{pmatrix}
          10 & 23\\
          11 & 15
        \end{pmatrix} = 10\cdot15 - 23\cdot11 = 1\\
    M^{-1} = (\det M)^{-1} \cdot B
       = 1 \cdot \begin{pmatrix}15 & 3\\15 & 10\end{pmatrix}
  \end{gather*}
  \textit{(Für die Bestimmung von $B$ siehe \autoref{sec:restklassen}.)}

  Damit lässt sich jetzt die Matrix~$A$ und der Vektor~$b$ bestimmen.
  \begin{gather*}
    A = M^{-1}\cdot C =
       \begin{pmatrix}15 & 3\\15 & 10\end{pmatrix}\cdot
       \begin{pmatrix}20 & 24\\12 & 3\end{pmatrix}
       = \begin{pmatrix}24 & 5\\4 & 0\end{pmatrix}\\
    b = c_{0}-m_{0}
       = \begin{pmatrix}18 & 14\end{pmatrix}
       - \begin{pmatrix}7 & 4\end{pmatrix}
       \cdot \begin{pmatrix}24 & 5\\4 & 0\end{pmatrix}
       = \begin{pmatrix}18 & 14\end{pmatrix}
       - \begin{pmatrix}2 & 9\end{pmatrix}
       = \begin{pmatrix}16 & 5\end{pmatrix}
  \end{gather*}
\end{bsp}

Der einzige Schutz bei affinlinearen Verschlüsselungen besteht darin, den
Schlüsselraum möglichst groß zu machen, um die Berechnungen bei einem Angriff
aufwendiger werden zu lassen.

\section{Feistel-Chiffre}

Die Idee zur \highl[Feistel-Chiffre]{Feistel"=Chiffre} wurde 1971 bei IBM in
dem Projekt "`\href{http://de.wikipedia.org/wiki/Lucifer\_(Kryptographie)}{Lucifer}"'
entwickelt und ist heute Grundlage für viele symmetrische Blockchiffren unter
anderem dem heute am häufigsten eingesetzen Verschlüsselungsalgorithmus DES
--~dazu später mehr in \autoref{sec:des}. Als Erfinder der Feistel"=Chiffre
gilt
\href{http://de.wikipedia.org/wiki/Horst_Feistel}{Horst Feistel}, ein
Mitarbeiter des Projekts Lucifer.

Bei der Feistel"=Chiffre werden die Klartextblöcke durch eine alternierende Folge von
Substitutionen und Transpositionen verschlüsselt. Einen einzelnen Durchlauf
von Substitution und Transposition bezeichnet man als \highl{Runde}. Die
einzelnen Schlüssel für jede Runde werden dabei aus einem (Haupt"~)""Schlüssel
erzeugt.
\todo{Erklären, was die S-Box (Substitution) und die P-Box (Translation; von
  Permutation) ist.}
\todo{to produce a function with large amounts of what Claude Shannon
  described as ``confusion and diffusion.'' Bit shuffling creates the diffusion
  effect, while substitution is used for confusion.}

Eine Nachricht~$m\in\Z_{2}^{n}$ der Länge~$n$ (o.\,B.\,d.\,A. sei $n$ gerade)
wird in zwei gleichlange Teile~$L_{0}$ und $R_{0}$ zerlegt. Aus diesen beiden
wird durch die Zuordnung in \autoref{eq:feistel} ein neuer linker Teil~$L_{1}$
und ein neuer rechter Teil~$R_{1}$ gewonnen. Diese beiden Zeichenketten
wiederum werden als Eingabe für die nächste Runde verwendet. Die
\highl{Rundenzahl}~$r$ bestimmt dabei, wie oft ein solcher Durchlauf
stattfindet. In der letzten Runde wird die leicht modifizierte Vorschrift aus
\autoref{eq:feistel-last} verwendet, bei der die Transposition entfällt

\begin{align}\label{eq:feistel}
  \begin{split}
    L_{i} &= R_{i-1}\\
    R_{i} &= L_{i-1} \oplus f_{K_{i}}(R_{i-1})
  \end{split}
     &\text{für~}i=1,\dotsc,r-1\\
  \label{eq:feistel-last}
  \begin{split}
    L_{r} &= L_{r-1} \oplus f_{K_{r}}(R_{r-1})\\
    R_{r} &= R_{r-1}
  \end{split}
\end{align}
\begin{gather*}
  (L_{i-1}, R_{i-1})
     \xrightarrow{\text{Substitut.}}
     \bigl(L_{i-1} \oplus f_{K_{i}}(R_{i-1}), R_{i-1} \bigr)
     \xrightarrow{Transposit.}
     \bigl(R_{i-1}, L_{i-1}\oplus f_{K_{i}}(R_{i-1}) \bigr)
\end{gather*}
(Anm.: $\oplus$ ist das Exclusive-Oder \texttt{xor})

\begin{figure}
  \centering
  \input{feistel.pdf_t}
  \caption{Schematische Darstellung der Feistel"=Chiffre}
  \label{fig:feistel}
\end{figure}

Für die Entschlüsselung einer Nachricht kann man den gleichen Algorithmus mit
der umgekehrten Schlüsselfolge $K_{i}':= K_{r+1-i}$ (für $i=1,\dotsc,r$) auf
$c=(L_{0}', R_{0}')=(L_{r}, R_{r})$ verwenden und einfach die verschlüsselte
Nachricht nochmals verschlüsseln. Dies hat zum Einen den Vorteil, dass man die
gleiche Hard"~/""Software auf der Sender- und Empfängerseite einsetzen kann,
und zum Anderen kann die Funktion~$f$ sehr kompliziert sein, da man nicht
deren inverse Funktion benötigt.

Bei der Entschlüsselung gilt in allen Runden $i=1,\dotsc,r$ der Zusammenhang
$(L_{i}', R_{i}') = (L_{r-i}, R_{r-i})$ und für die letzte Runde ergibt sich
dann der Klartext der Nachricht als $(L_{r}', R_{r}') = (L_{0}, R_{0})$.

\begin{align*}
  (L_{1}', R_{1}') &= \bigl(R_{0}',\; L_{0}' \oplus f_{K_{1}'}(R_{0}')\bigr)
     &\text{nach \eqref{eq:feistel}}\\
  &= \bigl(R_{r},\; L_{r}\oplus f_{K_{r}}(R_{r}) \bigr) &\text{nach IV.}\\
  &= \bigl(R_{r-1},\; \bigl(L_{r-1} \oplus f_{K_{r}}(R_{r-1})\bigr) \oplus
     f_{K_{r}}(R_{r-1}) \bigr) &\text{nach \eqref{eq:feistel-last}}\\
  &= (R_{r-1}, L_{r-1}) &\text{da~}a\oplus a=a\displaybreak[0]\\[1.5ex]
  (L_{n}', R_{n}') &= \bigl(R_{n-1}',\; L_{n-1} \oplus f_{K_{n}'}(R_{n-1}')
     \bigr) & \text{nach \eqref{eq:feistel}}\\
  &= \bigl(L_{r-n+1},\; R_{r-n+1} \oplus f_{K_{r+1-n}}(L_{r-n+1})\bigr)
     &\text{nach IV.}\\
  &= \bigl(R_{r-n},\; \bigl(L_{r-n}\oplus f_{K_{r-n+1}}(R_{r-n})\bigr) \oplus
     f_{K_{r+1-n}}(R_{r-n}) &\text{nach \eqref{eq:feistel}}\\
  &= (R_{r-n}, L_{r-n})
\end{align*}

% 15.11.

Da die Schlüsselfolge $K_{1},\dotsc, K_{r}$ für die Ver- und Entschlüsselung
aus dem gleichen (Haupt"~)""Schlüssel erzeugt wird, ist die Feistel"=Chiffre
eine symmetrische Verschlüsselung.

Die Sicherheit der gesamten Verschlüsselung beruht auf der Eigenschaft, dass
die Substitution, genauer die Funktion~$f_{K_{i}}$, eine nicht lineare
Transformation ist. Wäre $f_{K_{i}}$ eine lineare Transformation, so wäre auch
die Verkettung von Substitution und Translation\footnote{$\begin{pmatrix}R&L
\end{pmatrix} = \begin{pmatrix}L& R\end{pmatrix}\cdot
(\begin{smallmatrix}0& 1\\1& 0\end{smallmatrix})$} in jeder Runde eine lineare
Transformation. Man könnte also den gesamten Verschlüsselungsvorgang mit einer
einzigen linearen Gleichung beschreiben. Die Funktion $\oplus$ ist
linear, da sich leicht zeigen lässt, dass $f(ax+by)=af(x)+bf(y)$ mit
$f(x)= f(x_1, x_2)= x_1\oplus x_2= x_1 + x_2 \mod 2$ für $x_1, x_2 \in
\mathbb{F}_2$ folgt.

Ist die Funktion~$f$ eine krytographisch sichere Pseudozufallsfunktion, so
haben Michael Luby unnd Charles Rackoff gezeigt, reichen drei Runden um eine
Pseudozufallspermutation zu erreichen. Mit vier Runden bekommt man sogar eine
starke Pseudozufallspermutation.\footnote{Geklaut aus der
\href{http://en.wikipedia.org/wiki/Feistel_cipher}{englischen Wikipedia}, die
selbst auf "`M. Luby and C. Rackoff. ``How to Construct Pseudorandom
Permutations and Pseudorandom Functions.'' In SIAM J. Comput.,
vol. 17, 1988, pp. 373-386."' verweist.}

% Angenommen: $f_{K_{i}}$ ist linear:
% \begin{gather*}
%   f_{K_{i}}(R_{i-1}) = R_{i-1}\cdot A_{i} + b\qquad
%      A_{i}\in \Z_{2}^{(n\times n)}, b_{i} \in \Z_{2}^{(1\times n)}
% \end{gather*}
% dann ist die Substitution:
% \begin{gather*}
%   (L_{i-1}\oplus f_{K_{i}}(R_{i-1}), R_{i-1}) = (L_{i-1}, R_{i-1})\cdot
%      \begin{pmatrix}
%        E_{n} & 0_{n}\\
%        A_{i} & E_{n}
%      \end{pmatrix}
%      + (b_{i}, 0)
% \end{gather*}

\section{DES -- Data Encryption Standard}\label{sec:des}

Der \highl{Data Encryption Standard} (\highl{DES}) wurde in den
1970ern von IBM für eine Ausschreibung des US~National Bureau of
Standards\footnote{wurde später in
  \href{http://www.nist.gov/}{National Institute of Standards and
    Technology (NIST)} umbenannt} entwickelt. Er basiert auf den
vorangegangenen Entwicklungen des Projekts Lucifer, das die
Feistel"=Chiffre entwickelt hatte. Am 23.\,November 1976 wurde DES als
Standard für die Verschlüsselung in den amerikanischen Bundesbehörden
anerkannt und im Januar 1977 erfolgte die Veröffentlichung als
\href{http://csrc.nist.gov/publications/fips/fips46-3/fips46-3.pdf}{FIPS
  PUB 46}.

Die International Organization for Standardization~(ISO) übernahm den
Algorithmus unter der Bezeichnung "`Data Encipherment No.\,1"'~(DEA-1) in ihr
Verzeichnis.

Die Kryptographen Eli Biham und Adi Shamir entwickelten gegen Anfang
der 90er Jahre die differentielle Kryptoanalyse als Spezialform der
Kryptoanalyse. Dabei wird untersucht, wie sich das Chiffrat bei
unterschiedlichem Input ändert. Das Verfahren wandten sie auch auf DES
an\footnote{Biham, E. and A. Shamir. (1990). Differential
  Cryptanalysis of DES-like Cryptosystems. Advances in Cryptology "=
  CRYPTO
  '90. Springer-Verlag. 2?21.}\footnote{\href{http://www.cs.technion.ac.il/users/wwwb/cgi-bin/tr-get.cgi/1991/CS/CS0708.ps}{Eli
    Biham, Adi Shamir,"Differential Cryptanalysis of the Full 16-Round
    DES, CS 708, Proceedings of CRYPTO 92, Volume 740 of Lecture
    Notes in Computer Science, December 1991.}}.
Das Verfahren erfordert bei DES $2^{47}$ frei gewählte Klartexte und
nach Angaben von IBM war dieser Angriff seit 1974 bekannt. Eines der
Designziele von DES war die Absicherung gegen die differentielle
Kryptoanalyse.

Die fortschreitende Weiterentwicklung der Rechenkraft führte letztlich
dazu, dass ein Brute-Force-Angriff gegen DES erfolgreich wird. So
wurde 1997 das erste Mal eine verschlüsselte Nachricht gebrochen. Ein
Jahr später gelingt es der Electronic Frontier Foundation~(EFF) mit
dem eigens dafür angefertigten Supercomputer "`Deep Crack"', der 88
Milliarden Schlüssel pro Sekunde testen konnte, binnen 56~Stunden eine
Verschlüsselung zu brechen. Ein halbes Jahr später im Januar~1998
gelang es durch die Zusammenarbeit von Deep Crack und
\href{http://distributed.net}{distributed.net} einen DES"=Schlüssel in
22~Stunden und 15~Minuten zu ermitteln --~mehr als 245 Milliarden
Schlüssel wurden pro Sekunde getestet.

Im Jahr~1999 wird DES als Standard für die Verschlüsselung der
amerikanischen Bundesbehörden widerrufen und schließlich 2002 durch den
Advanced Encryption Standard~(AES) ersetzt.

DES arbeitet nach dem gleichen Prinzip wie die Feistel"=Chiffre und ist
damit eine symmetrische Blockchiffre. Die Schlüssellänge für die
Verschlüsselung beträgt 64~Bit, wobei ein Bit pro Byte als Prüfbit verwendet
wird, was den effektiven Schlüsselraum~$\mathcal{K} =\{0,1\}^{56}$ auf 56~Bit
reduziert.

DES arbeitet mit 16 Runden. Aus dem Schlüssel~$k\in\mathcal{K}$ werden
16~Teilschlüssel $k_{1}, k_{2},\dotsc, k_{16}$ der Länge $\abs{k}=16$
generiert, die jeweils in einem $SBB$ (Standard Building Block) verwendet
werden.

Die Nachricht wird in Blöcke~$m$ der Länge~64 aufgeteilt und nach einer
initialen Permutation~$IP$ in den 16~SBB tranformiert und anschließend noch
mal mit $IP^{-1}$ permutiert.

Schema:
\begin{gather*}
  % Eine Runde "`Zeichnen für arme Leute"' :-))
  \xrightarrow[64]{m}
     \raisebox{-1.6ex}{\framebox{\rule{0pt}{5.5ex}$IP$}}\:
     \begin{split}
       \xrightarrow[32]{}\\
       \xrightarrow[32]{}\\
     \end{split}
     \stackrel{K_{1}\downarrow 48}%
              {\raisebox{-1.6ex}{\framebox{\rule{0pt}{5.5ex}$SBB_{1}$}}}
     \begin{split}
       \xrightarrow[32]{}\\
       \xrightarrow[32]{}\\
     \end{split}
     \stackrel{K_{2}\downarrow 48}%
              {\raisebox{-1.6ex}{\framebox{\rule{0pt}{5.5ex}$SBB_{2}$}}}
     \dotso
     \stackrel{K_{15}\downarrow 48}%
              {\raisebox{-1.6ex}{\framebox{\rule{0pt}{5.5ex}$SBB_{15}$}}}
     \begin{split}
       \xrightarrow[32]{}\\
       \xrightarrow[32]{}\\
     \end{split}
     \stackrel{K_{16}\downarrow 48}%
              {\raisebox{-1.6ex}{\framebox{\rule{0pt}{5.5ex}$SBB_{16}$}}}
     \begin{split}
       \xrightarrow[32]{}\\
       \xrightarrow[32]{}\\
     \end{split}
     \:\raisebox{-1.6ex}{\framebox{\rule{0pt}{5.5ex}$IP^{-1}$}}
     \xrightarrow[64]{C}
     % und wer hat jetzt Lust das Bild auszumalen?
\end{gather*}

Runde~$i$: Die Eingabe wird in eine linke und reche Hälfte $(L,R)$ geteilt.
Die Ausgabe $(L', R')$ wird erzeugt durch $L'=R$ und $R'$ auf folgende Weise:
\begin{enumerate}
 \item Diffusionsschritt: Aus $R$ wird ein 48-Bit-Wort $R_{1}$ erzeugt
 \item $R_{2}= R_{1}\oplus K_{i}$
 \item Konfusionsschritt: aus $R_{2}$ wird durch eine nicht lineare
  Transformation~$S$ ein 32-Bit-Wort $R_{3}$ erzeugt

  $S$: Zerlegen in 8 Worte der Länge~6 und diese mit $S_{i}$ zur 8 Worten der
  Länge~4 verknuddeln und diese wieder zu einem 32-Bit-Wort zusammenkleben.
 \item Permutation von $R_{3}$ erzeugt $R_{4}$
 \item $R' = L\oplus R_{4}$
\end{enumerate}

\todo{Hier gab es ein tolles Schema. Wollen wir das?}

Vereinbarung: Die gesamte Transformation bei einem kompletten Durchlauf
beschreiben wir als $c= DES_{k}(m)$

Abwandlungen zur Erhöhung der Sicherheit von DES:
\begin{itemize}
 \item $c = DES_{k_{2}}\bigl( DES_{k_{1}}(m) \bigr)$ keine wesentliche
  Erhöhung der Sicherheit, da es einfach nur die Rundenzahl erhöht.

 \item $c = DES_{k_{1}}\bigl( DES_{k_{2}}^{-1}( DES_{k_{1}}(m) ) \bigr)$ mit
  chosen-plain-text-Angriff ist dies auch leicht knackbar.

 \item $c= DES_{k_{3}}\bigl( DES_{k_{2}}^{-1}( DES_{k_{1}}(m) ) \bigr)$
  wird als \highl{Triple-DES} (\highl{3DES}) bezeichnet.
\end{itemize}
Was ist der Unterschied zwischen $DES^{-1}_{k}$ und $DES_{k^{T}}$? DES
beschreibt auch, wie die Teilschlüssel erzeugt werden und daher ist $k^{T}$
nicht der permutierte Schlüssel, der bei $DES^{-1}_{k}$ verwendet wird.

% 20.11.

\subsection{Ein Beispiel einer vereinfachten DES-Verschlüsselung}

$n = 12$ und $\abs{L} = \abs{R} = 6$
\todo{Bild}

Ausgangsschlüssel~$k$ der Länge 9, Rundenschlüssel: $k_{1}, k_{2}, \dotsc$

Erzeugung der Rundenschlüssel: das 1.\,Bit von $k_{i}$ ist das $i$.\,Bit von
$k$ gefolgt von den nächsten 7~Bits in zyklischer Reihenfolge.
$k=(\kappa_{1}\dotso\kappa_{9})$ $\rightarrow$ $k_{i} = (\kappa_{i}
\kappa_{i+1}\dotso\kappa_{i+7})$; $k_{i} = k_{i+9} = k_{i+18} = \dotsb$

\begin{enumerate}[1.\,{Schritt}]
 \item Diffusion $D\colon \Z_{2}^{6} \mapsto \Z_{2}^{8}$ (wobei $R_{1}=D(R)$)
  mit
  \begin{gather*}
    D(\alpha_{1},\dotsc,\alpha_{6}) = (\alpha_{1}, \alpha_{2}, \alpha_{4},
       \alpha_{3}, \alpha_{4}, \alpha_{3}, \alpha_{5},\alpha_{6})
  \end{gather*}
  Damit ist $D$ eine lineare Abbildung:
  \begin{gather*}
    D(\alpha) = \alpha \cdot
       \begin{pmatrix}
         1& 0& 0& 0& 0& 0& 0& 0\\
         0& 1& 0& 0& 0& 0& 0& 0\\
         0& 0& 0& 1& 0& 1& 0& 0\\
         0& 0& 1& 0& 1& 0& 0& 0\\
         0& 0& 0& 0& 0& 0& 1& 0\\
         0& 0& 0& 0& 0& 0& 0& 1
       \end{pmatrix}
  \end{gather*}

 \item $R_{2} = R_{1} \oplus k_{i}$

 \item Transformation mit zwei $S$-Boxen; eine $S$-Box ist eine Permutation
  der Zahlen $\{0,\dotsc,7\}$ in jeweils zwei Zeilen:
  \begin{gather*}
    \sigma_{1} =
       \begin{pmatrix}
         5& 2& 1& 6& 3& 4& 7& 0\\
         1& 4& 6& 2& 0& 7& 5& 3
       \end{pmatrix}\\
    \sigma_{2} =
       \begin{pmatrix}
         4& 0& 6& 5& 7& 1& 3& 2\\
         5& 3& 0& 7& 6& 2& 1& 4
       \end{pmatrix}
  \end{gather*}

  Die Eingabe für jede $S$-Box ist ein 4-Bit-Wort: dazu $R_{2} = (A, B)$ und
  damit ist $A\in \Z_{2}^{4}$ die Eingabe für $S_{1}$ und $B\in\Z_{2}^{4}$ die
  Eingabe für $S_{2}$. Das erste Bit der Eingabe gibt die Zeile in der $S$-Box
  an: 0 für die erste und 1 für die zweite Zeile. Die verbleibenden drei Bits
  beschreiben eine Zahl zwischen 0 und 7 und legen die Spalte fest: 000 ist
  die erste Spalte, \dots, 111 für die achte Spalte.

  Der Eintrag an dieser Position ist die Ausgabe der $S$-Box. Formal: $S\colon
  \Z_{2}^{4} \mapsto \Z_{2}^{3}$ wobei
  \begin{gather*}
    (\alpha_{1},\dotsc,\alpha_{4}) \mapsto \sigma\bigl(\alpha_{1}+1,
       bin^{-1}(\alpha_{2},\alpha_{3},\alpha_{4})\bigr)
  \end{gather*}

  $R_{3} = \bigl(S_{1}(A), S_{2}(B)\bigr)$
\end{enumerate}

\begin{bsp}
  $K=(0100\,11001), R=(101011)$ Frage: Was ist $f_{k_{4}}(R)$

  \begin{enumerate}[1.\,{Schritt}]
    \addtocounter{enumi}{-1}
   \item Bestimme $k_{4} = (0110\,0101)$
   \item Bestimme $R_{1} = D(R) = (1001\,0111)$
   \item Bestimme $R_{2} = R_{1}\oplus k_{4} = (1111\,0010)$
   \item $A=(1111), B=(0010)$ $S_{1}(A) = S_{1}(1\,111) = (011)$ und $S_{2}(B)
    = S_{2}(0\,010) = (110)$
  \end{enumerate}
  $\Rightarrow$ $f_{k_{4}}(R) = (011\,110)$

  Wie sieht die gesamte 4.\,Runde des vereinfachten DES aus?

  Angenommen: $(L_{3}\: R_{3}) = (001\,111\: 101\,011) \in \Z_{2}^{12}$, dann
  ist $(L_{4}\: R_{4}) = (R_{3}\: L_{3}\oplus f_{k_{4}}(R_{3})) = (101\,011\:
  010\,001)$
\end{bsp}

Wo ergeben sich jetzt Angriffspunkte?

\subsection{Analyse des DES -- Differentielle Kryptoanalyse}

Methode von Bahim und Shamir aus dem Jahr 1990. Methode speziell für DES
entwickeln, funktioniert aber auch bei ähnlichen Verfahren.

\highl{Chosen-Plaintext-Attack}: Der Angreifer kennt den Algorithmus, das Verfahren
zur Erzeugung der Rundenschlüssel, die Diffusion und die $S$-Boxen. Er kennt
nicht den Schlüssel~$k=(\kappa_{1}\dotso\kappa_{9})$

Wir setzen weiter vorraus, dass der Angreifer für einen Klartext~$(L_{0},
R_{0})$ das Resultat~$(L_{r}, R_{r})$ kennt.

Idee: Analysiere Differenzen (modulo 2) verschiedener Klartextblöcke im
Vergleich zu den verschlüsselten Blöcken.

Zwei Blöcke
\begin{gather*}
  (L_{0}, R_{0}), (L_{0}', R_{0}') \mapsto (L_{0}\oplus L_{0}', R_{0}\oplus
     R_{0}')\\
  (L_{r}, R_{r}), (L_{r}', R_{r}') \mapsto (L_{r}\oplus L_{r}', R_{r}\oplus
     R_{r}')
\end{gather*}

Warum ist ein solcher Ansatz erfolgsversprechend?
\begin{itemize}
 \item Differenzen ändern sich nicht, wenn zu zwei Blöcken ein und derselbe
  Block (Rundenschlüssel) addiert wird.

 \item Eigenschaften der $S$-Boxen: Es gibt für einie
  Differenzen~$D\in\Z_{2}^{4}$, so dass für viele Eingabepaare mit dieser
  Differenz~$D$ die Ausgabepaare wieder die Differenz haben.
\end{itemize}

\begin{bemerk}
  Man muss bei der Konstruktion der $S$-Boxen darauf achten, diese Eigenschaft
  zu vermeiden oder zu mindern.
\end{bemerk}

nun konkret am oberen Beispiel: Für zwei Eingabeblöcke $A$ und $A'$ für
$S_{1}$ heißt $A\oplus A'$ \highl{Eingabedifferenz} (Input"=Differenz) und
$S_{1}(A)\oplus S_{1}(A')$ \highl{Ausgabedifferenz} (Output"=Differenz).

Es sei $A^{*}\in\Z_{2}^{4}$ beliebig. Für alle Paare $(A, A')\in
\Z_{2}^{4}\times \Z_{2}^{4}$ mit der Eigenschaft $A\oplus A'=A^{*}$ können wir
die Ausgabedifferenzen bestimmen. $S_{1}(A)\oplus S_{1}(A')$ und deren
Verteilung in einer Tabelle festhalten.

Beachte dabei folgendes: Für $A^{*}\ne(0000)$ gibt es genau \textit{acht}
Belegungen $\{A,A'\}$ mit $A\oplus A'=A^{*}$, nämlich $\{A, A\oplus A^{*}\}$.

% 22.11.

\subsection{Differentielle Kryptoanalyse}

$A, A'\in\Z_{2}^{4}$ als Eingabe für $S_{1}$\\
$A\oplus A'$ ist die Input-Differenz\\
$S_{1}(A)\oplus S_{1}(A')$ ist die Output-Differenz\\
Für jeder Differenz $A^{*}\in\Z_{2}^{4}$ ($A^{*}\ne(0000)$) gibt es acht
Mengen $\{A,A'\} = \{A, A\oplus A^{*}\}$ mit dieser Differenz $A^{*}$

\begin{bsp}
  \begin{gather*}
    S_{1} =
       \begin{pmatrix}
         5& 2& 1& 6& 3& 4& 7& 0\\
         1& 4& 6& 2& 0& 7& 5& 3
       \end{pmatrix}
       \qquad A^{*}=(0011)\\
    \begin{array}{cc|c}
      A & A'& S_{1}(A)\oplus S_{1}(A')\\
      \hline
      (0000)& (0011)& (101)\oplus(110) = (011)\\
      (0001)& (0010)& (010)\oplus(001) = (011)\\
      (0100)& (0111)& (011)\oplus(000) = (011)\\
      (0101)& (0110)& (100)\oplus(111) = (011)\\
      \hline
      (1000)& (1011)& (001)\oplus(010) = (011)\\
      (1001)& (1010)& (100)\oplus(110) = (010)\\
      (1100)& (1111)& (000)\oplus(011) = (011)\\
      (1101)& (1110)& (111)\oplus(101) = (010)
    \end{array}
  \end{gather*}
\end{bsp}
Theoretisch sind acht verschiedene Ergebnisse möglich, aber einige treten
häufiger auf als andere. Es gibt 15 derartige Tabellen für $S_{1}$ und
$S_{2}$ (insgesamt 30).

unser Ansatz zunächst: Was passiert beider Verschlüsselung zweier
Klartextblöcke $(L_{i-1}, R_{i-1})_{12 Bit}$ und $(L_{i-1}', R_{i-1}')_{12 Bit}$ in Runde~$i$?
\begin{enumerate}[1.\,{Schritt}]
 \item Diffusion (oder Expansion) $D(R_{i-1})_{8 Bit}$
 \item $(D(R_{i-1})\oplus k_{i})_{8 Bit} = (A_{4 Bit}, B_{4 Bit})$
 \item $(S_{1}(A)_{3 Bit}, S_{2}(B)_{3 Bit})_{6 Bit} = f_{k_{i}}(R_{i-1})_{6
   Bit}$
\end{enumerate}

genauso für den zweiten Klartextblock $(L_{i-1}', R_{i-1}')$, aber genauer:
\begin{gather*}
  R_{i-1}'\\
  \downarrow\\
  D(R_{i-1}') = (\tilde{A}', \tilde{B}') \qquad k_{i} = ((k_{i}^{L})_{4Bit},
     (k_{i}^{R})_{4Bit})\\
  D(R_{i-1}')\oplus k_{i} = (\tilde{A}'\oplus k_{i}^{L}, \tilde{B}'\oplus
     k_{i}^{R}) = (A', B')\\
  \downarrow\\
  (S_{1}(A'), S_{2}(B')) = f_{k_{i}}(R_{i-1}')
\end{gather*}

Es gilt:
\begin{gather*}
  A\oplus A' = (\tilde{A} \oplus k_{i}^{L}) \oplus (\tilde{A}'\oplus
     k_{i}^{L}) = \tilde{A}\oplus \tilde{A}'\\
  B\oplus B' = (\tilde{B} \oplus k_{i}^{L}) \oplus (\tilde{B}'\oplus
     k_{i}^{L}) = \tilde{B}\oplus \tilde{B}'
\end{gather*}
aber die Output-Differenz $S_{1}(A)+S_{1}(A')$ hängt vom Schlüssel~$k_{i}^{L}$
ab. Wenn $S_{1}$ nicht linear ist, dann gilt i.\,A. nicht.
\begin{gather*}
  S_{1}(A)\oplus S_{1}(A') = S_{1}(A\oplus A')
\end{gather*}
Annahme: Wir kennen $\tilde{A}, \tilde{A}'$ und $S_{1}(A), S_{1}(A')$.

Es gilt:
\begin{enumerate}
 \item $A$ und $A'$ haben die Input-Differenz $A\oplus A' = A^{*} =
  \tilde{A}\oplus \tilde{A}'$
 \item $A$ und $A'$ haben die Output-Differenz $C^{*}=S_{1}(A)\oplus S_{1}(A')$
\end{enumerate}

Weiterhin gilt: $\{A, A'\}$ kommt in der Tabelle für $A^{*}$ vor und man
erkennt alle Möglichkeiten für $\{A,A'\}$ die Output-Differenz $C^{*}$ zu
bilder. Da $\tilde{A}$ und $C^{*}$ bekannt sind und $A=\tilde{A}\oplus
k_{i}^{L}$ ergben sich auf diese Weise Einschränkungen für die Wahl von
$k_{i}^{L}$.

\begin{bsp}
  Illustration am oberen Beispiel: $\tilde{A}=(0100), \tilde{A}'=(0110),
  C^{*}=S_{1}(A)\oplus S_{1}(A')=(010), \tilde{A}\oplus \tilde{A}' = (0011) =
  A^{*}$

  Tabelle: $A\in\{(1001), (1010), (1101), (1110)\}$ nun gilt weiter $k_{i}^{L}
  = A\oplus \tilde{A} cmi\{ (1101), (1110), (1001), (1010)\}$
\end{bsp}

Das war jetzt für einen Klartextblock, mit einem weitern Klartextblock kann
man eine weitere Schlüsselmenge finden. Der tatsächliche Schlüssel liegt im
Durchschnitt beider Teilmengen.

Dies Ganze so oft bis der (Runden"~)""Schlüssel eindeutig bestimmt ist.

\subsubsection{Differentielle Kryptoanalyse für ein System mit drei Runden}

Der obige Ansatz ist ausreichend für eine Analyse von drei Runden.
Ausgangspunk: zwei Klartextblöcke wie eben $(L_{0}, R_{0}), (L_{0}', R_{0}')$
und die zugehörigen Geheimtextblöcke $(L_{3}, R_{3}), (L_{3}', R_{3}')$. Es
gilt:
\begin{align*}
  L_{3} &= L_{2}\oplus f_{k_{3}}(R_{2}) = R_{1}\oplus f_{k_{3}}(R_{2}) =
     L_{0}\oplus f_{k_{1}}(R_{0})\oplus f_{k_{3}}(R_{2})\\
  L_{3}' &= L_{0}'\oplus f_{k_{1}}(R_{0}')\oplus f_{k_{3}}(R_{2}')
\end{align*}
Wir wählen die Klartextblöcke, so dass $R_{0}=R_{0}'$ gilt.
Setzen die Output-Differenz $L_{3}^{*} := L_{3}\oplus L_{3}'$.
\begin{gather*}
  L_{3}^{*} = \underbrace{L_{0}\oplus L_{0}'}_{=L_{0}^{*}} \oplus
     f_{k_{3}}(R_{2}) \oplus f_{k_{3}}(R_{2}')\\
  L_{3}^{*}\oplus L_{0}^{*} = f_{k_{3}}(R_{2}')\oplus f_{k_{3}}(R_{2}') =
     f_{k_{3}}(R_{3})\oplus f_{k_{3}}(R_{3}'), da R_{2}=R_{3} und R_{2}'=R_{3}'
\end{gather*}
Wir kennen also $R_{3}=R_{2}$ und damit $D(R_{2}) = (\tilde{A}, \tilde{B})$
und $R_{3}'=R_{2}'$ und damit $D(R_{2}') = (\tilde{A}', \tilde{B}')$.

Die linke Hälfte von $f_{k_{3}}(R_{3})\oplus f_{k_{3}}(R_{3}') =
S_{1}(\tilde{A})\oplus S_{1}(\tilde{A}')$ und sind in der Situation wie oben.

% 27.11.

\begin{gather*}
  S_{2} = \begin{pmatrix}
            4& 0& 6& 5& 7& 1& 3& 2\\
            5& 3& 0& 7& 6& 2& 1& 4
          \end{pmatrix}
     \qquad
     B^{*} = \begin{pmatrix}1& 0& 1& 1\end{pmatrix}
\end{gather*}

\subsection{Zusfa.: Differentielle Kryptoanalyse für DES mit drei Runden}

\begin{align*}
  L_{0}^{*} &= L_{0}\oplus L_{0}'\\
  L_{3}^{*}& = L_{3}\oplus L_{3}' = L_{0} \oplus f_{K_{3}}(R_{2}) \oplus
     f_{K_{3}}(R_{2}')\\
  L_{3}^{*} \oplus L_{0}^{*} & = f_{K_{3}}(R_{3})\oplus f_{K_{3}}(R_{3}')&
     \text{da,~} R_{3}=R_{2}, R_{3}'=R_{2}'
\end{align*}

Mit $R_{2}$ kennen wir $D(R_{2}) = (\tilde{A}, \tilde{B})$ und $D(R_{2}') =
(\tilde{A}', \tilde{B}')$.

linke Hälfte: $S_{1}(\tilde{A}\oplus K_{3}^{L}) \oplus S_{1}(\tilde{A}'\oplus
K_{3}^{L})$\\
rechte Hälfte: $S_{2}(\tilde{B}\oplus K_{3}^{R})\oplus S_{2}(\tilde{B}'\oplus
K_{3}^{R})$

$R_{0}=R_{0}'$

Beispiel:
\begin{align*}
  (L_{0}, R_{0})& = (000\,111, 011\,011)\\
  (L_{0}', R_{0}')& = (101\,110, 011\,011)\\
  (L_{3}, R_{3})& = (100\,101, 000\,011)\\
  (L_{3}', R_{3}')& = (011\,000, 100\,100)
\end{align*}

Ziel: Bestimme den Schlüssel~$K$ (bzw. Einschränkung der Möglichkeiten)

\begin{align*}
  R_{2}& = R_{3} = (000\,011)& D(R_{2})& =(0000, 0011) = (\tilde{A},\tilde{B})\\
  R_{2}'& = R_{3}' = (100\,100)& D(R_{2}')& =(1010, 1000) =
     (\tilde{A}',\tilde{B}')
\end{align*}

Eingabedifferenz in $S$-Box $S_{1} = \tilde{A}\oplus\tilde{A}' = (1010)$\\
Ausgabedifferenz von $S_{1}$: linke Hälfte von $L_{3}^{*}\oplus L_{0}^{*}$

linke Hälfte von $L_{3}^{*}\oplus L_{0}^{*}$
\begin{gather*}
  L_{3}^{*} = (100\,101)\oplus (011\,000) = (111\,101)\\
  L_{0}^{*} = (000\,111)\oplus (101\,110) = (101\,001)\\
  L_{3}^{*} \oplus L_{0}^{*} = (010\,100)
\end{gather*}

Die Ausgabedifferenz von $S_{1}$ ist $(010)$. kam in der Tabelle oben \todo{link
finden} zweimal vor. $A\in \{(0011), (1001)\}$

$K_{3}^{L} = A\oplus \tilde{A} = \{(0011), (1001)\}$ zwei Möglichkeiten.

Eingabedifferenz der $S$-Box $S_{2}$:
\begin{gather*}
  \tilde{B}\oplus \tilde{B}' = (0011)\oplus (1000) = (1011)
\end{gather*}
Ausgabedifferenz der $S$-Box $S_{2}$: rechte Hälfte von $L_{3}^{*}\oplus
L_{0}^{*}$: $(100)$.

liefert die Schlüssel $K_{3}^{R}\in\{(1111),(0100)\}$ zwei Möglichkeiten
$\rightarrow$ vier Möglichkeiten für $K_{3}$ und damit acht Möglichkeiten für
$K$ statt 512.

\begin{gather*}
  \begin{array}{c|c|c|c|cl}
    \tilde{B}& \tilde{B}'& S_{2}(\tilde{B})& S_{2}(\tilde{B}')&
    S_{2}(\tilde{B})\oplus S_{2}(\tilde{B}')\\
    \hline
    (0000)& (1011)& (100)& (111)& (011)\\
    (0001)& (1010)& (000)& (000)& (000)\\
    (0010)& (1001)& (110)& (011)& (101)\\
    (0011)& (1000)& (101)& (101)& (000)\\
    (0100)& (1111)& (111)& (100)& (011)\\
    (0101)& (1110)& (001)& (001)& (000)\\
    (0110)& (1101)& (011)& (010)& (001)\\
    (0111)& (1100)& (010)& (110)& (100)& (*)
  \end{array}\\
  (*)\quad B=\{(0111), (1100)\}\qquad K_{3}^{R}= B\oplus \tilde{B} = \{(0100),
     (1111)\}
\end{gather*}

Brauchen ein zweites Klartextpaar: z.\,B. $(L_{0}, R_{0}) = (010\,111,
011\,011)$ und $(L_{0}', R_{0}') = (101\,110, 011\,011)$ mit $(L_{3}, R_{3}) =
(001\,010, 001\,011)$ und $(L_{3}', R_{3}') = (011\,000, 100\,100)$.

1.\,Aufgabe: Bestimme $K_{3}^{L}$ und $K_{3}^{R}$. 2.\,Aufgabe: Bestimme $K$.

Angenommen $K_{3} = (x_{1} x_{2} x_{3} x_{4} x_{5} x_{6} x_{7} x_{8})$.
Dann hat $K$ die Gestalt $K=(x_{p} x_{1} x_{2} x_{3} x_{4} x_{5} x_{6} x_{7})$.
\begin{align*}
  L_{3} = L_{2}\oplus f_{k_{3}}(R_{2})& = R_{1}\oplus f_{k_{3}}(R_{2})\\
  & L_{0}\oplus f_{k_{1}}(R_{0})
\end{align*}

\subsection{Differentielle Analyse des DES mit vier Runden}

Ansatz: "`Eigenschaft 2"': Es gibt einige Differenzen~$D$, so dass es
"`viele"' Eingabepaare mit der Differenz~$D$ gibt, derart dass die
Ausgabedifferenzen übereinstimmen.

Beispiel: $S$-Box $S_{1}$ liefert für $D=A^{*} = (0011)$ in 6~von 8~Fällen die
Ausgabedifferenz $(011)$. $S_{1}(A)\oplus S_{1}(A')$. Das heißt: Für $A^{*} =
(0011)$ erwarten wir mit einer Wahrscheinlichkeit von $\frac{3}{4}$ die
Ausgabedifferenz $(011)$.

$S$-Box $S_{2}$ liefert für
$D=B^{*}=(1100)$ in 4~von 8~Fällen die Ausgabedifferenz $(010)$.
Das heißt: Für $B^{*}=(1100)$ erwarten wir mit einer Wahrscheinlichkeit von
$\frac{1}{2}$ die Ausgabedifferenz $(010)$.

Idee: Für Paare von Klartextblöcken $(L_{0}, R_{0})$ wird $(L_{0}', R_{0}')$
mit $L_{0}\oplus L_{0}' = (0011)$ und $R_{0}\oplus R_{0}' = (1100)$ erwarten
wir (beim richtigen Schlüssel) mit Wahrscheinlichkeit $\frac{3}{4}-\frac{1}{2}
= \frac{3}{8}$ die Ausgabedifferenz $(011\,010)$.

% 29.11.

\subsection{Analyse für vier Runden}

Ansatz: Nichtgleichverteilung der Output-Differenzen.\\
Idee: Versuchen eine Situation nach einer Runde so zu erreichen, dass wir dann
die 3-Rundenanalyse ansetzten können.

Dazu wählen wir Paare von Klartextblöcken $(L_{0}, R_{0})$ und $(L_{0}',
R_{0}')$ mit folgenden Eigenschaften:
\begin{enumerate}
 \item $R_{0}^{*} = R_{0}\oplus R_{0}' = (001\,100)$

  Bei der Bildung von $f_{K_{1}}(R_{0})$ und $f_{K_{1}}(R_{0}')$ passiert
  folgendes:
  \begin{gather*}
    D(R_{0})\oplus D(R_{0}') = (00111100)
  \end{gather*}
  Input für $S_{1}$ ist $(0011)$ für $S_{2}$ ist es $(1100)$.

  für $(0011)$ erwarten wir mit Wahrscheinlichkeit $\frac{3}{4}$ den Output
  $(011)$ bei $S_{1}$ und für $(1100)$ erwarten wir mit Wahrscheinlichkeit
  $\frac{1}{2}$ den Output $(010)$ bei $S_{2}$.

  Wir betrachten die Outputs der beiden $S$-Boxen als unabhängig und erwarten
  deshalb mit Wahrscheinlichkeit $\frac{3}{4}\cdot\frac{1}{2}=\frac{3}{8}$
  eine Gesamt-Output-Differenz von $f_{K_{1}}(R_{0})\oplus f_{K_{1}}(R_{0}') =
  (011\,010)$

 \item $L_{0}^{*} = L_{0} \oplus L_{0}' = (011\,010)$

  $R_{1}= L_{0}\oplus f_{K_{1}}(R_{0}), R_{1}' = L_{0}'\oplus
  f_{K_{1}}(R_{0}')$. Für den Fall $f_{K_{1}}(R_{0}) \oplus f_{K_{1}}(R_{0}')
  = (011\,010)$ ergibt sich:
  \begin{align*}
    R_{1}\oplus R_{1}' &= (L_{0}\oplus L_{0}') \oplus (f_{K_{1}}(R_{0}) \oplus
       f_{K_{1}}(R_{0}))\\
    & = (011\,010) \oplus (011\,010) = (000\,000)
  \end{align*}
  Da $R_{1} = R_{0}$ und $L_{1}' = R_{0}'$ gilt mit Wahrscheinlichkeit
  $\frac{3}{8}$, dass $(L_{1}, R_{1})$ und $(L_{1}', R_{1}')$ die Eigenschaft
  $R_{1}=R_{1}'$ haben und $(L_{1}\oplus R_{1})\oplus (L_{1}', R_{1}') =
  (R_{0}\oplus R_{0}', 0\dotso 0) = (001\,100, 000000)$.
\end{enumerate}

Strategie: Wähle Klartextpaare $(L_{0}, R_{0})$ und $(L_{0}', R_{0}')$ mit der
Summe $(011\,010, 001\,100)$ und bestimme dazu $(L_{4}, R_{4})$ und $(L_{4}',
R_{4}')$. Angenommen es ist so, dass $R_{1}\oplus R_{1}' = (000\,000)$ (das
gilt in 3 von 8~Fällen), dann haben wir die Ausgangssituation zur Analyse der
Runden 2, 3 und 4 als 3-Rundenanalyse.

Dort, wo die Annahme korrekt ist, erhalten wir eine Menge möglicher Schlüssel
für $K_{4}^{L}$ bzw. $K_{4}^{R}$. Dort, wo die Annahme falsch ist (die
Mehrzahl der Fälle), erhalten wir irgendwelche (zufälligen) Bitfolgen von
acht Bit.

\subsection{Die Sicherheit von DES}

\begin{enumerate}
 \item Die Größe des Schlüsselraums ist $2^{56}$ (es güngig aber
  $2^{55}$~Schlüssel zu testen), mit erschöpfender Suche war 1977 war defakto
  nicht möglich.

  1997: setzt die RSA-Data-Security US\,\$~10\,000 für die Dechiffrierung
  eines DES-Textes aus. Nach 5 Monaten war der Schlüssel ermittelt von Ronald
  Vesper -- durch organisiertes Parallelrechnen via Internet (25\,\%
  des Schlüsselraums wurde getestet.)

  1998: setzt die RSA-Data-Security wieder einen Preis aus und nach 39~Tagen
  war wieder der Schlüssel gefunden, obwohl 85\,\% des Schlüsselraums
  durchsucht wurden.

  1999: Electronic Frontier Foundation, 1536 parallel arbeitende Spezialchips
  benötigen im Schnitt $4\frac{1}{2}$~Tag um den kompletten Schlüsselraus zu
  durchsuchen.

  Quelle: 
 \item Es gibt bei DES \highl[Schlüssel!schwacher]{schwache Schlüssel}, die für alle Runden den gleichen
  Rundenschlüssel erzeugen. Aber man kann diese auch einfach beim Einsatz
  vermeiden.

 \item Differentielle Kryptoanalyse funktioniert nicht, wenn man die $S$-Boxen
  geeignet wählt. (Nicht-Gleichverteilung vermeiden.)
\end{enumerate}

% 4.12.

\subsubsection{DES und differentielle Kryptoanalyse}

Die differentielle Kryptoanalyse war den Designern des DES bekannt und deshalb
folgte die Verteidigung. $S$-Boxen sind so konstruiert, dass für höchstens ein
Viertel der Zweiermengen $\{A, A'\}$ die Output-Differenzen $S(A)\oplus S(A')$
übereinstimmen. Mit der Folge, dass für einen Chosen-Plaintext-Angriff
$2^{47}$ Klartextblöcke benötigt werden. Ein Known-Plaintext-Angriff benötigt
$2^{55}$ Klartextblöcke. Dies ist nicht wesentlich weniger als für einen
Brute-Force-Angriff benötigt werden: $2^{56}$. Deshalb sind es 16~Runden!

\subsubsection{DES und lineare Kryptoanalyse}

Von M.\,Mitsui auf der Konferenz EUROCRYPT im Jahre 1993 vorgestellt. War den
Designern von DES nicht bekannt.

Weder die $S$-Boxen und damit auch die gesamte Verschlüsselung beschreibt eine
lineare Abbildung. Damit sicher gegen solche Angriffe.

Die Idee der \highl{linearen Kryptoanalyse} ist: Approximation der
Verschlüsselung durch lineare Abbildungen. Ansatz: Bilde \texttt{xor} für
einige Klartextbits und \texttt{xor} für eine Geheimtextbits und verknüpfe
beide mit \texttt{xor}. Das Ergebnis ist ein einzelnes Bit, das als die
\texttt{xor}-Verknüpfung einiger Schlüsselbits interpretiert wird. Das Ganze
wieder für eine bestimmte Wahrscheinlichkeit~$p$. Wenn $p\ne\frac{1}{2}$,
Ausnutzung der Asymetrie (insbesondere ist der fünfte $S$-Boxtyp des DES dafür
anfällig) liefert eine Einschränkung der Schlüssel.

In der Arbeit von M.\,Mitsui wurde gezeigt, dass man für einen
Known-Plaintext-Angriff nur $2^{43}$~Paare, d.\,h. sie ist besser als die
\highl{differentielle Kryptoanalyse}.

\subsubsection{DES realisiert Diffusion und Konfusion}

Diffusion: Die Änderung der Eingabe in eine $S$-Box in einem Bit ändert die
Ausgabe in mindestens zwei Bit.

Konfusion: Jedes Ausgabebit hängt nach fünf Runden von allen Eingabebits ab.

\subsubsection{DES hat keine Gruppeneigenschaft}

Die \highl{Gruppeneigenschaft} lässt sich folgender Maßen beschreiben:
\begin{gather*}
  \forall k_{1},k_{2}\in\mathcal{K} \exists k_{3}\colon
     DES_{k_{1}} \circ DES_{k_{2}} = E_{k_{3}}
\end{gather*}


Für DES gilt aber im Allgemeinen für je drei Schlüssel $k_{1},k_{2},k_{3}$:
\begin{gather*}
       DES_{k_{1}} \circ DES_{k_{2}} \ne E_{k_{3}}
\end{gather*}

Das heißt $2^{56}$ mögliche Schlüssel erzeugen eine viel größere Gruppe
innerhalb von $\mathcal{S}_{2^{64}}$. Beachte $\abs{\mathcal{S}_{2^{64}}} =
(2^{64})! > 10^{10^{20}}$

Gezeigt wurde (1993: David Coppersmith): Die Gruppe der DES-Verschlüsselungen
umfasst mehr als $10^{2500}$ Verschlüsselungen, die sich durch Kombination
ergeben.

Konsequenz: DES wird bei Mehrfachverschlüsselung sicherer.

\subsubsection{"`Meet-in-the-Middle"'-Angriff}

Doppelte Verschlüsselung bewirkt eine Vergrößerung des Schlüsselraums auf
$2^{112}$~Schlüssel. Der folgende Angriff beschränkt das Durchprobieren auf
$2^{57}$~Versuche bei extremen Speicherplatzbedarf.

Angenommen ein Angreifer kennt einen Klartext~$m$ und den doppelt chiffrierten
Klartext $c=E_{k_{2}}(E_{k_{1}}(m))$ und sucht das Paar $(k_{1}, k_{2})$.
\begin{enumerate}
 \item Berechne und speichere $DES_{k}(m)$ für alle Schlüssel~$k$
  ($2^{56}$~Stück).
 \item Berechne und speichere $DES^{-1}_{k}(c)$ für alle Schlüssel~$k$
  ($2^{56}$~Stück).
 \item Vergleiche beide Listen nach Stellen, die die Gestalt $DES_{k_{1}}(m) =
  DES^{-1}_{k_{2}}(c)$. Hierfür gilt $DES_{k_{2}}(DES_{k_{1}}(m))=c$ und damit
  hat man $(k_{1},k_{2})$.
\end{enumerate}

Unter Umständen gibt es mehrere Schlüsselpaare, dann muss man das Verfahren
nochmal mit einem anderen Paar $(m',c')$ wiederholen. Also sind für
$n$~Schlüssel $2n$~Berechnungen nötig, anstelle von $n^{2}$~Berechnungen. (es
sind noch $n\log n$~Vergleiche notwendig)

\subsubsection{Dennoch in der Praxis}
Denoch wird DES in der Praxis eingesetzt als: $DES_{k_{1}}\circ
DES_{k_{2}}\circ DES_{k_{3}}$ und $DES_{k_{1}}
\circ DES_{k_{2}}^{-1} \circ DES_{k_{1}}$, da DES schnell ist und weit
verbreitet/Hardware vorhanden.

\section{International Data Encryption Algorithm (IDEA)}

Der International Data Encryption Algorithm (kurz \highl{IDEA}) wurde zu
beginn der neunziger Jahre des zwanzigsten Jahrhunderts in einer
Gemeinschaftsarbeit von James Massey und Xueija Lai von der ETH~Zürich und der
Ascom Systec~AG entwickelt. Die Ascom Systec~AG hält zum gegenwärtigen
Zeitpunkt noch einige Patente für IDEA. Denoch wird der Algorithmus im
PGP"~Verfahren eingesetzt.
\help{Stimmt es, dass IDEA in PGP verwendet wird?}

IDEA arbeitet mit der Blocklänge von 64~Bit, einer Schlüssellänge von 128~Bit
und 8~Runden zuzüglich einer Abschlussrunde. Durch den riesigen Schlüsselraum
wird ein Brute-Force-Angriff gegenüber DES wesentlich erschwert.

\begin{figure}[ht]
  \centering
  \input{idea.pdf_t}
  \caption{Blockschema für den Ablauf der $i$. Runde der IDEA"~Verschlüsselung}
  \label{fig:idea}
\end{figure}

Der Ablauf jeder Runde ist in \autoref{fig:idea} dargestellt. Jeder
Klartextblock wird in vier Teilblöcke zu je 16~Bit zerlegt, die durch
Verknüpfung mit 6~Rundenschlüsseln bzw. den Ergebnissen der Verknüpfungen in
vier Teilblöcke von 16~Bit transformiert werden. Als Verknüpfung werden die
drei Operationen Exklusives"~Oder~($\oplus$), Addition modulo~$2^{16}$~
($\boxplus$) und Multiplikation modulo $2^{16}+1$~($\odot$) eingesetzt.

% \begin{enumerate}
%  \item $\alpha_{1} = x_{1}\odot k_{i_{1}}$
%  \item $\alpha_{2} = x_{2}\boxplus k_{i_{2}}$
%  \item $\alpha_{3} = x_{3}\boxplus k_{i_{3}}$
%  \item $\alpha_{4} = x_{4}\odot k_{i_{4}}$
%  \item $\beta_{1} = \alpha_{1} \oplus \alpha_{3}$
%  \item $\beta_{2} = \alpha_{2} \oplus \alpha_{4}$
%  \item $\gamma = \beta_{1} \odot k_{i_{5}}$
%  \item $\delta = \beta_{2} \boxplus \gamma$
%  \item $\epsilon = \delta \odot k_{i_{6}}$
%  \item $\zeta = \gamma \boxplus \epsilon$
%  \item $x_{1}' = \alpha_{1} \oplus \epsilon$
%  \item $x_{2}' = \alpha_{3} \oplus \epsilon$
%  \item $x_{3}' = \alpha_{2} \oplus \zeta$
%  \item $x_{4}' = \alpha_{4} \oplus \zeta$
% \end{enumerate}

Nach der 8.~Runde gibt es eine Schlussrunde:
\begin{align*}
  x_{1}' &= x_{1}\odot k_{9_{1}} &
     x_{2}' &= x_{2}\boxplus k_{9_{2}} &
  x_{3}' &= x_{3}\boxplus k_{9_{3}} &
     x_{4}' &= x_{4}\odot k_{9_{4}}
\end{align*}

Da IDEA andere algebraische Operationen einsetzt als die Feistel-Chiffre,
bezeichnet man ihn auch nicht als eine Feistel-Chiffre. Denoch ist er so
konstruiert, dass die Verschlüsselungsfunktion auch als
Entschlüsselungsfunktion verwendet werden kann.

Die Sicherheit von IDEA ist auf der Unverträglichkeit der drei
unterschiedlichen arithmetischen Operationen begründet. Es ist zwar eine
Klasse von \highl[Schlüssel!schwacher]{schwachen Schlüsseln} mit
$2^{65}$~Elementen bekannt, denoch ist der Algorithmus durch die komplexen
Runden sicher gegen lineare und differentielle Kryptoanalyse.\cite{idea-save}

\section{RC-Familie}

In den 1990ern wurden von Ronald Rivest von der RSA Data Security eine Reihe
von Verschlüsselungsverfahren entwickelt, die als
\highl[RC-Familie]{RC"~Familie} (Ron's Code oder Rivest's Cipher)
zusammengefasst werden.\cite[Abs.\,3.6.2--4]{rsafaq}

\highl{RC2} bezeichnet eine Feistelchiffre, die mit 18~Runden und einer
Klartextblocklänge von 64~Bit arbeitet. Die Schlüssellänge muss ein Vielfaches
von acht sein und kann zwischen einschließlich 8 und 128~Bit gewählt werden.

RC2 wurde 1987 als Ersatz für DES entwickelt und ist als solcher auch
schneller und, bei geeigneter Wahl des Schlüssels, sicherer als DES. RC2
wurde, bis es 1996 von einem Unbekannten im Usenet veröffentlicht wurde,
geheim gehalten.

\highl{RC5} wurde 1994 ebenfalls für die RSA Data Security entwickelt und
weist ungewöhnlich viele Freiheiten bei der Wahl der Parameter auf. Die
Blocklänge kann 32, 64 oder 128~Bit sein. Die Schlüssellänge kann von 0 bis
2040~Bit und die Rundenanzahl von 0 bis 255 gewählt werden.

Es gibt drei Operationen: Schlüsselerweiterung, Ver- und Entschlüsselung. Bei
der Schlüsselerweiterung wird in Abhängigkeit von der Rundenanzahl eine
Tabelle für die Ver"~/""Entschlüsselung erzeugt. Die Ver"~/""Entschlüsselung
arbeitet mit Addition, exklusiven Oder und Bitrotation. Durch einen extrem
einfachen Aufbau ist der RC5-Algorithmus leicht zu implementieren und zu
verifizieren.
\begin{align*}
  x_{1}' &= rot(x_{1} \oplus x_{2}, x_{2}) \boxplus K_{1} &
  x_{2}' &= rot(x_{2} \oplus x_{1}', x_{1}') \boxplus  K_{2}
\end{align*}

RC5 ist sicher gegen differentielle und lineare Kryptoanalyse.\cite{rc5save}

Um die Kriterien für die Ausschreibung des Advanced Encryption Standards zu
erfüllen, wurde RC5 etwas verändert und als \highl{RC6} eingereicht. Die
Blockgröße, Schlüssellänge und Rundeanzahl können aus den selben Bereichen wie
bei RC5 gewählt werden. RC6 wurde 1998 veröffentlich und gelangte auch in die
letzte Ausscheidungsrunde für den AES.

% 6.12.

\section{Blowfish und Twofish}

Blowfish (1994), Twofish (1998) von Bruce Schneier

\begin{description}
 \item[Blowfish] variable Schlüssellänge (bis 448~Bit), $S$-Boxen
  schlüsselunabhängig, 16~Runden, Blöcklänge~64. Trotz aufwendiger $S$-Boxen
  ein schnell zu implementierender Algorithmus (\texttt{xor} und Addition von
  32-Bitwerten)

 \item[Twofish] Runde der letzten 5 AES-Kandidaten. Schlüssellänge: 128, 192,
  256, Blocklänge: 64, $8\times8$ $S$-Boxen, arithmetische Operationen in
  $\F_{2^{8}}$ endlicher Körper der Ordnung $2^{8}$ (anstelle von $\Z_{2}=\F_{2}$)
\end{description}

\section{Sonstige Blockchiffren}

\begin{description}
 \item[SAFER] 1995, Massey
 \item[CAST] 1990, 1997 -- wird bei PGP benutzt
 \item[SKipjack] NSA, 1990
 \item[KASUMI] Weiterentwicklung von MISTY, wird zur Verschlüsselung bei UMTS
  eingesetzt.
\end{description}

\section{Der Advanced (Data) Encryption Standard -- AES}

1997: macht die US-Standardisierungsbehörte ein \textit{öffentliche}
Ausschreibung eines Verfahrens als Nachfolgers von DES. Forderungen an das
Verfahren: öffentlich, lizenzfrei, weltweit verfügbar, schneller als
Triple-DES. Vorgaben: Blocklänge min. 128 und Schlüssellänge von 128, 192,
256.

1998: Wurden 15 Verfahren eingereicht. (darunter auch MAGENTA von der
deutschen Telekom, das schon in der Präsentation gebrochen wurde)

1999: 5 Kandidaten in der Endrunde: Twofisch (Platz 2, weil $\F_{256}$ und
nicht $\F_{2}$), RC6, MARS (IBM, David Coppersmith), Serpent (ähnlich DES,
über 32 Runden, Platz 3), Rijngdael

2000: Wird Rijndael als Sieger bekannt gegeben.

2002: Rijndael wird als AES (FIPS) veröffentlich.

\subsection{Bescheibung des Verfahrens von Rijndael}

iterirte Blockchiffre; keine Feistel-Chiffre; Block- und Schlüssellänge können
unabhängig voneinander gewählt werden; Rundenzahl ist abhängig von 10, 12 oder
14; in FIPS: 128 als Blocklänge, 128 als Schlüssellänge und 10 als Rundenzahl
und eine Abschlussrunde

\todo{Bild vom Schema}

Was passiert in den Runden? Jede Runde (bis auf die letzte) besteht aus drei
Schichten:
\begin{enumerate}
 \item ByteSub-Transformation: nicht lineare Transformation als Schutz vor
  differenzieller und linearer Kryptoanalyse
 \item SchiftRow-Transformation: zwischen Diffusion
 \item MixColumn-Transformation
\end{enumerate}

\todo{Bild vom Schema der Runde~$i$}

\subsection{Exkurs über endliche Körper}

\subsubsection{Endliche Körper von Primzahlordnung}
wissen: Zerlegung der ganzen Zahlen in Äquivalenzklassen modulo $m$: $\Z_{m}
:= \Z_{\nicefrac{}{\equiv (m)}}$; ergibt einen Ring $[\Z_{m}, +,\cdot]$ für
$m>1$ mit dem Nullelement $0 := [0]_{m}$ und Einselemt $1 := [1]_{m}$. $\Z_{m}
= \{ [0]_{m}, [1]_{m}, \dotsc, [m-1]_{m}\} = \{0,1,\dotsc,m-1\}$,
$\abs{\Z_{m}}=m$. Ein Element $a\in\Z_{m}$ heißt \highl{Einheit} \gdwdef es
gibt ein inverses Element $b$ mit $a\cdot b=1$. Es gilt: $a$ ist Einheit in
$\Z_{m}$ \gdw $\ggT(a,m) = 1$

$\Z_{m}^{*}:= \{a\in\Z_{m}\colon a~\text{ist Einheit}\}$, $\abs{\Z_{m}^{*}} =
\phi(m)$ (Eulersche $\phi$-Funktion)

Wenn $m=p$ eine Primzahl ist, dann ist $\Z_{p}^{*} = \{1, 2,\dotsc,p-1\}$
($\phi(p)=p-1$) und $\Z_{p}$ ein endlicher Körper der Ordung~$p$.

Ziel: Endliche Körper der Ordnung $p^{k}$ ($p$ ist Primzahl);
Primzahlpotenzordnung.

\subsubsection{Polynomringe}

Es sei $[R, +,\cdot]$ ein (endlicher) Ring, z.\,B. $[\Z_{m}, +,\cdot]$ und
$x\notin R$ ist ein Symbol, dass nicht im Ring vorkommt. Wir definieren
Polynome vom Grad~$k$, mit $r_{i}\in R$ für $i=0,\dotsc,k$ und $r_{k}\ne0$
\begin{gather*}
  p(x) := r_{k}\cdot x^{k} + r_{k-1}\cdot x^{k-1} + \dotsb+ r_{1} x^{1} + r_{0}
\end{gather*}
Bezeichnung $R[x]$ ist die Menge aller Polynome in $x$ über $R$.

Addition und Multilikation komponentenweise wie üblich.

$[R[x], +, \cdot]$ ist ein Ring und heißt \highl{Polynomring}. ist abzählbar
unendlich

\subsubsection{$\F_{p^{k}}$ endlicher Körper der Ordnung $p^{k}$}

Dazu benötigen wir ein \highl{irreduzibles Polynom} vom Grad~$k$. $m$
Polynom als Modul
\begin{gather*}
  m(x) = a_{k} x^{k} + a_{k-1} x^{k-1} + \dotsb+ a_{1}x^{1} + a_{0}
\end{gather*}
$a_{k}\ne0$, z.\,B. $a_{k}=1$

reduzibel = Polynom lässt sich schreiben als Produkt zweier Polynome schreiben
$m(x) = p(x)\cdot q(x)$ für $p$ und $q$ vom Grad $\geq1$ -- Analogie zu prim
für Polynome.

Ansatz: $\F_{p^{k}}$ ist eine Menge aller Polynome über $\Z_{p}$ modulo des
Polynoms $m$. Das heißt: $p(x) = q(x) \cdot m(x) + r(x)$; $r(x)$ Repräsentant
von $p$ in $\F_{p^{k}}$

% 13.12.

Wir betrachten zunächst die Gesamtheit $\Z[p]$ aller Polynome mit
Koeffizienten aus $\Z_{p}$ und betrachten die Reste modulo $m(x)$
$\Z_{p}[x]_{\nicefrac{}{m(x)}}$ Diese Reste sind Polynome vom Grad $\leq k-1$
und haben die Form
\begin{gather}
  \label{eq:1}
  p(x) = b_{k-1} x^{k-1} + b_{k-1} x^{k-2} + \dotsb+ b_{1} x + b_{0}
\end{gather}
mit Koeffizienten $b_{k-1}, b_{k-2}, \dotsc, b_{1}, b_{0}\in \Z_{p}$. Es gibt
also $p^{k}$ verschieden Polynome der Form \autoref{eq:1}.
\begin{gather*}
  \F_{p^{k}} = \Z_{\nicefrac{p(x)}{m(x)}}
\end{gather*}

Addition $\oplus$ wie üblich und komponentenweise, Multiplikation $\odot$ wie
üblich mit anschließender Division durch den Modul $m(x)$, wobei der Rest das
Ergebnis ist.

bei AES: $p=2, k=8$, d.\,h. wir betrachen $\F_{2^{8}} = \F_{256}$ mit
Koeffizienten aus $\Z_{2}$ und dem Modulpolynom
\begin{gather*}
  m(x) = x^{8} + x^{4} + x^{3} + x +1
\end{gather*}
(Das Ding ist irreduzibel).

\begin{bsp}
  \begin{gather*}
    (x^{6} + x^{4} + x^{2} + x + 1) \odot (x^{7} + x +1)
  \end{gather*}

  \begin{enumerate}[1.\,{Schritt}]
   \item Übliche Multiplikation
    \begin{align*}
      (x^{6} + x^{4} + x^{2} + x + 1) \cdot (x^{7} + x +1) =
         x^{13} + x^{11} + x^{9} + x^{8} + x^{7}\\
      + x^{7} + x^{5} + x^{3} + x^{2} + x\\
      + x^{6} + x^{4} + x^{2} + x + 1\\
      = x^{13} + x^{11} + x^{9} + x^{8} + x^{6} + x^{5} + x^{4} + x^{3} + 1
    \end{align*}
    Der Koeffizient $x^{7}$ verschwindet, da $2\pmod{2} \equiv 0$

   \item Division:
    \begin{gather*}
      (x^{13} + x^{11} + x^{9} + x^{8} + x^{6} + x^{5} + x^{4} + x^{3} + 1) :
         (x^{8} + x^{4} + x^{3} + x + 1) = x^{5} + x^{3} = q(x)\\
      +(x^{13} + x^{9} + x^{8} + x^{6} +x^{5})\\
      ---\\
      x^{11} + x^{4} + x^{3} + 1\\
      -(x^{11} + x^{7} + x^{6} + x^{4} +x^{3})\\
      ---\\
      -x^{7} - x^{6} +1 = x^{7} + x^{6} + 1 = r(x)
    \end{gather*}
    $p(x) = q(x) \cdot m(x) + r(x)$

    Also
    \begin{gather*}
      (x^{6} + x^{4} + x^{2} + x + 1) \odot (x^{7} + x +1) = x^{7} + x^{6} +1
    \end{gather*}
  \end{enumerate}
\end{bsp}

\subsubsection{Darstellung der Elemente aus $\F_{256}$}

\begin{enumerate}
 \item Darstellung als Polynom
  \begin{gather*}
    p(x) = b_{7} x^{7} + b_{6} x^{6} + \dotsb+ b_{1} x + b_{0}
  \end{gather*}
  mit $b_{7},\dotsc, b_{0} \in \{0,1\}$.

 \item Darstellung als Folge von Bits $(b_{7}, b_{6}, \dotsc, b_{0})$ 8~Bit =
  1~Byte

  unser Beispiel:
  \begin{gather*}
    (0,1,0,1,0,1,1,1) \odot (1,0,0,0,0,0,1,1) = (1,1,0,0,0,0,0,1)
  \end{gather*}
  Das $\odot$ hängt von dem $m(x)$ ab. $\F_{256}[m(x)] \cong \F_{256}[m'(x)]$

 \item Darstellung als zweistellige Hexadezimalzahl

  unser Beispiel: $57\odot 83 = C1$

  Das Ergebnis lässt sich aus einer $256\times 256$-Tabelle ablesen.

 \item Multiplikatives Inverses in $\F_{256}$

  Ansatz: Es sei $p(x)\in \F_{256}$ mit $p(x)\ne0$. Dann sind $p(x)$ und
  $m(x)$ teilerfremd (weil $m(x)$ irreduzibel), d.\,h. es gibt kein Polynome
  $g(x)\ne1$ mit der Eigenschaft $p(x)= a(x)\cdot g(x)$ und $m(x) = b(x)\cdot
  g(x)$. Mit anderen Worten: der größe gemeinsame Teiler von $p(x)$ und $m(x)$
  ist 1. Also lässt sich 1 mit Hilfe des erweiterten euklidischen Algorithmus
  darstellen: d.\,h. es gibt Polynome $u(x)$ und $v(x)$ mit der Eigenschaft
  \begin{gather*}
    p(x) \cdot u(x) + m(x) v(x) = 1
  \end{gather*}
  Hieraus folgt: $p(x)\odot u(x) =1$

  Wir brauchen den \highl{erweiterten euklidischen Algorithmus} für Polynome:
  Für Zahlen hat der die Form:\\
  Eingabe: $b_{0}, b_{1}$\\
  \begin{verbatim}
  begin
    x[0] := 1; y[0] := 0;
    x[1] := 0; y[1] := 1;
    i := 1;
    while not teilt(b[i], b[i-1]) do
    begin
      q[i] := b[i-1] div b[i];
      b[i+1] := b[i-1] - q[i] b[i];
      x[i+1] := x[i-1] + q[i] x[i];
      y[i+1] := y[i-1] + q[i] y[i];
    end
    begin output
      b := b[i];
      x := ((-1) ** i) * x[i];
      y := ((-1) ** i) * y[i];
    end
  end
  \end{verbatim}
\end{enumerate}

% 18.12.

\begin{bsp}
  $b_{0}=220, b_{1} = 26$
  \begin{gather*}
    \begin{array}{c|cccc}
      i& q_{i} & b_{i+1} & x_{i+1}& y_{i+1}\\
      \hline
      1& 8& 200-8\cdot 26=12& 1+0\cdot8=1& 0+1\cdot8=0\\
      2& 2& 26-2\cdot 2=2& 0+1\cdot2=2& 1+2\cdot8 = 17\\
      3& \multicolumn{4}{l}{2\mid 12 \rightarrow \text{Abbruch}}
    \end{array}
  \end{gather*}
  $b= 2 = \ggT(b_{0}, b_{1}), x= (-1)^{3}\cdot 2 = -2, y=(-1)^{4}\cdot 17 = 17$

  $2= -2\cdot 220 + 17\cdot 26 = -440 + 442$
\end{bsp}

\subsection{Erweiterter Euklidischer Algorithmus für Polynome}

Eingabe: $b_{0}(x):=m(x) = x^{8} + x^{4} + x^{3} +x +1, b_{1}(x)$
\begin{verbatim}
begin
  ux[0] := 1; vx[0] := 0;
  ux[1] := 0; vx[1] := 1;
  i := 1;
  while bx[i] ist kein Teiler von bx[i-1] do
  begin
    qx[i] := bx[i-1] div bx[i];
    bx[i+1] := bx[i-1] - qx[i] * bx[i];
    ux[i+1] := ux[i-1] + qx[i] * ux[i];
    vx[i+1] := vx[i-1] + qx[i] * vx[i]
    i := i + 1;
  end
  begin output
    bx := bx[i];
    ux := ((-1) ** i) * ux[i];
    vx := ((-1) ** i) * vx[i];
  end output
end
\end{verbatim}

\begin{bsp}
  $b_{1} = x^{7} + x^{6} + x^{3} + x + 1$

  \begin{enumerate}[1.\,{Schleifendurchlauf}]
   \item $(x^{8} + x^{4} + x^{3} + x + 1) : (x^{7} + x^{6} + x^{3} + x +1) =x$\\
    $\oplus (x^{8} +x^{7} + x^{4} + x^{2} +x)$\\
    ---\\
    $x^{7} + x^{3} + x^{2} + 1$\\
    $\oplus (x^{7} + x^{6} + x^{3} +x +1)$\\
    ---\\
    $x^{6} + x^{2} + x$

    $q_{1}(x) = x+1, b_{2}(x) = x^{6} + x^{2} + x, u_{2}(x) = 1+0, v_{2}(x) = 0+(x+1) 1$

   \item $(x^{7} + x^{6} + x^{3} + x + 1) : (x^{6} + x^{2} + x) = x$\\
    $\oplus(x^{7} + x^{3} + x^{2})$\\
    ---\\
    $x^{6} + x^{2} + x + 1$\\
    $\oplus(x^{6} + x^{2} + x)$\\
    ---
    1

    $q_{2}(x) = x+1, b_{3} = 1, u_{3} = 0+ (x+1) \cdot 1, v_{3}(x) = 1 +
    (x+1)(x+1) = 1 + x^{2} + x + x + 1 = x^{2}$ (da $+ = \oplus$)
  \end{enumerate}
  $b(x) = 1, u(x) = x+1, v(x) = x^{2}$

  $u(x)\cdot m(x) + v(x) \cdot a(x) = (x+1) (x^{8} + x^{4} + x^{3} + x + 1) +
  x^{2} (x^{7} + x^{6} + x^{3} + x +1) = x^{9} + x^{5} + x^{4} +x^{2} + x +
  x^{8} + x^{4} + x^{3} + x + 1 + x^{9} + x^{8} + x^{5} + x^{3} + x^{2} = 1$

  Also gilt: $v(x) a(x) = u(x) m(x) + 1$ also $v(x) \odot a(x) = 1$, $v(x) =
  a^{-1}(x)$. Oder als Bitfolgen geschrieben: $a(x) = (1100\,1011), a^{-1}(x)
  = (0000\,0100)$
\end{bsp}

\section{2.\texorpdfstring{\,}{ }Stufe: Polynome über dem Körper \texorpdfstring{$\F_{256}$}{F256}}

Wir betrachten den Polynomring $\nicefrac{\F_{256}[x]}{(x^{4}+1)}$. Die
Elemente sind Polynome höchstens dritten Grades.
\begin{gather*}
  c(x) = c_{3} x^{3} + c_{2} x^{2} + c_{1} x + c_{0}
\end{gather*}
dabie sind die Koeffizient~$c_{i}\in\F_{256}$ und erlauben die folgende
Darstellung:

\begin{bsp}
  als Polynom: $c(x) = 01 x^{3} + 03 x^{2} + A1 x + 02$\\
  Hexadezimal: $[01, 03, A1, 02]$\\
  Binär: $[0000\,0001, 0000\,0011, 1010\,0001, 0000\,0010]$
\end{bsp}

Addition ist komponentenweis mit \texttt{xor} $\oplus$.
\begin{gather*}
  a(x)\oplus b(x) = (a_{3}\oplus b_{3}) x^{3} + (a_{2} \oplus b_{2}) x^{2} +
     (a_{1}\oplus b_{1}) x + (a_{0} \oplus b_{0})
\end{gather*}

Multiplikation: $\otimes$ in zwei Schritten:
\begin{enumerate}[1.\,{Schritt}]
 \item Polynommultiplikation $c(x) = a(x)\odot b(x) = c_{6} x^{6} + \dotsb+
  c_{1} x^{1} + c_{0}$, wobei
  \begin{align*}
    c_{6}& = (a_{3}\odot b_{3})\\
    c_{5}& = (a_{3}\odot b_{2})\oplus (a_{2}\odot b_{3})\\
    c_{4}& = (a_{3}\odot b_{1})\oplus (a_{2}\odot b_{2})\oplus
       (a_{1}\odot b_{3})\\
    c_{3}& = (a_{3}\odot b_{0})\oplus (a_{2}\odot b_{1})\oplus
       (a_{1}\odot b_{2})\oplus (a_{0}\odot b_{3})\\
    c_{2}& = (a_{2}\odot b_{0})\oplus (a_{1}\odot b_{1})\oplus
       (a_{0}\odot b_{2})\\
    c_{1}& = (a_{1}\odot b_{0})\oplus (a_{0}\odot b_{1})\\
    c_{0}& = (a_{0}\odot b_{0})
  \end{align*}

 \item Faktorisierung modulo $(x^{4}+1)$

  Fakt: $x^{i}\pmod{x^{4}+1} = x^{i\pmod{4}}$

  Für das modulare Produkt gilt:
  \begin{align*}
    d(x) & = a(x)b(x) \pmod{x^{4}+1}\\
    & = d_{3}x^{3}+d_{2}x^{2}+d_{1}x+d_{0}
  \end{align*}
  mit den Koeffizienten
  \begin{align*}
    d_{3}& = (a_{3}\odot b_{0}) \oplus (a_{2}\odot b_{1}) \oplus
       (a_{1}\odot b_{2}) \oplus (a_{0}\odot b_{3})\\
    d_{2}& = (a_{2}\odot b_{0})\oplus (a_{1}\odot b_{1})\oplus
       (a_{0}\odot b_{2}) \oplus (a_{3}\odot b_{3})\\
    d_{1}& = (a_{1}\odot b_{0})\oplus (a_{0}\odot b_{1}) \oplus
       (a_{3}\odot b_{2})\oplus (a_{2}\oplus b_{3})\\
    d_{0}& = (a_{0}\odot b_{0})\oplus (a_{3}\odot b_{1})\oplus
       (a_{2}\odot b_{2})\oplus (a_{1}\odot b_{3})
  \end{align*}

  Matrizenschreibweise:
  \begin{gather*}
    \begin{pmatrix}
      d_{3}\\
      d_{2}\\
      d_{1}\\
      d_{0}
    \end{pmatrix} =
       \begin{pmatrix}
         a_{0}& a_{1}& a_{2}& a_{3}\\
         a_{3}& a_{0}& a_{1}& a_{2}\\
         a_{2}& a_{3}& a_{0}& a_{1}\\
         a_{1}& a_{2}& a_{3}& a_{0}
       \end{pmatrix} :
       \begin{pmatrix}
         b_{3}\\
         b_{2}\\
         b_{1}\\
         b_{0}
       \end{pmatrix}
  \end{gather*}
\end{enumerate}

\begin{bsp}
  \begin{gather*}
    [00,00,00,01] \otimes [47, 08, 1F, 2B] = [47, 08, 1F, 2B]\\
    [01,00,00,00]\otimes [2B, 1F, 08, 47] = [47, 2B, 1F, 08]
  \end{gather*}
\end{bsp}

Es gilt: $R=\nicefrac{\F_{256}[x]}{(x^{4}+1)}$ ist Ring, der kein Körper ist.
Das bedeutet, dass nicht jedes Elment $c(x)\in R$ ein Inverses besitzt. AES
benutzt
\begin{gather*}
  c(x) = 03 x^{3}+ 01 x^{2} + 01 x + 02
\end{gather*}
mit dem Inversen $c^{-1}(x) = 0B x^{3} + 0D x^{2} + 09 x + 0E$

% 20.12.

\paragraph{Notationen für AES}
Es werden Bytes von je 8~Bits verwendet $a=a_{7}a_{6}\dotso a_{0}
\in\F_{256}$. Für die Eingabeblocklänge 128~Bits ergeben sich Bytefolgen der
Länge~16.
\begin{gather*}
  s = a^{(0)}a^{(1)}\dotso a^{(14)}a^{15}
\end{gather*}
die als Matrizen geschrieben werden.
\begin{gather*}
  s =
     \begin{pmatrix}
       a^{(0)}& a^{(4)}& a^{(8)}& a^{(12)}\\
       a^{(1)}& a^{(5)}& \dotso\\
       a^{(2)}& \dotso \\
       a^{(3)}& a^{(7)}& a^{(11)}& a^{(15)}
     \end{pmatrix} =
     \begin{pmatrix}
       a^{(0,0)}& a^{(0,1)}& a^{(0,2)}& a^{(0,3)}\\
       a^{(1,0)}& a^{(1,1)}& \dotso\\
       a^{(2,0)}& \dotso \\
       a^{(3,0)}& a^{(3,1)}& a^{(3,2)}& a^{(3,3)}
     \end{pmatrix}
     = a^{z,s}
\end{gather*}
mit je 4~Zeilen und 4~Spalten. Weiter wird festgelegt: Die Eingabe in die
$i$.\,Runde wird mit $s_{i,a}$ bezeichnet
\begin{gather*}
  s_{i,a} =
     \begin{pmatrix}
       a^{(0,0)}& a^{(0,1)}& a^{(0,2)}& a^{(0,3)}\\
       \vdots \\
       a^{(3,0)}& \dotso && a^{(3,3)}
     \end{pmatrix}
\end{gather*}
Das Ergebnis des ersten Schritts (\highl{Byte-Sub}) wird mit $s_{i,b}$
bezeichnet und ist die Eingabe des zweiten Schritts (\highl{Row-Shift}).
\begin{gather*}
  s_{i,b} =
     \begin{pmatrix}
       b^{(0,0)}& b^{(0,1)}& b^{(0,2)}& b^{(0,3)}\\
       \vdots \\
       b^{(3,0)}& \dotso && b^{(3,3)}
     \end{pmatrix}
\end{gather*}
Das Ergbnis des zweiten Schritts $s_{i,c}$ ist die Eingabe des dritten
Schritts (\highl{Column-Mix}). Das Ergebnis des dritten Schrittes ist
$s_{i,d}$ und die Eingabe für den vierten Schritt (\highl{Schlüsseladdition}).
Dieses Ergebnis ist $s_{i+1,a}$ und die Eingabe für die $i+1$.\,Runde.

Schreibweise in $\nicefrac{\F_{256}[x]}{x^{4}+1}$:
\begin{gather*}
  a(x) = 02 + 01x + 01x^{2}+03\quad\text{bzw.}\\
  a = [02, 01, 01, 03]
\end{gather*}

\paragraph{Beschreibung der einzelnen Schritte}
\begin{enumerate}[1.\,{Schritt}]
 \item Byte-Sub
  \begin{enumerate}
   \item mathematischer Hintergrund: Eingabe: $a^{(z,s)}$. Zwei Transformationen:
    \begin{enumerate}
     \item Bestimme das multiplikative Inverse $(a^{(z,s)})^{-1}$ in
      $\F_{256}$. Bemerkung: Falls $a^{(z,s)}= 00$, dann $(a^{(z,s)})^{-1} =
      00$.

     \item Berechne folgende affine Abbildung
      \begin{gather*}
        (a^{(z,s)})^{-1} = \tilde{a}_{7}\tilde{a}_{6}\dotso\tilde{a}_{0}
      \end{gather*}
      mit dem Ergebnis $b^{(z,s)} = b_{7}b_{6}\dotso b_{0}$
      \begin{gather*}
        \begin{pmatrix}
          b_{0}\\
          b_{1}\\
          b_{2}\\
          b_{3}\\
          b_{4}\\
          b_{5}\\
          b_{6}\\
          b_{7}
        \end{pmatrix} =
           \begin{pmatrix}
             1& 0& 0& 0& 1& 1& 1& 1\\
             1& 1& 0& 0& 0& 1& 1& 1\\
             1& 1& 1& 0& 0& 0& 1& 1\\
             1& 1& 1& 1& 0& 0& 0& 1\\
             1& 1& 1& 1& 1& 0& 0& 0\\
             0& 1& 1& 1& 1& 1& 0& 0\\
             0& 0& 1& 1& 1& 1& 1& 0\\
             0& 0& 0& 1& 1& 1& 1& 1
           \end{pmatrix} \cdot
           \begin{pmatrix}
             \tilde{a}_{0}\\
             \tilde{a}_{1}\\
             \tilde{a}_{2}\\
             \tilde{a}_{3}\\
             \tilde{a}_{4}\\
             \tilde{a}_{5}\\
             \tilde{a}_{6}\\
             \tilde{a}_{7}
           \end{pmatrix} +
           \begin{pmatrix}
             1\\ 1\\ 0\\ 0\\ 0\\ 1\\ 1
           \end{pmatrix}
      \end{gather*}

      Bemerkung: Diese Abbildung kann als Abbildung über dem Polynomring
      $\nicefrac{\F_{2}[x]}{x^{8}+1}$ verstanden werden.
      \begin{gather*}
        \begin{pmatrix}
          b_{0}& b_{1}& b_{2}& b_{3}& b_{4}& b_{5}& b_{6}& b_{7}
        \end{pmatrix}
           =
           \begin{pmatrix}
             1& 1& 1& 1& 1& 0& 0& 0
           \end{pmatrix}
           \cdot
           \begin{pmatrix}
             \tilde{a}_{0}& \tilde{a}_{1}& \tilde{a}_{2}& \tilde{a}_{3}&
             \tilde{a}_{4}& \tilde{a}_{5}& \tilde{a}_{5}& \tilde{a}_{6}&
             \tilde{a}_{7}
           \end{pmatrix}
           +
           \begin{pmatrix}
             1& 1& 0& 0& 0& 1& 1& 0
           \end{pmatrix}
      \end{gather*}
    \end{enumerate}

   \item Die Darstellung -- Praktische Umsetzung: Table-lookup\\
    zusammengefasst ist das Resultat
    \begin{gather*}
      b^{(z,s)} = S_{8}(a^{(z,s)})
    \end{gather*}
    das in einer Tabelle ($16\times16$) dargestell werden kann. Die
    niederwertigen Bits $a_{3}, a_{2}, a_{1}$ und $a_{0}$ bestimmen die
    Spalte der Tabelle und die Bits $a_{7}, a_{6}, a_{5}$ und $a_{4}$
    bestimmen die Zeile.

    Beispiel: $S_{8}(1011\,0101)$, Zeile~11 und Spalte~5. Die Tabelle
    liefert $D5$, d.\,h. 13 und 5. $S_{8}(1011\,0101) = (1101\,0101)$.
  \end{enumerate}
 \item Row-Shift
  \begin{enumerate}
   \item mathematischer Hintergrund: Rechnen in
    $\nicefrac{\F_{2^{8}}[x]}{x^{4}+1}$ zeilenweise:
    \begin{align*}
      [c^{(0,0)}, c^{(0,1)}, c^{(0,2)}, c^{(0,3)}]
         &= [b^{(0,0)}, b^{(0,1)}, b^{(0,2)}, b^{(0,3)}]\\
      [c^{(1,0)}, c^{(1,1)}, c^{(1,2)}, c^{(1,3)}]
         &= [b^{(1,0)}, b^{(1,1)}, b^{(1,2)}, b^{(1,3)}] \otimes 01x^{3}\\
      [c^{(2,0)}, c^{(2,1)}, c^{(2,2)}, c^{(2,3)}]
         &= [b^{(2,0)}, b^{(2,1)}, b^{(2,2)}, b^{(2,3)}] \otimes 01x^{2}\\
      [c^{(3,0)}, c^{(3,1)}, c^{(3,2)}, c^{(3,3)}]
         &= [b^{(3,0)}, b^{(3,1)}, b^{(3,2)}, b^{(3,3)}] \otimes 01 x
    \end{align*}

   \item Die Darstellung
    \begin{gather*}
      \begin{pmatrix}
        c^{(0,0)}& c^{(0,1)}& c^{(0,2)}& c^{(0,3)}\\
        c^{(1,0)}& c^{(1,1)}& c^{(1,2)}& c^{(1,3)}\\
        c^{(2,0)}& c^{(2,1)}& c^{(2,2)}& c^{(2,3)}\\
        c^{(3,0)}& c^{(3,1)}& c^{(3,2)}& c^{(3,3)}
      \end{pmatrix} =
         \begin{pmatrix}
           b^{(0,0)}& b^{(0,1)}& b^{(0,2)}& b^{(0,3)}\\
           b^{(1,1)}& b^{(1,2)}& b^{(1,3)}& b^{(1,0)}\\
           b^{(2,2)}& b^{(2,3)}& b^{(2,0)}& b^{(2,1)}\\
           b^{(3,3)}& b^{(3,0)}& b^{(3,1)}& b^{(3,2)}
         \end{pmatrix}
    \end{gather*}
  \end{enumerate}

 \item Column-Mix:
  \begin{enumerate}
   \item mathematischer Hintergrund:\\
    spaltenweise
    \begin{gather*}
      \begin{pmatrix}
        d^{(0,s)} \\ d^{(1,s)}\\ d^{(2,s)}\\ d^{(3,s)}
      \end{pmatrix} = S_{32}
         \begin{pmatrix}
           c^{(0,s)} \\ c^{(1,s)}\\ c^{(2,s)}\\ c^{(3,s)}
         \end{pmatrix}
    \end{gather*}

    Beschreibung der Abbildung $S_{32}$ \todo{Bild von $S_{32}$}

    \begin{gather*}
      \mathit{xtime}(x_{7}x_{6}\dotso x_{0}) =
         \begin{cases}
           x_{6}x_{5}x_{4}x_{3}x_{2}x_{1}x_{0} 0&\colon x_{7}=0\\
           (x_{6}x_{5}x_{4}x_{3}x_{2}x_{1}x_{0} 0) \oplus (0001\,1011)&
           \colon x_{7} = 1
         \end{cases}
    \end{gather*}

    kompakte Darstellung in $\nicefrac{\F_{2^{8}}[x]}{x^{4}+1}$:
    \begin{gather*}
      [d^{(0,s)} d^{(1,s)}, d^{(2,s)}, d^{(3,s)}] =
         [c^{(0,s)} c^{(1,s)}, c^{(2,s)}, c^{(3,s)}] \otimes [02\:01\:01\:03]
    \end{gather*}
    Matrixschreibweise:
    \begin{align*}
      \begin{pmatrix}
        d^{(0,s)}\\ d^{(1,s)},\\ d^{(2,s)},\\ d^{(3,s)}
      \end{pmatrix} &=
         \begin{pmatrix}
           02 (c^{(0,s)}\oplus c^{(1,s)}) \oplus c^{(1,s)} \oplus
           c^{(2,s)} \oplus c^{(3,s)}\\
           02 (c^{(1,s)} \oplus c^{(2,s)}) \oplus c^{(0,s)} \oplus
           c^{(2,s)} \oplus c^{(3,s)}\\
           02 (c^{(2,s)} \oplus c^{(3,s)}) \oplus c^{(0,s)} \oplus
           c^{(1,s)} \oplus c^{(3,s)}\\
           02 (c^{(3,s)} \oplus c^{(0,s)}) \oplus c^{(0,s)} \oplus
           c^{(1,s)} \oplus c^{(2,s)}
         \end{pmatrix}\\
      &= \begin{pmatrix}
           02& 03& 01& 01\\
           01& 02& 03& 01\\
           01& 01& 02& 03\\
           03& 01& 01& 02
         \end{pmatrix} \cdot
         \begin{pmatrix}
           d^{(0,s)}\\ d^{(1,s)}\\ d^{(2,s)}\\ d^{(3,s)}
         \end{pmatrix}
    \end{align*}

   \item Die Darstellung: wieder in einer Tabelle
  \end{enumerate}

 \item Die Schlüsseladdition
  \begin{gather*}
    S_{i+1, a} = S_{i,d} \oplus k_{i}
  \end{gather*}
\end{enumerate}

\subsubsection{Struktur des Entschlüsselungsalgorithmus}

Jeder Verschlüsselungsschritt besitzt einen Umkehrschritt
\begin{enumerate}
 \item $(\text{Byte-Sub})^{-1}$ existiert, da die affine Abbildung eine
  Umgekehrabbildung besitzt und das Inverse des Inversen des ursprüngliche
  Element im Körper liefert.

 \item $(\text{Row-Shift})^{-1}$ existiert ebenfalls. Einfach eine Rechtsverschiebung.

 \item $(\text{Column-Shift})^{-1}$ existiert, da $a(x) = 02+01x+ 01x^{2} + 03x^{3}$
  im Ring $\nicefrac{\F_{2^{8}}[x]}{x^{4}+1}$ das inverse Polynom $a^{-1}(x)$
  hat.

 \item $(\text{Key-Add})^{-1}$ existiert auch; $\oplus$ mit demselben Schlüssel.
\end{enumerate}

Bei AES ist auch der Hintergrund bekannt, wärend bei DES dies nicht war.
(Diff-Kryptoanalyse war IBM seit 1970 bekannt)

\chapter{Public-key Kryptosysteme}

\section{Tausch geheimer Schlüssel}

\todo{Hier fehlt die Vorlesung vom 8.1.}

% 10.1.

\section{Mathematischer Hintergrund: Einwegfunktion, diskreter Logarithmus,
  primitive Wurzeln}

\subsection{Modulare Exponensation mit fester Basis und festem Modul}

$f_{a,n}\colon\Z_{n} \mapsto \Z_{n}$, $f_{a,n}(m) := a^{m} \mod n$

\begin{satz}\label{satz:1}
  $f_{a,n}\in\FP$

  \begin{proof}
    rekursive Prozedur
    \begin{verbatim}
    function (a,m,n)
    begin
        if m = 0
        then return 1
        else
        begin
            if m gerade
            then return (function(a, m/z, n) ** 2) mod n
            else return (function(a, m-1, n) * a) mod n
        end
    end
    \end{verbatim}

    Dieser Algorithmus erfordert zwischen $\log_{2}m$ und $2\cdot\log_{2}m$
    Durchläufe, also $O(\log_{2}m) = O(\abs{m})$. Das heißt man benötigt
    $O(\abs{m})$ vielen Multiplikationen, d.\,h. dies ist ein
    Polynomialzeitalgorithmus.
  \end{proof}
\end{satz}

Ansatz: Die inverse "`Funktion"' $f^{-1}_{a,n}$ bezeichnen wir als
\highl{diskreter Logarithmus}. Gegeben ist $a$, $n$ und ein Wert $x$, Aufgabe
ist: Bestimmt $m$, so dass $a^{m}\mod n = x$, falls ein solches $m$ existiert.

Jedoch exstiert die inverse Funktion im allgemeinen Fall nicht, da $f_{a,n}$
nicht eineindeutig ist.
\begin{bsp}[Diskreter Logarithmus]
  $f_{5,21}(m) = 16$. Es gibt zwei Lösungen für $m$, nämlich $m_{1}=4$:
  $5^{4} = 625 = 16 \mod 21$ und $m_{2} = 10$: $5^{10} = 9\,765\,625 = 16\mod 21$
\end{bsp}

\begin{bemerk}
  Wann ist $f_{a,n}$ eineindeutig bzw. wann existiert der diskrete Logarithmus?
\end{bemerk}

\begin{dogma}
  Wir glauben, die Funktion $f_{a,n}$ ist nicht $\FP$-invertierbar.

  Könnten wir beweisen, dass $f_{a,n}$ nicht $\FP$-invertierbar ist, dann
  könnten wir zeigen, dass es eine echte Einwegfunktion gibt und dann wären
  nach der letzten Vorlesung $\mathrm{P}=\mathrm{NP}$.

  Also ist $f_{a,n}$ ein Kadidat für eine Einwegfunktion.
\end{dogma}

\begin{bemerk}
  Wenn $f$ eine Einwegfunktion ist, dann kann auch der \textit{legitimierte}
  Empfänger Bob aus dem Kryptogramm $c=f(m)$ die Botschaft $m$ nicht in
  Polynomialzeit zurückrechnen.
\end{bemerk}

\subsection{Falltür-Einwegfunktionen}

\begin{defini}
  (nach Deffie/Helman) Eine Zahlenfunktion~$f\colon X\rightarrow Y$ heißt
  \highl{Falltür-Einwegfunktion} (engl. trapp door one way function) \gdwdef
  \begin{enumerate}
   \item Die Funktion ist in Polynomialzeit berechenbar und $f$ ist
    "`ehrlich"' (Das Ergebnis der Umkehrfunktion ist in Polynomialzeit
    aufschreibbar); $f\in\FP$
   \item $f$ ist mit der Falltürinformation; $\exists g\in\FP \exists
    \text{Falltürinformation~} t \forall y\in W_{f}\colon f(g(y,T)) = y$
    (d.\,h. $f$ ist in Polynomialzeit umkehrbar)
   \item $f$ ist ohne die Falltürinformation nicht $\FP$-invertierbar
  \end{enumerate}
\end{defini}

\begin{bemerk}
  Eine solche Falltür-Einwegfunktion ist keine Einwegfunktion, denn es gibt
  einen Polynomialzeitalgorithmus, der die $\FP$-Invertierung ermöglicht.
\end{bemerk}

\subsection{Modulare Exponentation mit festem Exponenten und festem Modul}

$g_{n,m}\colon \Z_{n} \mapsto \Z_{n}$ mit $g_{n,m}(a) := a^{m} \mod n$.
(vergleiche mit der Definition von $f_{a,n}$)

\begin{satz}
  $g_{n,m}\in\FP$

  \begin{proof}
    Der rekursive Algorithmus aus \autoref{satz:1}.
  \end{proof}
\end{satz}

Ansatz: Die inverse Funktion $g_{n,m}^{-1}$ bezeichnen wir als
\highl{$m$.\,Wurzel}. Gegeben ist $n,m,y$, bestimmte $a$ mit $a^{m}\mod n =
y$, falls ein solches $a$ existiert.

\begin{bsp}
  4.\,Wurzel von $16\mod 21$, $g_{21,4}(a) = 16$: $a_{1} =5, a_{2}=2$.
\end{bsp}
Problem Wurzel nicht eindeutig.

Sind das alle 4.\,Wurzeln? Gibt es Zahlen $y$, die keine 4.\,Wurzeln hat?

Im Gegensatz zu $f_{a,n}$ lässt sich $g_{n,m}$ in Polynomialzeit invertieren,
vorrausgesetzt die Faktorisierung von $n$ steht als Falltürinformation zur
Verfügung. Dazu ein Exkurs in die Zahlentheorie.

\subsubsection{Exkurs in die Zahlentheorie}

Ansatzpunk:
\begin{gather*}
  \Z_{n}^{*} := \{ i\colon 1\leq i < n, \ggT(i,n)=1\}
\end{gather*}
ist eine multiplikative Gruppe der Ordnung $\phi(n)$.

\begin{satz}
  (von Euler) Es gilt für alle $x$ mit $1\leq x < n$ und $\ggT(x,n) = 1$ gilt
  folgenden Kongruenz:
  \begin{gather*}
    x^{\phi(n)} \equiv 1\pmod{n}
  \end{gather*}
  (Beliebiges Element hoch Ordnung der Gruppe ergibt das Einselement)

  Spezialfall ist der kleine Satz von Fermat: Für alle Primzahlen~$p$ und alle
  $x$ mit $1\leq x < p$ gilt:
  \begin{gather*}
    x^{p-1} \equiv 1\pmod{p}
  \end{gather*}
\end{satz}

Vorraussetzung für alles: $n$ ist das Produkt zwei verschiedener
Primzahlen~$p$ und $q$ ($p\ne q$): $n=pq$.

Die Eulersche $\phi$-Funktion ist multiplikativ, d.\,h. $\phi(n) = \phi(p\cdot
q) = \phi(p)\cdot\phi(q) = (p-1)\cdot (q-1)$

\begin{defini}
  Eine Zahl~$a$ ($1\leq a< n$) heißt \highl{primive Wurzel} von $n$ \gdwdef
  \begin{enumerate}
   \item $a$ und $n$ sind Teilerfremd ($\ggT(a,n)=1$) und
   \item für alle $d<\phi(n)$ gilt $a^{d}\not\equiv 1\pmod{n}$ (d.\,h. die
    Ordnung von $d$, der kleinste Exponent, dass $d^{ord}\equiv1\pmod{n}$, ist
    $\phi(n)$)
  \end{enumerate}
\end{defini}

\begin{bsp}
  Für $\Z_{5}^{*} = \{1,2,3,4\}$ ($n=5$) sind 2 und 3 primitive Wurzeln,
  4 ist keine primitive Wurzel, da $4^{2} \equiv 1\pmod{5}$. Für $\Z_{11}^{*}
  = \{ 1,2,\dotsc,10\}$ sind 2, 8, 7 und 6 die primitiven Wurzeln.

  \begin{gather*}
    \begin{array}[t]{*{4}{c}}
      a& a^{2}& a^{3}& a^{4}\\
      \hline
      2& 4& 3& 1\\
      3& 4& 2& 1\\
      4& 1& 4& 1
    \end{array} \quad
       \begin{array}[t]{*{10}{c}}
         a& a^{2}& a^{3}& a^{4}& a^{5}& a^{6}& a^{7}& a^{8}& a^{9}& a^{10}\\
         \hline
         2& 4& 8& 5& 10& 9& 7& 3& 6& 1\\
         3& 9& 5& 4& 1& 3& 9& 5& 4& 1\\
         4& 5& 9& 3& 1& 4& 5& 9& 3& 1\\
         5& 3& 4& 9& 1& 5& 3& 4& 9& 1\\
         6& 3& 7& 9& 10& 5& 8& 4& 2& 1\\
         7& 5& 2& 3& 10& 4& 6& 9& 8& 1\\
         8& 9& 6& 4& 10& 3& 2& 5& 7& 1\\
         9& 4& 3& 5& 1& 9& 4& 3& 5& 1\\
         10& 1& 10& 1& 10& 1& 10& 1& 10& 1
       \end{array}
  \end{gather*}
\end{bsp}

\begin{satz}
  (von Gauss)
  \begin{enumerate}
   \item $n$ hat eine primitive Wurzel \gdw $n=1,2$ oder $4$ oder $n = p^{k}$
    oder $n=2\cdot p^{k}$ für ungerade Primzahl~$p$.

   \item Falls $n$ primitve Wurzeln besitzt, dann $\phi(\phi(n))$ Stück.
  \end{enumerate}
\end{satz}

\begin{bemerk}
  \begin{enumerate}
   \item 8 und 12 sind die kleinsten Zahlen, die keine primitven Wurzeln haben
   \item $n=5$ hat $\phi(\phi(5)) =\phi(4) = 2$ primitve Wurzeln.
  \end{enumerate}
\end{bemerk}

Damit können wir den \highl{diskreten Logarithmus} $f_{a,n}^{-1}$ exakt als
Funktion definieren, falls $a$ eine primitive Wurzel von $n$ ist.
\begin{gather*}
  f_{a,n}^{-1}(x) := \log_{a} x \mod n
\end{gather*}
Dabei ist der Wert $\log_{a}x$ eindeutig bestimmt, als diejenige Zahl~$m$ mit
$a^{m} \log n = x$.

% 15.1.

\begin{lemma}\label{lem:1}
  Es ist bekannt, dass der erweiterte Euklidische Algorithmus korrekt ist, und
  es gilt $\ggT\in\FP$.

  \begin{proof}
    Es gibt worst-case-Abschätzungen, die zeigen, dass die Anzahl der
    Schleifendurchläufe am Größten für zwei aufeinander folgende
    Fibonacci-Zahlen $f_{k-1}$ und $f_{k}$ ist. Dann werden höchstens
    \begin{gather*}
      \floor{\log_{\frac{1}{2}(1+\sqrt{5})} (\sqrt{5}N) }-2
    \end{gather*}
    Schleifendurchläufe benötigt. Satz vin Lemé, 1985. Dabei ist $N> f_{k},
    f_{k-1}$
  \end{proof}
\end{lemma}

\begin{lemma}\label{lem:2}
  Der erweiterte Euklidische Algorithmus bestimmt in Polynomialzeit zwei
  Zahlen $c$ und $d$ mit $c\cdot \phi(n) + d\cdot m=1$.

  \begin{proof}
    o.\,B.\,d.\,A. sei $\phi(n)>m$.
    \begin{Verbatim}[gobble=4]
    Eingabe: b[0] := phi(n);    b[1] := m;
    begin
        x[0] := 1; y[0] := 0;
        x[1] := 0; y[1] := 1;
        i := 1;
        while not teilt(b[i], b[i-1]) do
        begin
            q[i] := ceil(b[i-1] / b[i]);
            b[i+1] := b[i-1] - q[i] * b[i];
            x[i+1] := x[i-1] - q[i] * x[i];
            y[i+1] := y[i-1] - q[i] * y[i];
            i := i + 1;
        end
    end
    Ausgabe: b[i], c := x[i], d := y[i];
    \end{Verbatim}

    Per Induktion können wir zeigen: $\forall i\geq0\colon b_{0}\cdot x_{i} +
    b_{1}\cdot y_{i} = b_{i}$.

    Anfang: Dies ist klar für $i=0$ und $i=1$.\\
    Schritt: Dies gilt für $i-1$ und $i$ und wir zeigen esfür $i+1$.
    \begin{align*}
      b_{0} x_{i+1} + b_{1} y_{i+1} &= b_{0} (x_{i-1} - q_{i} x_{i}) + b_{1}
         (y_{i-1}-q_{i}y_{i})\\
      &= (b_{0}x_{i-1} + b_{1} y_{i-1}) - q_{i} (b_{0} x_{i} + b_{1}y_{i})\\
      &= b_{i-1} - q_{i}b_{i} = b_{i+1}
    \end{align*}

    Wir haben damit $1=c\cdot \phi(n) +d\cdot m$ und d.\,h. $d\cdot
    m\equiv1\mod \phi(n)$. (d.\,h. $d$ ist das Inverse von $m$ in
    $\Z_{\phi(n)}^{*}$)
  \end{proof}
\end{lemma}

\begin{bsp}
  $b_{0} := 29, b_{1}:=13$
  \begin{gather*}
    \begin{array}{c|ccc}
      i& b_{i}& x_{i}& y_{i}\\
      \hline
      0& 29& 1& 0\\
      1& 13& 0& 1\\
      2& 3& 1& -2\\
      3& 1& -4& 9
    \end{array}
  \end{gather*}
  und es gilt: $(-4)\cdot 29 + 9\cdot13 = -116 + 117 = 1$
\end{bsp}

\begin{lemma}[Binomischer Satz]\label{lem:3}
  \begin{gather*}
    (r+s)^{t} = \sum_{k=0}^{t} \binom{t}{k} r^{t-k} s^{k}
  \end{gather*}
\end{lemma}

\begin{lemma}\label{lem:4}
  Für alle Primzahlen $p$ und $q$, die voneinander verschieden sind, und alle
  $x>0$ und $u>0$ gilt:
  \begin{gather*}
    x^{u}\equiv x\mod p\quad\text{und}\quad x^{u}\equiv x\mod q \Rightarrow
       x^{u}\equiv x\mod (p\cdot q)
  \end{gather*}

  \begin{proof}
    $x^{u}\equiv x\mod p$ bedeutet $x^{u}-x$ ist durch $p$ teilbar und
    entsprechend $x^{u}-x$ ist durch $q$ teilbar. Also ist $x^{u}-x$ durch
    $p\cdot q$ teilbar.
  \end{proof}
\end{lemma}
\begin{satz}
  Es gibt einen Polynomialzeitalgorithmus, der bei Eingabe von $n$, $m$ und
  $x$ ($\in\N$) mit der Eigenschaft, dass $\ggT(m,\phi(n)) = 1$, und der
  Falltürinformation $n=p\cdot q$ (für Primzahlen $p,q$), eine Zahl $a$
  bestimmt mit $a^{m}\mod n = x$.

  \begin{proof}
    Der Algorithmus besteht aus zwei Teilschritten:
    \begin{enumerate}[1.\,{Teil}]
     \item Bestimme ein $d$ mit $m\cdot d\equiv1\mod \phi(n)$ mit Hilfe des
      erweiterten Euklidischen Algorithmus':
      \begin{Verbatim}[gobble=6]
      b[0] := phi(n);    b[1] := m
      \end{Verbatim}
      und wie üblich
      \begin{align*}
        b_{0} &:= q_{1}b_{1} + b_{2} & \text{mit~} 0\leq b_{2}<b_{1}\\
        b_{1} &:= q_{2}b_{2} + b_{3}& \text{mit~} 0\leq b_{3}<b_{2}\\
        \dotso\\
        b_{k-1} &:= q_{k}b_{k} + b_{k-1}& \text{mit~} 0\leq b_{k-1}<b_{k}
      \end{align*}
      solange bis entweder $b_{k+1} = 1$ (oder $b_{k+1}=0$).

      Ausgabe: Falls $b_{k+1}=1$, dann ist $b_{k+1} = \ggT(b_{0},b_{1})$ (und
      falls $b_{k+1}=0$, dann ist $b_{k} = \ggT(b_{0},b_{1})$)

      Die zwei Lemmata zuvor. \autoref{lem:1} und \autoref{lem:2}

      Wir haben damit $1=c\cdot \phi(n) +d\cdot m$ und d.\,h. $d\cdot
      m\equiv1\mod \phi(n)$. (d.\,h. $d$ ist das Inverse von $m$ in
      $\Z_{\phi(n)}^{*}$)

     \item Berechne $x^{d}\mod n =: a$ in Polynomialzeit (schnelles
      Exponentiatieren. irgendein Satz vorher)

      Behauptung: Es gilt $a^{m}\mod n=x$. Dazu nehmen wir an, dass
      $x=y^{m}\mod n$ für irgendein $y$ und zeigen: $y=a$.

      \autoref{lem:3} können wir wie folgt anwenden: wir haben $a=x\mod n$ und
      da $x = y^{m}\mod n$ gilt $x=y^{m}-s\cdot n$ folgt
      \begin{gather*}
        a = (y^{m}-s\cdot n)^{d} \mod n = y^{m\cdot d}\mod n
      \end{gather*}
      da in allen bis auf den ersten Summanden das $n$ als Faktor auftritt.

      Da $m\cdot d\equiv1\mod \phi(n)$ gilt ein ein $t$, so dass gilt $m\cdot
      d=t\cdot\phi (n)+1$. Also gilt:
      \begin{gather}\label{eq:2}
        a\equiv y^{t\cdot\phi(n)+1}\mod n
      \end{gather}

      \begin{enumerate}[1.\,{Fall}]
       \item $y\not\equiv\mod p$. Dann gilt $y^{p-1}\equiv 1\mod p$ (Kleiner
        Fermat), d.\,h. es gilt $y^{p-1} = r\cdot p+1$ für ein passendes $r$.

        Also gilt:
        \begin{align*}
          a&= y^{t\cdot\phi(n)+1} = y^{t\cdot(p-1)\cdot(q-1)}\cdot y =
             (y^{p-1})^{t\cdot(q-1)}\cdot y\\
          &\equiv y^{t\cdot(q-1)}\cdot y\equiv y\mod p
        \end{align*}

       \item $y\equiv0\mod p$. trivialer Weise
      \end{enumerate}

      Also gilt für alle $y$
      \begin{gather*}
        a\equiv y\mod p
      \end{gather*}
      Genauso gilt $a\equiv y\mod p$. Also haben wir nach \autoref{lem:4}
      $a\equiv y\mod n$.
    \end{enumerate}
  \end{proof}
\end{satz}

\begin{dogma}
  Wir glauben, dass die Falltürinformation $n=p\cdot q$, d.\,h. Faktorisieren,
  nicht $\FP$-invertierbar ist. Das heißt, $g_{n,m}$ ist ein Kandidat für eine
  Falltür-Einwegfunktion.
\end{dogma}

Wir haben jetzt zwei Funktionen, von denen wir annehmen, dass sie nicht
invertierbar sind: der diskrete Logarithmus und die Faktorisierung von Zahlen.
Die Public-Key-Verfahren beruhen auf diesen Funktionen: RSA beruht auf der
Faktorisierung, El Gamal auf dem Logarithmus.

\begin{bemerk}
  Der erweiterte Euklidische Algorithmus erwartet als Eingabe zum einen $n$
  (ist gegeben) und zum anderen $\phi(n)$ (das ist einfach zu berechnen, falls
  die Faktorisierung $n=p\cdot q$ bekannt ist).
\end{bemerk}

\begin{fakt}
  Die Berechnung von $\phi(n)$ ist genauso schwer wie die Faktorisierung von
  $n$.

  \begin{proof}
    \begin{description}
     \item["`$\Rightarrow$"'] falls $n=p\cdot q$ bekannt ist, dann ist
      $\phi(n)$ leicht berechenbar. $\phi(n) = \phi(p\cdot q) =
      \phi(p)\cdot\phi(q) = (p-1)\cdot(q-1)$.

     \item["`$\Leftarrow$"'] falls $\phi(n)$ bekann ist (und $n$ das Produkt
      zweier Primzahlen ist), dann sind $p$ und $q$ leicht berechenbar.

      Wir erinnern uns: $\phi(n) := \card \{m\colon 0\leq m\leq n, \ggT(n,m)
      =1\}$ und $\phi(n) = n\cdot \prod_{p\mid n} (1-\frac{1}{p})$ (Dies setzt
      die Zerlegung von $n$ in Primfaktoren vorraus.)

      Gegeben sei eine natürliche Zahl $n$, für die gilt $n=p\cdot q$ für
      unbekannt Primfaktoren $p$ und $q$ mit $p\ne q$, und der Wert der
      Eulerschen $\phi$-Funktion $\phi(n)$. Die Aufgabe besteht darin:
      Bestimmt mit Hilfe dieser Größen die Primfaktoren $p$ und $q$.
    \end{description}
  \end{proof}
\end{fakt}

\clearpage
\appendix

\stepcounter{chapter}
\begin{thebibliography}{99}
\addcontentsline{toc}{chapter}{\thechapter.~\bibname}
 \bibitem{schneier} Bruce Schneier: "`Angewandte Kryptographie"', Pearson
  Studium, 1996
 \bibitem{rothe} Jörg Rothe: "`Complexity theory and cryptology---an
  introduction to cryptocomplexity"', Springer, 2005
 \bibitem{buchmann} J.\,Buchmann: "`Einführung in die Kryptographie"',
  Springer, 1999
 \bibitem{menezes} A.\,J.\,Menezes, P.\,C.\,van Oorschot, S.\,A.\,Vanstone:
  "`Handbook of Applied Cryptography"', CRC Press, 1997
 \bibitem{trappe} Trappe, Washington: "`Introduction to cryptography by coding
  theory"', Prantice Hall, 2002
 \bibitem{watjen} D.\,Wätjen: "`Kryptographie -- Grundlagen, Algorithmen,
  Protokolle"', Spektrum, 2004
 \bibitem{douglas} Douglas Stinson: "`Cryptography---Theory and praxis"', CRC
  Press, 1995
 \bibitem{bauer} F.\,Bauer: "`Entzifferte Geheimnisse"', Springer, 2000
 \bibitem{beutelspacher} A.\,Beutelspacher, J.\,Schwenk, K.-D.\,Wolfenstetter:
  "`Moderne Verfahren der Kryptographie"', 6.\,Auflage, Vieweg, 2006
 \bibitem{delfs} H.\,Delfs, H.\, Knebl: "`Introduction to cryptography"',
  Springer, 2002
 \bibitem{goldreich} O.\,Goldreich: "`Foundamentals of cryptography"',
  Cambridge, 2001
 \bibitem{diffihellman} W.\,Diffie, M.\,Hellman: "`New directions in
  cryptography"', IEEE Transaction on information theory 22, Seiten
  644--654, 1976
 \bibitem{adleman} L.\,Adleman, R.\,Rivest, A.\,Shamir: "`On digital
  signatures and public key cryptosystems"', MIT Press, 1977
 \bibitem{rsafaq} RSA Laboratories: "`RSA Laboratories' Frequently Asked
  Questions About Today's Cryptography, Version 4.1"', RSA Security Inc.,
  2000,\\ \url{ftp://ftp.rsasecurity.com/pub/labsfaq/rsalabs_faq41.pdf}
 \bibitem{rc5save} Y.\,L.\,Yin: "`The RC5 encryption algorithm: two years on"',
  CryptoBytes (3) 2, 1997
 \bibitem{idea-save} [DGV94] J.\,Daemen, R.\,Govaerts, J.\,Vandewalle: "`Weak 
  keys for IDEA, Advances in Cryptology -- Crypto '93"', Springer-Verlag, 1994
\end{thebibliography}

\chapter{Übungsaufgaben}
\section{Blatt 1}

Der folgende mit Vigenère-Chiffrierung deutschsprachige Text ist zu
entschlüsseln. (Die Blockstruktur dient lediglich der besseren Lesbarkeit.)

\subsection*{Aufgabe 1}
Bestimmen Sie eine mögliche Periodenlänge~$d$
\begin{enumerate}[a)]
 \item mit Hilfe des Kasiski-Tests.
 \item mit Hilfe des Friedman-Tests.
 \item Formulieren Sie eine Hypothese für $d$.
\end{enumerate}

\subsection*{Aufgabe 2}
Bestimmen Sie gemäß $d$ eine Häufigkeitsverteilung und leiten Sie daraus ein
Schlüsselwort ab.

\subsection*{Aufgabe 3}
Bestimmen Sie den Klartext.

\begin{verbatim}
  FSGEXV  EVIISA  MGYFNX  EJTMUR  MPNYME  FMPSIH  EFIXUE  HQFOOU
  PGIAVI  KJSWLT  IIZJIJ  ELXVOT  YBKMEC  GYUELW  RHEHOR  ONIFVS
  EHKCJS  WLFEEL  JIBNTS  VTIMGY  JSNECT  IBRQVE  HXJDHF  YVTSYP
  EEIYWX  JLNRRU  UYVCJC  BELDHZ  YVSKFE  IUERXV  TGCFKF  IHIZOF
  UGYFSP  IIGABV  VOGYRL  FGYRUM  AHKVOK  FEIUER  XRVFTY  XFHIII
  JGEIZU  ZOIZOE  LFVLAH  RKFNMT  IBCBIQ  VUHXVS  SOGYFN  ILEFSY
  MEFSSR  KBXORU  TEGEEU  IEDLCE  NVRDHN  IE
\end{verbatim}

\section{Blatt 2}

\subsection*{Aufgabe 1}
\begin{enumerate}
 \item Verschlüsseln Sie die Nachricht $m=\mathrm{WASSER}$ mit Hilfe der
  Hill-Chiffre und verwenden Sie die Matrix
  \begin{gather*}
    K =
    \begin{pmatrix}
      7 & 3\\
      5 & 8
    \end{pmatrix}
  \end{gather*}

 \item Bestimmen Sie die enschrechende Matrix zur Entschlüsselung und wenden
  Sie diese auf den in a) erhaltenen Geheimtext an.
\end{enumerate}

\subsection*{Aufgabe 2}
Bestimmen Sie eine $2\times 2$-Matrix~$M$, durch die die Nachricht "`hund"'
mit der Hill-Chiffre in den Geheimtext "`AFFE"' umgewandelt wird.

\subsection*{Aufgabe 3}
Wir definieren die Abbildung $\Phi_{a,b}\colon \Z_{26}\rightarrow\Z_{26}$ durch
\begin{gather*}
  \Phi_{a,b}(x) := (ax+b) \pmod{26}
\end{gather*}
Bestimmen Sie diejenigen ganzen Zahlen $a,b$, für die die Abbildung
$\Phi_{a,b}$ bijektiv ist.

\textbf{Bemerkung:} Diese Abbildung kann zum Verschlüsseln verwendet werden
(affine Chiffre)

\section{Blatt 3}

Der folgende Text wurde mit der Vigenère-Chiffrierung verschlüsselt. Die
Blockstruktur dient lediglich der besseren Lesbarkeit.

\subsection*{Aufgabe 1}

Bestimmen Sie eine mögliche Periodenlänge~$d$
\begin{enumerate}
 \item mit Hilfe des Kasiski-Tests.
 \item mit Hilfe des Friedman-Tests.
 \item Formulieren Sie eine Hypothese für $d$.
\end{enumerate}

\subsection*{Aufgabe 2}

Bestimmen Sie gemäß $d$ eine Häufigkeitsverteilung und leiten Sie darauf ein
Schlüsselwort ab.

\subsection*{Aufgabe 3}

Bestimmen Sie den Klartext.

\begin{verbatim}
  UEQPC  VCKAH  VNRZU  RNLAO  KIRVG  JTDVR  VRICV  IDLMY
  IYSBC  COJQS  ZNYMB  VDLOK  FSLMW  EFRZA  VIQMF  JTDIH
  CIFPS  EBXMF  FTDMH  ZGNMW  KAXAU  VUHJH  NUULS  VSJIP
  JCKTI  VSVMZ  JENZS  KAHZS  UIHQV  IBXMF  FIPLC  XEQXO
  CAVBV  RTWMB  LNGNI  VRLPF  VTDMH  ZGNMW  KRXVR  QEKVR
  LKDBS  EIPUC  EAWJS  BAPMB  VSZCF  UEGIT  LEUOS  JOUOH
  UAVAG  ZEZIS  YRHVR  ZHUMF  RREMW  KNLKV  KGHAH  FEUBK
  LRGMB  JIHLI  IFWMB  ZHUMP  LEUWG  RBHZO  LCKVW  THWDS
  ILDAG  VNEMJ  FRVQS  VIQMU  VSWMZ  CTHII  WGDJS  XEOWS
  JTKIH  KEQ
\end{verbatim}

\chapter{Lösungen}
\section{Blatt 1}
\subsection*{Aufgabe 1}
\begin{enumerate}[a)]
 \item Kasiski-Test (Wiederholung von Zeichenketten länger als 2), Beispiele:
  \begin{tabular}{l|l}
    KFEIUERX & $50 = 2\cdot 5\cdot 5$\\
    TIB & $138 = 2\cdot3\cdot23$\\
    IZO
       LAH
       GYR
  \end{tabular}

 \item Friedman-Test: $I(c) = 0,0483$ und $d\approx3\mathord{,}93$.

 \item Wir entscheiden uns für $d=5$.
\end{enumerate}

\subsection*{Aufgabe 2}
Schlüsselwort "`bauer"'.

Es bleibt: suchen 5 Caesar-Chiffren
1. Spalte: B für E, d.\,h. B für A (Verschiebung 1)\\
2. Spalte: A für E, d.\,h. A für A (Verschiebung 0)\\
3. Spalte: U für E, d.\,h. U für A (Verschiebung 3)\\
4. Spalte: E für E, d.\,h. E für A (Verschiebung 4)\\
5. Spalte: R für E, d.\,h. R für A (Verschiebung 13)\\

\todo{Ich bin mir nicht mehr sicher, ob das so richtig war. Bitte gegenprüfen.}

\subsection*{Aufgabe 3}
Es mag ueberraschen, dass man von einem vorgelegten monoalphabetisch
chiffrierten Text leichter sagen kann, ob er englisch oder franzoesisch ist
als ihn zu entschluesseln. Dies gilt natuerlich auch fuer Klartext. Es gibt
ein einfaches Verfahren genuegend langen Klartext auf Zugehoerigkeit zu einer
bekannten Sprache zu untersuchen ohne seine Syntax und Semantik zu betrachten.

\section{Blatt 2}
\subsection*{Aufgabe 1}

\begin{enumerate}
 \item
  $m=WASSER$\\
  $22~0, 18~18, 4~17$\\
  $w_{1} = v_{1}\cdot K = 24~14$\\
  $w_{2} = v_{2}\cdot K = 8~16$\\
  $w_{3} = v_{3}\cdot K = 9~18$\\
  $c=YOIJS$

 \item Die inverse Matrix zu $K$ kann man entweder mit der Formel aus
  \autoref{sec:restklassen} oder durch simultane Umformung einer
  Einheitsmatrix bei der Umformung von $K$ in eine Einheitsmatrix bestimmen.

  \begin{minipage}{.45\linewidth}
    \begin{align*}
      \begin{gmatrix}[p]
        7& 3\\ 5& 8
      \end{gmatrix} &
         \begin{gmatrix}[p]
           1& 0\\ 0&1
           \rowops
           \mult{0}{\cdot 15}
         \end{gmatrix}\\
      \begin{gmatrix}[p]
        1& 19\\ 5& 8
      \end{gmatrix} &
         \begin{gmatrix}[p]
           15& 0\\ 0&1
           \rowops
           \add[21]{0}{1}
         \end{gmatrix}\\
      \begin{gmatrix}[p]
        1& 19\\ 0& 17
      \end{gmatrix} &
         \begin{gmatrix}[p]
           15& 0\\ 3&1
           \rowops
           \mult{1}{\cdot 23}
         \end{gmatrix}\\
      \begin{gmatrix}[p]
        1& 19\\ 0& 1
      \end{gmatrix} &
         \begin{gmatrix}[p]
           15& 0\\ 17& 23
           \rowops
           \add[7]{1}{0}
         \end{gmatrix}\\
      \begin{gmatrix}[p]
        1& 0\\ 0& 1
      \end{gmatrix} &
         \begin{gmatrix}[p]
           4& 5\\ 17& 23
         \end{gmatrix}
    \end{align*}
  \end{minipage}%
  \begin{minipage}{.55\linewidth}
    Mit etwas Glück fällt auf, dass 7 eine Einheit von $\Z_{26}$ ist und man so
    leicht in der oberen linken Ecke eine 1 erzeigen kann. Das Inverse zu 7 ist
    15, daher wird die erste Zeile mit 15 durchmultipliziert.

    Dann ist es leicht in der unteren Zeile aus dem linken Element eine 0 zu
    machen: $0 = 21\cdot 1+5\pmod{26}$.

    17 ist wieder eine Einheit, so dass eine 1 durch Multiplikation mit 23
    erzeugt werden kann: $23\cdot17\pmod{26} = 1$.

    Aus der 19 lässt sich jetzt wiederrum sehr leicht eine 0 erzeugen:
    $0=1\cdot7+19\pmod{26}$.
  \end{minipage}

  \begin{gather*}
    \det K = 7\cdot8 - 3\cdot5 \pmod{26} = 41\pmod{26} = 15 \\
    \det(K^{-1}) = 7
  \end{gather*}
\end{enumerate}

\subsection*{Aufgabe 2}
hund = 7~20~13~3\\
AFFE = 0~5~5~4

\begin{gather*}
  M \cdot \begin{pmatrix}7& 13\\20 & 3\end{pmatrix} =
     \begin{pmatrix}
       0& 5\\
       20& 3
     \end{pmatrix}\\
  M =
     \begin{pmatrix}
       15& 13\\4& 9
     \end{pmatrix} \cdot
     \begin{pmatrix}
       0& 5\\
       20& 3
     \end{pmatrix} =
     \begin{pmatrix}
       20& 19\\13& 23
     \end{pmatrix}
\end{gather*}

\subsection*{Aufgabe 3}
Diese Aufgabe war eigentlich nur ein Test, ob man in der Vorlesung aufgepasst
hat, weil die Antwort bereits in \autoref{sec:tausch} gegeben wurde.

Ob die Abbildung bijektiv ist oder nicht, hängt nicht von $b$ ab.
Es hängt allein von $a$ ab, ob zwei Zeichen~$x_{1},x_{2}$ durch das gleiche
Zeichen ($E(x_{1}) = E(x_{2})$) verschlüsselt werden.
\begin{gather*}
  ax_{1} + b \equiv_{k} ax_{2}+ b \quad\Leftrightarrow\quad
     ax_{1} \equiv_{k} ax_{2}
\end{gather*}

Haben $k$ und $a$ einen gemeinsamen Teiler~$\ggT(k,a)\ne1$, so ist die
Entschlüsselung der Null beispielsweise nicht mehr eindeutig, denn $E(0) =
0\cdot a = 0$ und
\begin{gather*}
  E\Bigl(\frac{k}{\ggT(k,a)}\Bigr) = \frac{k}{\ggT(k,a)} \cdot a \pmod{k}
     = k\cdot \underbrace{\frac{a}{\ggT(k,a)}}_{\in\Z_{k}, > 1} \pmod{k}
     = 0
\end{gather*}

Also muss $a$ teilerfremd zu $k$ sein, damit alle $\Phi_{a,b}$ bijektiv sind.
\help{Warum ist das hinreichend?}

\section{Blatt 3}

\subsection*{Aufgab 3}
Den hoechsten Organisationsstand erfuhr die Kryptologie in Venedig, wo sie in
Form einer staatlichen Buerotaetigkeit ausgeuebt wurde. Es gab
Schluesselsekretaere die ihr Buero im Dogenpalast hatten und fuer ihre
Taetigkeit rund zehn Dukaten im Monat bekamen. Es wurde dafuer gesorgt, dass
sie waehrend ihrer Arbeit nicht gestoert wurden. Sie durften ihre Bueros aber
auch nicht verlassen, bevor sie eine gestellte Aufgabe geloest hatten.

\clearpage
\pdfbookmark[0]{Index}{index}
\printindex

\end{document}
