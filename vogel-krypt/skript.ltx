
% ToDo:
%   + Es sollte Befehle für Klartext und Chiffretext geben, damit die Texte im
%     gesamten Dokument gleich aussehen. z.\,B. \klartext=\texttt\uppercase
%     und \chiffretext=\texttt\lowercase; \MakeUppercase \MakeLowercase
%     \bstv = Buchstabe verschlüsselt
%     \bstu = Buchstabe unverschlüsselt
%     \textv = Text verschlüsselt
%     \textu = Text unverschlüsselt
%     \schlsl = Schlüssel

% Einige zusätzliche Informationen für rubber
%  rubber erkennt nicht, dass die Datei weg kann, daher sagen wir es ihm
% rubber: clean $base.thm
%  rubber soll nach Änderungen an der Datei nochmal bauen
% rubber: watch $base.thm
% rubber: makeidx.tool      xindy
% rubber: makeidx.language  german-din
%
% scrreprt trifft am Besten die Bedürfnisse eines Skripts, das ganze wird
% zweiseitig (twoside), d.h. es wird zwischen linker und rechter Seite
% unterschieden, und wir verwenden zwischen den Absätzen einen Abstand
% von einer halben Zeile (halfparskip) und dafür keinen Absatzeinzug,
% wobei die letzte Zeile eines Absatzes zu min. 1/4 leer ist.

\RequirePackage[l2tabu,orthodox]{nag}  % nag überprüft den Text auf verältete
                                       % Befehle oder solche, die man nicht in
                                       % LaTeX verwenden soll --
                                       % l2tabu-Checker in LaTeX

\RequirePackage[ngerman=ngerman-x-latest]{hyphsubst} % einbinden der neuen
                   % Trennmuster, diese korrigieren einige Fehler der alten
                   % und bieten mehr Trennstellen

\documentclass[ngerman,draft,twoside]{scrreprt}

\usepackage{ifthen}
\usepackage{index}
\usepackage[final]{graphicx}  % Für Grafiken
\usepackage{xcolor}
\usepackage[draft=false,colorlinks,bookmarksnumbered,linkcolor=blue,breaklinks]{hyperref}

\usepackage[utf8]{inputenc}
\usepackage{babel}

\usepackage{lmodern}		% Latin Modern
\usepackage[T1]{fontenc}        % T1-Schriften notwendig für PDFs
\usepackage{textcomp}           % wird benötigt, damit der \textbullet
                                % für itemize in lmodern gefunden wird.

\usepackage[intlimits,leqno]{amsmath}
\usepackage[all,warning]{onlyamsmath}  % warnt bei Verwendung von nicht
                                       % amsmath-Umgebungen z.\,B. $$...$$
\usepackage{amssymb}     % wird für \R, \C,... gebraucht
\usepackage{fixmath}     % ISO-konforme griech. Buchstaben
\usepackage[euro]{isonums} % definiert Komma als Dezimaltrennzeichen

\usepackage[amsmath,thmmarks,hyperref]{ntheorem} % für die Theorem-Umgebungen
                                                 % (satz, defini, bemerk)
\usepackage{paralist}    % besseres enumerate und itemize und neue
                         % compactenum/compactitem; s. texdoc paralist

\usepackage{svn}         % Zum Auswerten und ordentlichen Darstellen der
                         % SVN-Schlüsselwörter (s. vor \begin{document})
                         % dafür muss in SVN noch das Flag svn:keywords
                         % auf "LastChangedRevision LastChangedDate"
                         % gesetzt werden
\usepackage{ifpdf}       % Erkennung, ob PDF generiert wird; nützlich zur
                         % Unterscheidung bei Grafiken \input{XYZ.pdf_t}
\usepackage{ellipsis}    % Korrektur für \dots
\usepackage{fixltx2e}
\usepackage[final]{microtype} % Verbesserung der Typographie
\usepackage{nicefrac}
\usepackage{gauss}
\usepackage{fancyvrb}
\usepackage{tabularx}
\usepackage{pigpen}
\usepackage{todonotes}
\usepackage{braket}
\usepackage{mathtools}

% Damit auch die Zeichen im Mathemode in Überschriften fett sind
% <news:lzfyyvx3pt.fsf@tfkp12.physik.uni-erlangen.de>
\addtokomafont{sectioning}{\boldmath}

% nach dem Theoremkopf wird ein Zeilenumbruch eingefügt, die Schrift des
% Körpers ist normal und der Kopf wird fett gesetzt
\theoremstyle{break}
\theorembodyfont{\normalfont}
\theoremheaderfont{\normalfont\bfseries}
\theoremnumbering{arabic}

% Die folgenden Umgebungen werden einzeln nummeriert und am Ende jedes
% Kapitels zurückgesetzt
\newtheorem{bemerk}{Bemerkung}[chapter]
\newtheorem{defini}{Definition}[chapter]
\newtheorem{bsp}{Beispiel}[chapter]
\newtheorem{satz}{Satz}[chapter]
\newtheorem{lemma}{Lemma}[chapter]

% Die folgenden Theoremumgebungen bekommen keine Nummer
\theoremstyle{nonumberbreak}

\newtheorem{dogma}{Dogma}

\theoremheaderfont{\scshape}
\theorembodyfont{\normalfont}
% Das Zeichen am Ende eines Beweises
\theoremsymbol{\ensuremath{_\blacksquare}}
% \theoremsymbol{q.\,e.\,d.}
\newtheorem{proof}{Beweis:}

% Hier die Definition, wie \autoref die Umgebungen nennen soll, die mit
% \newtheorem definiert wurden
\newcommand*{\bemerkautorefname}{Bemerkung}
\newcommand*{\definiautorefname}{Definition}
\newcommand*{\bspautorefname}{Beispiel}
\newcommand*{\satzautorefname}{Satz}
\newcommand*{\lemmaautorefname}{Lemma}
% Zwischen Unter- und Unterunterabschnitten sollte nicht unterschieden
% werden.
\renewcommand*{\subsectionautorefname}{Abschnitt}
\renewcommand*{\subsubsectionautorefname}{Abschnitt}

\pagestyle{headings}

\newcommand*{\N}{\mathbb{N}}      % natürliche Zahlen
\newcommand*{\Z}{\mathbb{Z}}      % ganze Zahlen
\newcommand*{\R}{\mathbb{R}}      % reellen Zahlen
\newcommand*{\F}{\mathbb{F}}      % endliche Ringe
\newcommand*{\NP}{\mathrm{NP}}    % Klasse der nichtpolynomiellen Probleme
\newcommand*{\FP}{\mathrm{FP}}    % Funktionen, die in Polynomialzeit
                                  % berechnet werden können

% Wenn irgendwo Unklarheiten zum Inhalt im Skript auftreten, können sie
% einfach mit \help{Ich verstehe das nicht} hervorgehoben werden. Dies
% macht es leichter sie alle zu finden und auch ganz einfach
% auszublenden, indem man den Befehl einfach leer definiert
\newcommand*{\help}[1]{\todo[color=green!40]{#1}}

% Um wichtige Begriffe im Text überall gleich vorzuheben (gleiches
% Markup), sollte dieser Befehl verwendet werden. Das Argument wird
% automatisch als Indexeintrag verwendet. Dieser kann aber auch als
% optionales Argument selbst bestimmt werden.
\newcommand*{\highl}[2][]{\textbf{\boldmath{#2}}%
  \ifthenelse{\equal{#1}{}}{\index{#2}}{\index{#1}}%
}

% Befehl für die Darstellung der Gliederungsüberschriften im Index
\newcommand*{\lettergroup}[1]{\minisec{#1}}

% Um sicherzustellen, dass jeder Betrag-/jede Norm links und rechts die
% Striche bekommt, sind diese Befehle da. Damit kann man nicht die
% rechten Striche vergessen und es wird etwas übersichtlicher. (Vorschlag
% ist aus amsldoc) \abs[\big]{\abs{a}-\abs{b}} \leq \abs{a+b}
\DeclarePairedDelimiter{\abs}{\lvert}{\rvert}
\DeclarePairedDelimiter{\norm}{\lVert}{\rVert}

% Diese Befehle sind dafür gedacht, dass die Symbole für "genau dann wenn"
% im ganzen Dokument gleich aussehen. Außerdem erlaubt es eine schnelle
% Veränderung aller Stellen, falls der Prof. doch nicht mehr gdw nimmt,
% sondern \Leftrightarrow.
\newcommand*{\gdw}{\ifthenelse{\boolean{mmode}}%
			       {\mspace{8mu}gdw\mspace{8mu}}%
			       {$gdw$\xspace}}
\newcommand*{\gdwdef}{\ifthenelse{\boolean{mmode}}%
			       {\mspace{8mu}gdw_{def}\mspace{8mu}}%
			       {$gdw_{def}$\xspace}}

% Das original Epsilon sieht nicht so toll aus
\renewcommand*{\epsilon}{\varepsilon}
% ... und mancheinem gefällt auch das Phi nicht
\renewcommand*{\phi}{\varphi}
\renewcommand*{\tilde}{\widetilde}


\makeindex

\SVN $LastChangedRevision$
\SVN $LastChangedDate$

\newcounter{cnt}
\setcounter{cnt}{1}
\whiledo{\thecnt < 27}{%
  \DeclareGraphicsRule{.\thecnt}{\ifpdf mps\else eps\fi}{*}{}%
  \stepcounter{cnt}%
}

\DeclareMathOperator{\sgn}{sgn}          % Signum/Vorzeichen
\DeclareMathOperator{\ggT}{ggT}          % größter gemeinsamer Teiler
\DeclareMathOperator{\kgV}{kgV}          % kleinstes gemeinsames Vielfaches
\DeclareMathOperator{\card}{card}        % Kardinalität

% Der Befehl \coloneq definiert ein := und ist aus dem Paket txfonts
% kopiert.
\newcommand*{\coloneq}{\mathrel{\mathop:}=}


\begin{document}

\title{Kryptologie -- von einer Geheimwissenschaft zu einer Wissenschaft
  von den Geheimnissen}
\author{Dr.\,Jörg Vogel}
\date{WS 2006/07}
\maketitle

\clearpage
\chapter*{Vorwort}

{\itshape
  Dieses Dokument wurde als Skript für die auf der
  Titelseite genannte Vorlesung erstellt und wird jetzt im Rahmen des
  Projekts
  "`\href{http://uni-skripte.lug-jena.de/}
  {Vorlesungsskripte der Fakultät für Mathematik}
  \href{http://uni-skripte.lug-jena.de/}{und Informatik}"'
  weiter betreut. Das
  Dokument wurde nach bestem Wissen und Gewissen angefertigt. Dennoch
  garantiert weder der auf der Titelseite genannte Dozent, die Personen,
  die an dem Dokument mitgewirkt haben, noch die
  Mitglieder des Projekts für dessen Fehlerfreiheit. Für etwaige Fehler
  und dessen Folgen wird von keiner der genannten Personen eine Haftung
  übernommen. Es steht jeder Person frei, dieses Dokument zu lesen, zu
  verändern oder auf anderen Medien verfügbar zu machen, solange ein
  Verweis auf die Internetadresse des Projekts
  \url{http://uni-skripte.lug-jena.de/}
  enthalten ist.

  Diese Ausgabe trägt die Versionsnummer~\SVNLastChangedRevision{} und ist vom
  \SVNDate{}. Eine neue Ausgabe könnte auf der Webseite des Projekts verfügbar
  sein.

  Jeder ist dazu aufgerufen, Verbesserungen, Erweiterungen und
  Fehlerkorrekturen für das Skript einzureichen bzw. zu melden oder diese
  selbst einzupflegen -- einfach eine E-Mail an die
  \href{mailto:uni-skripte@lug-jena.de}{Mailingliste
  \texttt{<uni-skripte@lug-jena.de>}} senden. Weitere Informationen
  sind unter der oben genannten Internetadresse verfügbar.

  Hiermit möchten wir allen Personen, die an diesem Skript mitgewirkt
  haben, vielmals danken:
  \begin{itemize}
   \item \href{mailto:joerg@alea.gnuu.de}{Jörg Sommer
    \texttt{<joerg@alea.gnuu.de>}} (2006/07)
   \item \href{mailto:jens@kubieziel.de}{Jens Kubieziel
    \texttt{<jens@kubieziel.de>}} (2006)
   \item Michael Preiss (2006/07)
   \item Christine List (2007)
  \end{itemize}
}

\clearpage
\pdfbookmark[0]{Inhaltsverzeichnis}{inhaltsverzeichnis}
\tableofcontents

\chapter{Einführung in die Kryptologie}

\begin{defini}[Kryptologie]
  \highl{Kryptologie} ist die Wissenschaft von der sicheren Übertragung
  (und Speicherung) von Nachrichten.

  Dabei unterscheidet man zwei Teilgebiete:
  \begin{itemize}
   \item die \highl{Kryptographie} als die Kunst des Verschlüsselns und
   \item die \highl{Kryptoanalyse} als die Kunst des Codebrechens.
  \end{itemize}
\end{defini}

Die Übertragung der Nachricht erfolgt über \highl{Kanäle}\index{Kanal}, wie z.\,B. Boten,
Kupferleitungen, Glasfasern oder drahtlose Verbindungen. Dabei kann es zu
verschiedenen Beeinträchtigungen kommen:
\begin{itemize}
 \item zufällige Störungen -- der Bote stürzt in eine Felsspalte.
 \item systematische (physikalisch bedingte) Störungen -- im Wald werden alle
  Boten gefangen genommen.
 \item passive Beeinträchtigungen -- während der König die Botschaft seinem
  Schreiber diktiert, hört der Spion hinterm Vorhang alles mit; Abhören von
  Telefongesprächen, Auslesen von Speichermedien.
 \item aktive Beeinträchtigungen -- während der Bote sein Nickerchen macht,
  tauscht ein Spion die Botschaft aus; Fälschen von Nachrichten und Daten.
\end{itemize}
Mit den ersten beiden Punkten, also wie sichert man Nachrichten gegen
Störeinflüsse, beschäftigt sich die Kodierungstheorie. Die
passiven und aktiven Beeinträchtigungen sind Gegenstand der Kryptologie.

Aus diesen Beeinträchtigungen ergeben sich Anforderungen an kryptologische
Verfahren:
\begin{itemize}
 \item \highl{Geheimhaltung}/\highl{Vertraulichkeit} -- Lesen der Nachricht
  für Unbefugte möglichst schwierig gestalten.
 \item \highl{Authentifizierung} -- Empfänger kann die \highl{Identität} des
  Senders prüfen; \highl{Authentisierung} -- Sender kann seine Identität
  einem Empfänger gegenüber beweisen; Empfänger weiß, dass die Nachricht
  nicht von einem Dritten stammt.
 \item \highl{Integrität} -- Nachricht wurde während der Übertragung nicht
  verändert (Austauschen, Weglassen oder Hinzufügen von Teilen).
 \item \highl{Verbindlichkeit} -- Sender kann nicht leugnen, dass die Nachricht
  von ihm stammt.
\end{itemize}

Im Laufe der Zeit hat sich das Anwendungsgebiet für Kryptologie gewandelt.
Früher wurde sie vorwiegend zur Geheimhaltung z.\,B. militärischer Anwendungen
eingesetzt, während heute durch den enormen Zuwachs der Kommunikation in
offenen Netzwerken Kryptologie auch verstärkt im zivilen Bereich eingesetzt
wird.

\section{Grundbegriffe}

Der \highl{Sender} --~in der Kryptologie wird dieser mit
\highl{Alice}\cite{rivest1978}
bezeichnet~-- verschlüsselt seine \highl{Nachricht}\footnote{Nachricht: auch
\highl{Klartext} oder \highl{plain text} genannt} mit Hilfe eines
\highl[Schlüssel]{Schlüssels} unter Verwendung eines
\highl[Verschlüsselungsverfahren]{Verschlüsselungsverfahrens}%
\footnote{Verschlüsselungsverfahren: auch als \highl{Chiffrierung} oder
  \highl{encryption} bezeichnet} und erhält so einen \highl{Geheimtext}%
\footnote{Geheimtext: auch \highl{Chiffretext} oder \highl{Kryptogramm}
  genannt} für die Nachricht. Diesen sendet er dem Empfänger --~in der
Kryptologie wird dieser mit \highl{Bob} bezeichnet~--, der durch Anwendung
eines \highl[Entschlüsselungsverfahren]{Entschlüsselungsverfahrens}%
\footnote{Entschlüsselungsverfahren: auch als \highl{Dechiffrierung} oder
  \highl{decryption} bezeichnet} wieder die Nachricht rekonstruieren kann.

Während der Übertragung könnte ein \highl[Angreifer!passiver]{passiver
Angreifer} --~in der Kryptologie wird dieser mit
\highl{Eve}\footnote{Eve: vom englischen Wort \textit{eavesdropper}
für Horcher oder Lauscher} bezeichnet~-- aus dem Geheimtext die
Nachricht oder Teile davon rekonstruieren und aus diesem Wissen
Vorteile ziehen. Oder ein \highl[Angreifer!aktiver]{aktiver Angreifer}
--~in der Kryptologie wird dieser mit
\highl{Mallory}\footnote{Mallory: vom englischen Wort
\textit{malicious} für bösartig} bezeichnet~-- könnte den Geheimtext
so verändern, dass der Klartext eine andere Bedeutung bekommt.

\begin{defini}[Kryptosystem]
  Ein \highl{Kryptosystem}~$\mathcal{S}$ ist ein Fünftupel
  $\mathcal{S}=(\mathcal{M}, \mathcal{C}, \mathcal{K}, E, D)$ bestehend aus:
  \begin{itemize}
   \item einer Menge von Nachrichten, die als \highl{Klartextraum}~$\mathcal{M}$
    ($\subseteq\Sigma^{\ast}$) bezeichnet wird; ein Element dieser Menge ist
    eine \highl{Nachricht}~$m\in\mathcal{M}$.

   \item dem \highl{Geheimtextraum}~$\mathcal{C}$ ($\subseteq\Gamma^{\ast}$),
    der Menge aller \highl[Kryptogramm]{Kryptogramme}~$c\in\mathcal{C}$,

   \item dem \highl{Schlüsselraum} $\mathcal{K}$, wobei jeder
    \highl{Schlüssel} $k\in\mathcal{K}$ ein Paar $k=(k_{e}, k_{d})$ ist, von
    dem $k_{e}$ zur Verschlüsselung und $k_{d}$ zur Entschlüsselung verwendet
    wird.

   \item einem \highl{Verschlüsselungsalgorithmus} $E\colon\mathcal{M}\times
    \mathcal{K}\rightarrow\mathcal{C}$ für den gilt $E(m, k_{e}) = c$,
    wobei für zwei unterschiedliche Nachrichten $m_{1}$ und $m_{2}$ gilt:
    $E(m_{1}, k_{e}) \ne E(m_{2}, k_{e})$ und

   \item einem \highl{Entschlüsselungsalgorithmus} $D\colon \mathcal{C}\times
    \mathcal{K}\rightarrow\mathcal{M}$ mit $D(c, k_{d}) = m$.
  \end{itemize}
\end{defini}

Aus diesen Festlegungen ergeben sich folgende Konsequenzen für die
Kommunikation zwischen Alice und Bob:
\begin{enumerate}
 \item Vor der Übertragung müssen sich beide über das
  Verfahren einigen.
 \item Viele Schlüssel sind eine notwendige Voraussetzung (großer Schlüsselraum) für die
  Sicherheit eines Verfahrens.
 \item Vor der Übertragung müssen sie sich auf ein
  Schlüsselpaar $k=(k_{e},k_{d})$ einigen.
 \item Der Schlüssel $k_{d}$ muss geheim gehalten werden.
\end{enumerate}

Da für den Austausch des Schlüssels zwischen Alice und Bob eine sichere
Übertragung --~sozusagen eine verschlüsselte Verbindung~-- notwendig ist,
stellt sich die Frage, warum die beiden nicht gleich die Nachricht über diese
sichere Verbindung übertragen.
\begin{itemize}
 \item Im Allgemeinen ist die Nachricht wesentlich länger als der Schlüssel,
  d.\,h. der Schlüsselaustausch kann über andere (langsamere, aber sicherere)
  Kanäle als der Nachrichtenaustausch erfolgen. Alice lässt Bob das Kennwort
  durch einen Boten zukommen und der Austausch der Nachricht geschieht dann
  per E-Mail.

 \item Der Zeitpunkt der Schlüsselübergabe ist frei wählbar. Es können also bei
  einem persönlichen Treffen mehrere Schlüssel für spätere Verbindungen
  vereinbart werden.

 \item Mit demselben Schlüssel lassen sich mehrere Nachrichten verschlüsseln.
\end{itemize}

\begin{defini}[Kerckhoffs' Prinzip]
  Das \highl[Kerckhoffs' Prinzip]{Kerckhoffs' Prinzip}\index{Prinzip!Kerckhoffs'} besagt, dass die \highl{Sicherheit} eines
  Kryptosystems nur von der Geheimhaltung des Schlüssels jedoch nicht von der
  Geheimhaltung des Algorithmus' abhängt.
\end{defini}

Dieses Prinzip wurde 1883 von \textsc{Auguste Kerckhoffs} in seiner
Arbeit "`La cryptographie militaire"'\footnote{Nachzulesen bei
\href{http://www.petitcolas.net/fabien/kerckhoffs/}{Fabien
Petitcolas}} niedergeschrieben. Er formulierte das Prinzip in sechs
Einzelpunkten.

% 18.10.2006

\begin{bsp}[praktische Kryptographie]
  Der
  \href{http://de.wikipedia.org/wiki/Freimaurer-Alphabet}{\highl{Freimaurercode}}
  (zweite Zeile in \autoref{fig:1}) arbeitet ohne Schlüssel. Jeder Buchstabe des Alphabets wird durch
  ein bestimmtes Geheimzeichen ersetzt. Damit ist der Freimaurercode kein
  Kryptosystem, da das Kerckhoffs' Prinzip verletzt ist: Die Sicherheit
  des Kryptosystems hängt von der Geheimhaltung des Algorithmus' ab.
  \begin{figure}[ht]
    \centering\ttfamily\large
    dieser satz ist geheim\\
%    \fmc{dieser~satz~ist~geheim}\\
    {\pigpenfont DIESER SATZ IST GEHEIM}\\
    UZVJVI JRKQ ZJK XVYVZD\\
    TFZZGR EDFY ABX IFFHXY
    \caption{Verschlüsselung der ersten Zeile mit dem Freimaurercode
      (2.\,Zeile), der Caesar-Chiffre (3.\,Zeile) und einem One-Time-Pad (4.\,Zeile)}
    \label{fig:1}
  \end{figure}

  Bei der \highl{Caesar-Chiffre} (dritte Zeile in \autoref{fig:1}) wird jeder
  Buchstabe des Alphabets für sich durch den Buchstaben, der $k$ Positionen
  weiter hinten steht, ersetzt.
  $k\in\{1,2,\dotsc,25\} = \mathcal{K}$ ist der Schlüssel dieses
  Kryptosystems -- im obigen Beispiel ist $k=17$. Jedoch ist diese Art der
  Verschlüsselung nicht sicher. Dazu später mehr.

  Der \highl{One-Time-Pad} (vierte Zeile in \autoref{fig:1}) ist ähnlich dem Caesarcode, jedoch
  wird hierbei (unabhängig und gleichverteilt) für jedes einzelne Zeichen der
  Nachricht eine Zahl $k\in\{0,1,\dotsc,25\}$ gewählt, um die das Zeichen
  verschoben wird. Der Schlüssel für eine Nachricht $m=(m_{1},m_{2},\dotsc,
  m_{n})$ ist also ein Tupel $k=(k_{1},k_{2},\dotsc, k_{n})$ der Länge~$n$.
  Dieses Kryptosystem schützt sich nicht nur durch den großen Schlüsselraum
  $26^{n}$, sondern auch dadurch, dass jeder beliebige Text mit einem geeigneten
  Schlüssel erzeugt werden kann.
\end{bsp}

Zur Einstufung einer \highl{Kryptoanalyse} trifft man die folgenden qualitativen
Unterscheidungen:
\begin{itemize}
  \item \highl[Aufbrechen!vollständiges]{vollständiges Aufbrechen} (\textit{engl.} total break) heißt,
  dass der Schlüssel $k_{d}$
  entdeckt wird, woraufhin jede Nachricht~$m$, die mit $k_{e}$ verschlüsselt
  wird, entschlüsselt werden kann.

 \item \highl[Deduktion!globale]{globale Deduktion} (\textit{engl.} global
  deduction) bedeutet, dass ohne
  Kenntnis von $k_{d}$ ein zu $D(c, k_{d})$ äquivalentes Verfahren~$\tilde{D}$
  gefunden wird, so dass man jede Nachricht~$m=D(c, k_{d})$ durch
  $m=\tilde{D}(c)$ rekonstruieren kann.

 \item \highl[Deduktion!lokale]{lokale Deduktion} (\textit{engl.} instance or
  local deduction) bezeichnet das Finden
  eines Klartexts für einen einzelnen Chiffretext.
 \item \highl{Informationsdeduktion} (\textit{engl.} information deduction) bedeutet,
  dass einige Informationen über den Schlüssel oder den Klartext gewonnen werden
  können.
\end{itemize}

Ebenso gibt es eine Unterscheidung der verschiedenen Arten eines
\highl[Angriff]{Angriffs} auf ein Kryptosystem:
\begin{description}
 \item[Cyphertext-Only-Angriff:]\index{Angriff!Cyphertext-Only-} Der
  Kryptoanalytiker verfügt über eine gewisse Menge von Geheimtexten.

 \item[Known-Plaintext-Angriff:]\index{Angriff!Known-Plaintext-}
  Für einen gewissen Chiffretext ist der Klartext bekannt.

 \item[Chosen-Plaintext-Angriff:]\index{Angriff!Chosen-Plaintext-}
  Für einen beliebigen Klartext ist es möglich, sich den zugehörigen
  Chiffretext zu besorgen. (Typisch für Public-Key-Verfahren)

  \item[Adaptive-Chosen-Plaintext-Angriff:]\index{Angriff!Adaptive-Chosen-Plaintext} Spezialfall des obigen
  Angriffszenarios. Hier wählt der Kryptoanalytiker einen Klartext basierend
  auf dem Ergebnis der vorigen Verschlüsselung.

  \item[Chosen-Ciphertext-Angriff:]\index{Angriff!Chosen-Ciphertext} Verschiedene Chiffrate können
  entschlüsselt werden und es besteht Zugriff zum entschlüsselten Text.

  \item[Chosen-Key-Angriff:]\index{Angriff!Chosen-Key} Man hat Wissen über die Beziehungen
  verschiedener Schlüssel untereinander (i.\,d.\,R. nicht praktisch
  relevant)

 \item[Rubber-Hose-Cryptanalysis:]\index{Cryptanalysis!Rubber-Hose} Angriff durch Gewalt/Erpressung/Entführung

 \item[Brute-Force-Angriff:]\index{Angriff!Brute-Force}\index{Brute-Force} Alle möglichen Schlüssel austesten. Dieses
  Verfahren sollte das effektivste sein.
\end{description}

Abhängig von der \highl{Sicherheit} des Ver-/Entschlüsselungsverfahrens kann
man Kryptosysteme in die Kategorien "`uneingeschränkt sicher"' (z.\,B.
One-Time-Pad), "`praktisch sicher"' (in praktikabler Zeit keine Lösung; die
Tageszeitung von Morgen erst nächste Woche entschlüsseln) und "`unsicher"'
(z.\,B. Caesarcode) einteilen.

Derzeit ist das \highl{One-Time-Pad} das einzige bekannte, uneingeschränkt sichere
Kryptoverfahren. In der Praxis findet es hauptsächlich im militärischen Bereich
und in hoch sicheren Umgebungen Anwendung.

Alle weiteren Kryptosysteme sind mit einem
\highl[Angriff!Ciphertext-Only-]{Ciphertext-Only-Angriff} verwundbar.
Man probiert einfach jeden möglichen Schlüssel und prüft, ob der resultierende
Klartext eine Bedeutung hat. Einen derartigen Angriff nennt man
\highl[Angriff!Brute-Force-]{Brute-Force-Angriff}, da diese nur mit roher
Gewalt (Durchtesten aller Kombinationen)
funktioniert.

% \todo{Wo soll das hin? Besseren Platz oder eine Umformulierung finden.}
% \highl{leicht} wird im gesamten Skript für "`in Polynomialzeit"' gebraucht.
% Analog dazu bedeutet \highl{schwer}, dass ein Problem "`nicht in
% Polynomialzeit"' gelöst werden kann.

\section{Beispiel einer praktischen Kryptoanalyse}
\label{sec:ka-bsp}
In der Regel kann man nicht von der Größe des Schlüsselraums eines
Kryptosystems auf die Sicherheit des Systems schließen. Folgendes Beispiel
soll dies verdeutlichen.

Ein Kryptosystem, das jedem Buchstaben des Klartexts ein Zeichen des
Chiffretexts zuordnet, nennt man \highl{monoalphabetisch}, d.\,h. der
Schlüssel ist eine Permutation der Chiffretextbuchstaben. Es gibt also $26!=
403\,291\,461\,126\,605\,635\,584\,000\,000$~Schlüssel.
\begin{center}
  \begin{tabular}{l|*{4}{>{\ttfamily}c}c*{3}{>{\ttfamily}c}}
    Klartextbuchstabe& a& b& c& d& \dots & x& y& z\\
    Schlüssel& V& J& C& E& \dots & A& H& D
  \end{tabular}
\end{center}

Trotz dieses großen Schlüsselraums ist es recht einfach die Verschlüsselung
durch eine \highl{Häufigkeitsanalyse} zu brechen. Aus der Größe des
Schlüsselraums kann man also keine unmittelbaren Rückschlüsse auf die
Sicherheit des Kryptosystems ziehen.

\begin{figure}[ht]
  \centering
  \begin{Verbatim}[gobble=2]
  CJ UAFFC CHZ WAZZ CHZCZ CJCN, LCT JDUOZ NAZGC SAUTC LHC JACDVC
  PZYCTLTOJJCZ QPT WPCUNC GCFTAGCZ UAFFC, LCJJCZ VTACRFC AXCT ZPZ QP
  CZLC GHZGCZ, JO LAJJ CT QPT ATXCHF HWWCT PZFAPGNHDUCT IATL. LA LADUFC
  LCT UCTT LATAZ, HUZ APJ LCW RPFFCT QP JDUARRCZ, AXCT LCT CJCN WCTVFC,
  LAJJ VCHZ GPFCT IHZL ICUFC, NHCR ROTF PZL WADUFC JHDU APR LCZ ICG
  ZADU XTCWCZ: LOTF, WCHZFC CT, VOCZZFC CT SA JFALFWPJHVAZF ICTLCZ.
  \end{Verbatim}
  \caption{Ein Beispiel eines Geheimtexts, der sich leicht mit
    Häufigkeitsanalyse brechen lässt.}
  \label{fig:2}
\end{figure}

\begin{enumerate}[1.\,{Schritt:}]
 \item Die Buchstaben im Geheimtext zählen. Für den Text in \autoref{fig:2}
  ergibt sich:
  \begin{center}
    \begin{tabular}{l*{7}{>{\ttfamily}c}c}
      Buchstabe:& C& Z& T& A& F& L& J& \dots \\
      Häufigkeit:& 62& 31& 29& 27& 22& 20& 19& \dots
    \end{tabular}
  \end{center}

  \begin{table}
    \centering
    \begin{tabular}{cc*{3}{||cc}}
      Bst. & Wsk. & Bst. & Wsk. & Bst. & Wsk. & Bst. & Wsk.\\
      \hline
      E & 17,40\,\% & D & 5,08\,\% & O & 2,51\,\% & V & 0,67\,\%\\
      N & 9,78\,\%  & H & 4,76\,\% & B & 1,89\,\% & ß & 0,31\,\%\\
      I & 7,55\,\%  & U & 4,35\,\% & W & 1,89\,\% & J & 0,27\,\%\\
      S & 7,27\,\%  & L & 3,44\,\% & F & 1,66\,\% & Y & 0,04\,\%\\
      R & 7,00\,\%  & C & 3,06\,\% & K & 1,21\,\% & X & 0,03\,\%\\
      A & 6,51\,\%  & G & 3,01\,\% & Z & 1,13\,\% & Q & 0,02\,\%\\
      T & 6,15\,\%  & M & 2,53\,\% & P & 0,79\,\% & \\
    \end{tabular}
    \parbox{12cm}{
      \caption{Häufigkeitsverteilung der Buchstaben der deutschen
        Sprache. Die Buchstaben ä, ö, ü wurden wie ae, oe, ue gezählt.
        \textit{Quelle:
% skript-check aus
          \href{http://de.wikipedia.org/wiki/Buchstabenh\%C3\%A4ufigkeit}%
% skript-check an
               {Wikipedia}}}}
    \label{tab:buchswsk}
  \end{table}

 \item Für natürliche Sprachen wie Deutsch ergibt sich in großen Texten eine
  signifikante Verteilung der Buchstaben (\autoref{tab:buchswsk}). Anhand der
  bekannten Verteilung der Buchstaben in der Sprache und der
  Häufigkeitsanalyse aus dem 1.\,Schritt, kann man die Klartextbuchstaben für
  einige Geheimtextzeichen bestimmen. So steht z.\,B. in einem deutschen Text das
  am häufigsten auftretende Zeichen für das E. Für den Text in
  \autoref{fig:2} ist also \texttt{e} durch \texttt{C} verschlüsselt.

  Da die Zeichenfolge \texttt{ZZ} vorkommt, ist ein weiterer Ansatz,
  dass das \texttt{Z} dem \texttt{n} entspricht.

  Aus den Teilen \texttt{CHZ} (\texttt{eHn}) und \texttt{CHZCZ}
  (\texttt{eHnen}) kann man schließen, dass das \texttt{H} dem \texttt{i}
  entspricht.

  Auffällig ist die Häufung des Wortes \texttt{CT} (\texttt{eT}). Dies
  könnte \texttt{er} oder \texttt{es} sein.

  Ebenso fällt das Wort \texttt{LCT} auf. Möglich: \texttt{der} oder
  \texttt{des}. Da "`der"' häufiger in deutschen Texten vorkommt,
  verwenden wir \texttt{r} für \texttt{T} und \texttt{d} für \texttt{L}.

 \item Lücken schließen:
  \begin{itemize}
   \item \texttt{iUn} ist sehr wahrscheinlich \texttt{ihn}; \texttt{U}
    entspricht \texttt{h}.

   \item \texttt{eJ} ist nicht \texttt{er} oder \texttt{ei} (da
    \texttt{r} und \texttt{i} schon vergeben), also \texttt{es};
    \texttt{J} entspricht \texttt{s}

   \item \texttt{dAJJ} ist \texttt{dass}; \texttt{A} ist \texttt{a}

   \item \texttt{haFFe} ist \texttt{hatte}; \texttt{F} ist \texttt{t}

   \item Erster Teilsatz: "`\texttt{es hatte ein Wann einen eseN,}"'; Aus dem
    Kontext folgt: \texttt{W} entspricht \texttt{m} und \texttt{N} ist
    \texttt{l}.

   \item weiter: "`der sDhOn lauGe Sahre die saeDVe"'; \texttt{D}
    entspricht \texttt{c}, \texttt{O} ist \texttt{o}, \texttt{G} ist
    \texttt{g} und \texttt{S} ist \texttt{j} und \texttt{V} ist \texttt{k}.
  \end{itemize}
\end{enumerate}

\begin{figure}[t]
  \centering
  \begin{Verbatim}[gobble=2]
  es hatte ein mann einen esel, der schon lange jahre die saecke
  unverdrossen zur muehle getragen hatte, dessen kraefte aber nun zu
  ende gingen, so dass er zur arbeit immer untauglicher ward. da dachte
  der herr daran, ihn aus dem futter zu schaffen, aber der esel merkte,
  dass kein guter wind wehte, lief fort und machte sich auf den weg
  nach bremen: dort, meinte er, koennte er ja stadtmusikant werden.
  \end{Verbatim}
  \caption{Entschlüsselung des Textes aus \autoref{fig:2}}
  \label{fig:3}
\end{figure}

% 23. Okt. 2006

\section{Einteilung der Verschlüsselungsverfahren}

Man kann die Verschlüsselungsverfahren anhand verschiedener Merkmale
unterteilen. So unterscheidet man anhand der Schlüssel~$k_{e}$ und $k_{d}$
zwischen symmetrischer und asymmetrischer Verschlüsselung. Ein Kryptosystem,
bei dem für die Entschlüsselung der gleiche (oder ein in Polynomialzeit
konstruierbarer) Schlüssel wie für die Verschlüsselung verwendet wird,
bezeichnet man als \highl{symmetrisch}%
\index{Verschlüsselung!symmetrische}\index{Kryptosystem!symmetrisches}. Unterscheidet sich der Schlüssel für
die Entschlüsselung von dem für die Verschlüsselung, bezeichnet man das
Verfahren als \highl{asymmetrisch}%
\index{Verschlüsselung!asymmetrische}\index{Kryptosystem!asymmetrisches}.

Weiterhin unterscheidet man die Verfahren anhand der eingesetzten Schlüssel.
Bei einer \highl{Stromchiffre} wird aus einem Hauptschlüssel ein
Schlüsselstrom generiert, wobei je ein Element des Schlüsselstroms für die
Verschlüsselung eines Klartextblocks verwendet wird. Bei einer
\highl{Blockchiffre} ist der Schlüssel für alle Blöcke gleich. In der Regel
ist die Blocklänge bei Stromchiffren wesentlich kürzer (32 statt 256~Bit),
wodurch sie vorwiegend zur on-the-fly-Verschlüsselung, z.\,B. einer
Videokonferenz oder eines Telefonats, verwendet werden.

Ein drittes Unterscheidungsmerkmal ist die Art der Verschlüsselung. Die zwei
Grundverfahren sind die Substitution und die Transposition. Wird jede Einheit
durch einen bestimmten Wert (u.\,U. aus einem anderen Alphabet) ersetzt, ist
dies eine \highl{Substitution}. Bei einer \highl{Transposition} hingegen wird
der Geheimtext durch Vertauschung der Einheiten im Klartext erzeugt. Die
Transposition ist also eine Permutation der Einheiten des Klartexts, wobei
keine neuen Symbole hinzukommen, insbesondere bleibt die Häufigkeitsverteilung
der Einheiten gleich.

Heutige Verfahren verwenden eine Kombination aus beiden Grundverfahren.

\chapter{Substitionsverfahren}

\section{Monoalphabetische Substitutionen}

Bei einer \highl[Verschlüsselung!monoalphabetische]{monoalphabetischen Verschlüsselung} wird jeder Buchstabe des
Klartextalphabets~$\Sigma$ immer durch denselben Buchstaben des
Geheimtextalphabets~$\Gamma$ ersetzt. Sei o.\,B.\,d.\,A. $\Sigma =\Gamma
=\{a,b,c,\dotsc,x,y,z\}$ bzw. sei das Alphabet in der Form
$X=\{0,1,2,\dotsc, 23, 24, 25\}$ gegeben; es gilt: $\abs{X} = 26$. Für
Alphabete mit $n$ Zeichen, sei die Darstellung $X=\{0,1,2,\dotsc, n-2, n-1\}$.

Die Verschlüsselung ist also eine Permutation $\pi\colon X\rightarrow X$ des
Alphabets, die gleichzeitig der Schlüssel ist. Aus einer Nachricht
$m=m_{1}m_{2}\dotso m_{k}$ wird so der Geheimtext $c=\pi(m_{1})\pi(m_{2})
\dotso\pi(m_{k})$. Es gibt hier $n!$~verschiedene Schlüssel, aber wir wissen
bereits aus \autoref{sec:ka-bsp}, dass dieses Verfahren kryptographisch auf
Grund der Häufigkeitsverteilung der Buchstaben auch bei
\highl[Angriff!Ciphertext-Only-]{Ciphertext-Only-Angriffen} unsicher ist.

\subsection{Verschiebechiffre (Caesar-Chiffre)}

Die \highl{Verschiebechiffre} --~auch \highl{Caesar-Chiffre} genannt~-- ist
die einfachste Form der monoalphabetischen Substitution. Jeder Buchstabe wird
durch seinen $k$-ten~Nachfolger ersetzt, wobei man wieder bei A beginnt, wenn man
Z überschreitet.

Anschaulich kann man sich eine Verschlüsselungsvorschrift so vorstellen, dass
unter den Buchstaben~A bis~Z die Buchstaben beginnend mit dem $k$-ten~Buchstaben
bis~Z und weiter von A bis zum $(k-1)$-ten~Buchstaben stehen. Jeder Buchstabe des
Klartextes wird durch den Buchstaben, der unter ihm in der zweiten Zeile
steht, ersetzt.

Mathematisch ausgedruckt, kodiert man die Buchstaben~A bis~Z mit den Zahlen~0
bis~25 und ordnet jedem Buchstaben den durch die Abbildung $x\mapsto
x+k\pmod{26}$ beschriebenen Buchstaben zu.

Der Schlüssel für die Verschlüsselung ist dabei $k\in\{0,1,\dotsc,25\}$, die
Anzahl der Positionen, um die die Buchstaben verschoben werden.

Das Verfahren hat jedoch den Nachteil, das nur wenige ($n$) Schlüssel
verfügbar sind und das die Verschlüsselung gebrochen ist, sobald \textit{ein}
Buchstabe übersetzt ist. Dies lässt sich wie in \autoref{sec:ka-bsp} gesehen,
sehr leicht mit der Häufigkeitsanalyse der Buchstaben bewerkstelligen.

\subsection{Tauschchiffren}
\label{sec:tausch}

\highl[Tauschchiffre]{Tauschchiffren} sind eine Verallgemeinerung der Verschiebechiffren. Die
Buchstaben werden ebenfalls durch
Zahlen kodiert, mit denen dann gerechnet wird. Jedes Zeichen $x\in
\{0,\dotsc,n-1\}$ wird durch die \highl[Abbildung!affinlineare]{affinlineare} Abbildung
$x\mapsto a\cdot x+b\pmod{n}$ in das Geheimzeichen überführt. Der Schlüssel ist dabei das Paar
$(a,b)\in \{0,\dotsc,n-1\}^{2}$.
Bei den Verschiebechiffren ist $a=1$.

Damit die Entschlüsselung möglich ist, muss die Abbildung bijektiv sein. Dazu
müssen $a$ und $n$ teilerfremd sein. Es gibt also $\phi(n)$\footnote{Eulersche
$\phi$-Funktion; siehe \autoref{sec:restklassen}} Möglichkeiten $a$ zu wählen
und insgesamt $\phi(n)\cdot n$ Schlüssel $(a,b)$.

Ein kurzes Gegenbeispiel, um das Problem zu verdeutlichen: Wählt man $n=26,
a=13$ und $b=0$, so wird das Zeichen~2 als $E(2) = 13\cdot 2+0 \pmod{26} = 0$
als auch das Zeichen~0 als $E(0) = 0 \cdot 13 +0 \pmod{26}$ verschlüsselt.
Eine Entschlüsselung des Zeichens~0 ist also nicht möglich.

\begin{bsp}
  Der Klartext "`text"' wird mit dem Schlüssel~$(5,13)$ auf den Geheimtext
  "`EHYE"' abgebildet.
  \begin{center}
    \begin{tabular}{c|cc|c}
      Buchstabe& Codierung~$x$& $5\cdot x+13\bmod 26$& Decodierung\\
      \hline
      t& 19& 4& E\\
      e& 4& 7& H\\
      x& 23& 24& Y\\
      t& 19& 4& E
    \end{tabular}
  \end{center}
\end{bsp}

Die Nachteile der Tauschchiffren sind:
\begin{itemize}
 \item Häufigkeitsverteilung der natürlichen Sprache bleibt erhalten und
 \item Verschlüsselung ist geknackt, wenn \textit{zwei} Buchstaben übersetzt
  sind
\end{itemize}

Die Tauschchiffren werden in einer allgemeineren Form nochmal im
\autoref{sec:afflin} besprochen.

\section{Homophone Substitutionen}

\highl[Substitution!homophone]{Homophone Substitutionen} versuchen die strukturelle Schwäche der
monoalphabetischen Verschlüsselung, die durch die Häufigkeitsverteilung
der Buchstaben bei natürlichen Sprachen gegeben ist, aufzuheben.

Dazu führt man ein neues und \textit{größeres} Geheimtextalphabet $Y$
und eine Abbildung $f\colon X\mapsto \mathfrak{P}(Y)$ ein, wobei verschiedene
Buchstaben disjunkten Teilmengen entsprechen. Für eine Nachricht
$m=m_{1}m_{2}\dotso m_{k}$ ist der Geheimtext $c=c_{1}c_{2}\dotso c_{k}$,
wobei $c_{i}$ zufällig aus $f(m_{i})$ gewählt wird. (Italien um 1400).

\begin{bsp}
  Für das Klartextalphabet $X=\{a,b,c\}$, wobei die Buchstaben mit den
  Wahrscheinlichkeiten 0,5\,\%, 0,35\,\% und 0,15\,\% vorkommen, verwenden wir das
  Geheimtextalphabet $Y=\{0,1,\dotsc,7\}$. Dazu definieren wir die Abbildung $f$
  wie folgt
  \begin{gather*}
    f(x) =
       \begin{cases}
         \{0, 3, 4, 7\} &\colon x= a\\
         \{1, 5, 6\} &\colon x=b\\
         \{2\} &\colon x=c
       \end{cases}
  \end{gather*}

  Der Buchstabe $b$ wird also durch die drei Zeichen 1, 5 und 6 codiert. Das
  Wort cbba könnte z.\,B. als 2514 oder 2663 verschlüsselt werden.
\end{bsp}

Der Vorteil einer solchen homophonen Substitution besteht darin, dass die
Häufigkeitsverteilung der Klartextbuchstaben zerstört wird, wenn für alle
$x\in X$, wobei $p(x)$ die relative Häufigkeit ist, mit der der Buchstabe $x$
in Texten auftritt, $f(x)$ so gewählt wird, dass $\frac{p(x)}{\abs{f(x)}}$ für
alle $x$ annähernd gleich ist!

Der Effekt des Ganzen ist, dass im Geheimtext alle Buchstaben des
Geheimtextalphabets~$Y$ etwa gleichwahrscheinlich auftreten!

\begin{table}
  \centering
  \begin{tabular}{c|*{6}{c}}
     & $x_{1}$ & $x_{2}$ & \dots & $x_{i}$ & \dots & $x_{n}$\\
    \hline
    $x_{1}$ & $y_{\frac{n^{2}}{9}}$ & $y_{\frac{7n^{2}}{8}}$ &
       \dots & $y_{\frac{n^{2}}{4}}$ & \dots & $y_{\frac{n^{2}}{2}}$\\
    $x_{2}$ & $y_{n^{2}}$ & $\ddots$\\
    \vdots &\\
    $x_{j}$ &\\
    \vdots & & & & & $\ddots$ & \vdots\\
    $x_{n}$ & & & & & \dots & $y_{\frac{n^{2}}{12}}$
  \end{tabular}
  \caption{Zuordnung von $n$ Zeichen des Klartextalphabet auf $n^{2}$
    Zeichen des Geheimtextalphabet}
  \label{tab:1}
\end{table}

\begin{lemma}
  Es gibt ein homophones Verschlüsselungsverfahren, bei dem es für jeden
  Geheimtext~$c$ mindestens zwei verschiedene Schlüssel gibt, die
  $c$ in zwei verschiedene, sinnvolle Klartexte überführen.

  \begin{proof}
    Das Klartextalphabet sei $X$ (mit $\abs{X}=n$) und
    $Y$ (mit $\abs{Y}=n^{2}$) das Geheimtextalphabet. Der Schlüsselraum wird
    beschrieben durch eine $n\times n$-Matrix. Die Zeilen und Spalten werden mit
    den Buchstaben aus $X$ indiziert und die Eintragungen sind die (zufällig
    angeordneten) Buchstaben von $Y$. Siehe \autoref{tab:1}. Wir definieren zwei
    Abbildungen:
    \begin{align*}
      f_{1}(x_{j}) &= \Set{ y\in Y | y \text{~steht in der $j$. Zeile}}\\
      f_{2}(x_{i}) &= \Set{ y\in Y | y \text{~steht in der $i$. Spalte}}
    \end{align*}

    Es sei $m=m_{1}m_{2}\dotso m_{k}$ der zu verschlüsselnde Klartext und
    $l'=l_{1}'l_{2}'\dotso l_{k}'$ ein weiterer sinnvoller Klartext gleicher Länge.

    Als Verschlüsselung für $m_{i}$ verwenden wir den Eintrag in der Matrix, der
    im Schnittpunkt von $m_{i}=x_{r}$ und $l_{i}=x_{s}$ ($r$-ter Zeile und $s$-ter
    Spalte) liegt.
    \begin{gather*}
      m_{i}\mapsto c_{i}\in f_{1}(m_{i}) \cap f_{2}(l_{i})
    \end{gather*}
  \end{proof}
\end{lemma}

Ein \highl[Angriff!Brute-Force-]{Brute-force-Angriff} bleibt bei solch einer
Verschlüsselung prinzipiell wirkungslos, weil jeder Geheimtext in zwei
verschiedene, \textit{sinnvolle} Klartexte übersetzt werden kann!

Jedoch bleibt weiterhin der Nachteil bestehen, dass für alle Buchstaben $x\in
X$ die Anzahl der möglichen Verschlüsselungen
$\abs{f(x)}$ gleich groß ist. Damit ist die Forderung, dass $\frac{p(x)}%
{\abs{f(x)}}$ für alle $x$ annähernd gleich ist, verletzt. Aber die Idee ist,
dass der Angreifer nicht sagen kann, welcher der beiden konkurrierenden
Klartexte der richtige ist.

% 25. 10. 2006

\begin{bsp}
  \label{bsp:3}
  Das Klartextalphabet $X$ sei das deutsche Alphabet und wir wählen als
  Geheimtextalphabet $Y=\{00, 01, \dotsc, 10,11,\dotsc,99\}$. Dann ist
  $\abs{Y}=100$. Die Zuordnung $f\colon X\rightarrow
  \mathfrak{P}(Y)$ wählen wir so, dass gilt: Für alle Buchstaben $x\in X$ ist $\abs{f(x)}\approx
  p(x)\cdot 100$.

  In \autoref{tab:buchswsk} mit Häufigkeiten der Buchstaben sehen
  wir, dass z.\,B. \texttt{c} mit der Wahrscheinlichkeit 3,06\,\% auftritt.
  Also wählen wir zufällig für \texttt{c} drei Zeichen aus $Y$, z.\,B. $07, 23, 42$.
\end{bsp}

\subsection{Ansatz zur Kryptoanalyse einer homophonen Verschlüsselung}

Eine weitere Idee für einen Angriff ist andere Unregelmäßigkeiten --~neben der
Häufigkeitsverteilung der Buchstaben~-- in der deutschen Sprache zu finden.
Dazu betrachten wir sogenannte \highl[Digramm]{Digramme} oder
\highl[Bigramm]{Bigramme} (Zweierfolgen von Buchstaben)
in Texten. Dafür gibt es insgesamt $26^{2}$ mögliche Paarungen. Beispiele für
Digramme sind \textit{en} und \textit{er}, die mit einer Wahrscheinlichkeit
von ca.\,4\,\% in deutschen Texten auftreten. Das Digramm \textit{ch} tritt mit
einer Wahrscheinlichkeit von ca.\,2,75\,\% und die Digramme \textit{de},
\textit{te}, \textit{nd}, \textit{ei}, \textit{ie}, \textit{es}, \textit{in}
treten mit der Wahrscheinlichkeit von ca.\,2\,\% auf.

Damit haben wir bereits eine Anomalie gefunden. Während die Buchstaben
\textit{e} und \textit{n} häufig auftreten und auch das Digramm aus beiden
\textit{en} häufig auftritt, ist es im Fall von \textit{c}, \textit{h} und
\textit{ch} nicht so. Die einzelnen Buchstaben sind recht selten (siehe
\autoref{tab:buchswsk}), das Digramm jedoch tritt sehr häufig auf.

Ausgangspunkt: Verschlüsselung von \glq{}c\grq{}. Es sei $\abs{f(\mathtt{c})} =k$
(z.\,B. $k=3$ in \autoref{bsp:3}) Dann müssen (etwa) folgende Relationen erfüllt sein:
$\abs{f(\mathtt{e})}\approx 6k, \abs{f(\mathtt{n})} \approx 3k,
\abs{f(\mathrm{i})} \approx 2,5k, \abs{f(\mathrm{r})} \approx
2,5k$.

Das Bigramm "`en"' wird auf $6k\cdot 3k = 18k^{2}$ verschiedene Weisen
verschlüsselt und "`ch"' auf $k\cdot 1,5k = 1,5k^{2}$ verschiedene
Weisen.

Ein Digramm, dass "`en"' verschlüsselt, tritt mit einer Häufigkeit von
$\frac{4\,\%}{18}\approx 0,25\,\%$ auf. Für "`ch"' ist die Häufigkeit
$\frac{2,5\,\%}{1,5}\approx 1,6\,\%$.

Dies ist ein Ansatz zunächst durch eine \highl{Häufigkeitsanalyse} die Verschlüsselung für \textit{c} und
\textit{h} zu knacken. Voraussetzung für einen solchen Angriff ist aber
ein wirklich langer Geheimtext!

\section{Polyalphabetische Verschlüsselung}

Polyalphabetische Verschlüsselung hat ebenfalls das Ziel, die Häufigkeit
der Buchstaben zu verwischen. Ein prominentes Beispiel ist die
\highl{Vigenère-Chiffre} von dem französischen Diplomat \textsc{Blaise
  Vigenère} (1523--1596), die erst im 19.\,Jahrhundert gebrochen wurde.

\begin{table}
  \centering
  \begin{minipage}{13.5cm}
    \ttfamily\footnotesize\raggedright~~~%
    \setcounter{cnt}{1}%
    \whiledo{\thecnt < 27}{%
      \alph{cnt}~~%
      \stepcounter{cnt}%
    }\\
    \newcounter{cntline}\setcounter{cntline}{1}%
    \newcounter{cntcol}%
    \setcounter{cnt}{1}%
    \whiledo{\thecntline < 27}{%
      \ifthenelse{\thecnt > 26}{\addtocounter{cnt}{-26}}{}%
      \alph{cnt}~~%
      \setcounter{cntcol}{1}%
      \whiledo{\thecntcol < 27}{%
        \ifthenelse{\thecnt > 26}{\addtocounter{cnt}{-26}}{}%
        \Alph{cnt}~~%
        \stepcounter{cnt}%
        \stepcounter{cntcol}%
      }\\
      \stepcounter{cnt}%
      \stepcounter{cntline}%
    }
  \end{minipage}
  \caption{Das Vigenère-Quadrat.}
  \label{tab:vig}
\end{table}

Die Idee der Vigenère-Chiffre ist, dass jeder Buchstabe mit einer anderen
Caesar-Chiffre verschlüsselt wird, aber nicht zufällig, sondern strukturiert
mit Hilfe eines Schlüsselworts.

\begin{bsp}
  Der zu verschlüsselnde Klartext sei \texttt{emmentaler} und das Schlüsselwort
  "`ALLGAEU"'.
  \begin{center}
    \begin{tabular}{l*{14}{c}}
      Klartext:& e& m& m& e& n& t& a& l& e& r& &&& \\
      Schlüsselwort:& A& L& L& G& A& E& U& A& L& L& G& A& E& U\\
      Geheimtext:& E& X& X& K& N& X& U& L& P& C& &&&
    \end{tabular}
  \end{center}
\end{bsp}

Die Verschlüsselung ist nicht wesentlich aufwendiger als die Caesar-Chiffre,
aber es stellt sich eine neue Situation ein: "`e"' wird zu "`E"', "`K"' und
"`P"' und umgekehrt entsteht "`X"' aus "`m"' und "`t"'. Dadurch werden die
unterschiedlichen Häufigkeiten der Klartextbuchstaben im Geheimtext
ausgeglichen.

Die \highl[Verschlüsselung!polyalphabetische]{polyalphabetische Verschlüsselung} lässt sich allgemein auf
folgenden Weise beschreiben: Es gibt ein Klartextalphabet~$\Sigma$,
$d$~Geheimtextalphabete $\Gamma_{0}, \Gamma_{1}, \dotsc, \Gamma_{d-1}$, $d$~bijektive
Abbildungen $f_{i}\colon \Sigma \rightarrow \Gamma_{i}$ ($i=0,\dotsc,d-1$) und eine
surjektive Abbildung $h\colon\N\mapsto \{0,1,\dotsc,d-1\}$. Den Schlüssel
bilden dabei $h, f_{0}, f_{1}, \dotsc, f_{d-1}$.

Ein Klartext $m=m_{1}m_{2}\dotso m_{t}$ mit $m_{j}\in \Sigma$ der Länge~$t$ wird in
einen Geheimtext $c=c_{1}c_{2}\dotso c_{t}$ durch $c_{j} = f_{h(j)}(m_{j})$
für $1\leq j\leq t$ überführt.

Bei der \highl{Vigenère-Chiffre} sind die Alphabete identisch, also
$\Sigma=\Gamma_{0}=\dotsb= \Gamma_{d} =\{0,1,\dotsc,25\}$. Das Schlüsselwort
$k=k_{0}k_{1}\dotso k_{d}$ der Länge~$d$ beschreibt die einzelnen
Verschlüsselungsfunktionen durch eine Verschiebechiffre $f_{i}(a) = a+
k_{i}\bmod{n}$ (für $a\in X$). Als Funktion~$h$ wird einfach $h(x) = x\bmod{d}$
(für $x\in\N$) verwendet.

\begin{bsp}
  Das Alphabet sei $X=\{0,1,\dotsc,25\}$ und das Schlüsselwort sei "`KRYPTO"'
  ($d=6$), wobei dies als $10,17,24,15,19,14 = k_{0},k_{1}, k_{2}, k_{3},
  k_{4}, k_{5}$ dargestellt wird. Für den Klartext \texttt{kommemorgennicht}
  ergibt sich der Geheimtext \texttt{UFKBXAYIETGBSTFI}.
  \begin{center}
    \begin{tabular}{l*{6}{|c}}
      Schlüsselwort & K & R& Y& P& T& O\\
      Kodierung~$k_{j}$ & 10 & 17 & 24 & 15 & 19 & 14\\
      \hline
      Klartext & k & o & m & m & e & m\\
      Kodierung~$x$ & 10 & 14 & 12 & 12 & 04 & 12\\
      $x + k_{j}\bmod 26$ & 20 & 05 & 10 & 01 & 23 & 00\\
      Geheimtext & U & F & K & B & X & A\\
      \hline\hline
      Klartext & o & r & g & e & n & n\\
      Kodierung~$x$ & 14 & 17 & 06 & 04 & 13 & 13\\
      $x + k_{j}\bmod26$ & 24 & 08 & 04 & 19 & 06 & 01\\
      Geheimtext & Y & I & E & T & G & B\\
      \hline\hline
      Klartext & i & c & h & t &&\\
      Kodierung~$x$ & 08 & 02 & 07 & 19 &&\\
      $x + k_{j}\bmod26$ & 18 & 19 & 05 & 08 &&\\
      Geheimtext & S & T & F & I &&
    \end{tabular}
  \end{center}
\end{bsp}

% 2006-10-30

\subsection{Analyse der polyalphabetischen Verschlüsselung}

Der Angriffspunkt bei der polyalphabetischen Verschlüsselung ist die
Periodizität. Bei einer Periodenlänge~$d$ bezeichnet man als einen
Teiltext die Buchstabenfolge an den Positionen $k+nd$ für
$1\leq k \leq d$ und $n\in\N_{0}$. Wenn man den Text in Form einer Tabelle mit
der Breite der Schlüsselwortlänge aufschreibt, dann ist jede Spalte von oben
nach unten gelesen ein Teiltext.

Obwohl die Teiltexte keine sinnvollen Texte sind, stellt sich bei "`langen"'
Teiltexten die gleiche Häufigkeitsverteilung der Buchstaben wie bei einem
richtigen Text ein. Innerhalb der Spalten findet man also eine
Buchstabenhäufigkeit wie bei einem natürlichen Text.

Die einzelnen Teiltexte sind monoalphabetisch verschlüsselt. Man kann
also im ersten Schritt die Schlüssellänge bestimmen und im zweiten Schritt die
monoalphabetischen Teiltexte mit Hilfe der \highl{Häufigkeitsanalyse} entschlüsseln.

\subsubsection{Brute-force-Angriff auf polyalphabetische Verschlüsselung}
\index{Angriff!Brute-Force-}

Aus Erfahrung weiß man, dass die Häufigkeitsverteilung der Buchstaben im
Klartext nivelliert ist, wenn ein Geheimtext, der durch polyalphabetische
Verschlüsselung entstanden ist, mit einem Schlüssel der falschen Länge
entschlüsselt wird. Man kann also
systematisch $d=1,2,3,\dotsc$ durchprobieren bis man für den entschlüsselten
Text eine natürliche Verteilung der Buchstaben gefunden hat.

Dies funktioniert nur für kleine $d$!

\subsubsection{Kasiski-Test}\index{Kasiski-Test}

\textsc{Charles Babbage} entdeckte 1854 die Möglichkeit, die Länge des
Schlüsselworts für einen polyalphabetisch verschlüsselten Text zu
bestimmen. Der Algorithmus wurde aber nach \textsc{Kasiski} benannt, der ihn das erste Mal
veröffentlichte.

Wenn man die polyalphabetische Verschlüsselung betrachtet, fällt auf, dass
Buchstabenfolgen, die sich im Abstand eines Vielfachen der Periodenlänge
wiederholen, auf das gleiche Muster im Geheimtext abgebildet werden. Häufig
auftretenden Buchstabenkombinationen werden also an mehreren Stellen im Text
auf die gleiche Weise verschlüsselt.

Beispiele für solche Muster können die Artikel der, die, das, ein oder eine
sein, die häufig in einem Text vorkommen und somit auch wiederholt in der
gleichen Spalte bei der Verschlüsselung beginnen.

Findet man also in einem Geheimtext Muster, die länger als zwei Zeichen sind
und mehrfach auftreten, so können dies Buchstabenfolgen sein, die auf die
gleiche Weise verschlüsselt wurden. Die Länge des Schlüsselworts muss also ein
Teiler des Abstands der Wiederholungen des Musters sein.

Man kann mit mehreren Mustern und anhand ihrer Struktur (längere Muster sind
eher das Ergebnis eines Musters im Klartext als eine zufällige Wiederholung im
Geheimtext) eine (oder ein paar) Vermutungen über die Schlüssellänge finden.

\subsubsection{Friedman-Test}\index{Friedman-Test}

Von \textsc{William Friedman} (1891--1969) stammt die Idee, die Periodenlänge mit Hilfe
statistischer Methoden zu bestimmen. Die entscheidende statistische
Größe ist der Koinzidenzindex~$I(t)$ für einen Text~$t$.

Für ein Alphabet $A=\{a_{1},\dotsc, a_{n}\}$ mit $\abs{A}=n$ und einen
Text~$t$ der Länge~$l$ ist der \highl{Koinzidenzindex}~$I(t)$ die
Wahrscheinlichkeit dafür, dass an zwei zufällig gewählten Positionen in dem
Text der selbe Buchstabe steht.

Es sei $l_{i}$ die absolute Häufigkeit (Anzahl der Vorkommen) des
Buchstabens~$a_{i}$ im Text, d.\,h. $l=\sum_{i=1}^{n} l_{i}$. Für einen Text
der Länge~$l$ gibt es $\binom{l}{2}$ zufällig gewählte Zweiermengen von
Positionen. Die Anzahl der Mengen von zwei zufällig gewählten Positionen mit
gleichen Buchstaben beträgt
\begin{gather*}
  \sum_{i=1}^{n} \binom{l_{i}}{2} = \sum_{i=1}^{n} \frac{l_{i}(l_{i}-1)}{2}
\end{gather*}

Damit ergibt sich die Wahrscheinlichkeit, dass an zwei zufällig gewählten
Positionen zwei gleiche Buchstaben im Text~$t$ stehen:
\begin{align}
  I(t) &= \sum_{i=1}^{n} \frac{\binom{l_{i}}{2}}{\binom{l}{2}}
     = \sum_{i=1}^{n} \frac{l_{i}(l_{i}-1)}{l(l-1)}
     = \sum_{i=1}^{n} \frac{l_{i}^{2}}{l(l-1)}
     - \sum_{i=1}^{n} \frac{l_{i}}{l(l-1)} \notag\\
  &= \frac{l}{l-1} \sum_{i=1}^{n} \Bigl(\frac{l_{i}}{l}\Bigr)^{2} -
     \frac{1}{l-1} \label{eq:koinzi}
\end{align}

Für einen hinreichend großen Text, d.\,h. $l\rightarrow\infty$, in deutscher
Sprache~$t_{d}$ mit den Buchstabenhäufigkeiten aus \autoref{tab:buchswsk}
ergibt sich ein \highl{Koinzidenzindex}~$I_{d} \coloneq I(t_{d}) \approx 0,0762$.

Der Koinzidenzindex für einen hinreichend großen Zufallstext~$t_{z}$ der
Länge~$l$, bei dem alle Buchstaben gleich häufig auftreten $l_{1}=l_{2}=\dotsb=
l_{n}$, ist
\begin{gather*}
  I(t_{z}) = \frac{l}{l-1} \sum_{i=1}^{n} \Bigl(\frac{1}{n}\Bigr)^{2} - \frac{1}{l-1}
     = \frac{l}{l-1} \frac{1}{n} - \frac{1}{l-1}
     \xrightarrow{l\rightarrow\infty} \frac{1}{n}
\end{gather*}
Legt man ein Alphabet mit 26~Buchstaben zugrunde, ergibt sich so ein
\highl{Koinzidenzindex}~$I_{z} \coloneq \frac{1}{26} \approx 0,0385$.

\begin{bemerk}
  Der entscheidende Fakt für den Friedman-Test, der einen Angriff auf die
  Verschlüsselung ermöglicht, ist, dass die Wahrscheinlichkeit an zwei
  zufällig gewählten Positionen denselben Buchstaben zu finden, in deutschen
  Texten (und Texten anderer natürlicher Sprachen) etwa doppelt so groß wie in
  Zufallstexten ist.
\end{bemerk}

In einem Geheimtext~$c$ der Länge~$l$, der das Ergebnis einer
polyalphabetischen Verschlüsselung mit Periode~$d$ ist, sind die Buchstaben in
einem Teiltext ($k, d+k, 2d+k,\dotsc$) entsprechend der Buchstabenhäufigkeit
der Sprache verteilt. Zwischen den Teiltexten (d.\,h. von einer Spalte zu einer
anderen) sind die Buchstaben jedoch zufällig verteilt. (Eigenschaft der
polyalphabetischen Verschlüsselung.)

% Wählt man zufällig zwei Positionen in einem Teiltext, so trifft man mit einer
% Wahrscheinlichkeit von $I_{d}$ auf zwei gleiche Buchstaben. Wählt man zufällig
% zwei Positionen aus dem gesamten Geheimtext, so ist die Wahrscheinlichkeit für
% zwei gleiche Buchstaben $I_{z}$.

Die Teiltexte haben die Länge~$\frac{l}{d}$. Also gibt es
\begin{gather*}
  d\cdot \binom{\frac{l}{d}}{2} = \frac{l(l-d)}{2d}
\end{gather*}
zufällige Paare in ein und demselben Teiltext über alle Teiltexte. Für die
zufälligen Paare in unterschiedlichen Teiltexten bleiben
\begin{gather*}
  \frac{1}{2} \cdot l\cdot (l-\frac{l}{d}) = \frac{l^{2}(d-1)}{2d}
\end{gather*}
Möglichkeiten. ($l$~Möglichkeiten für die erste Position; $l-\frac{l}{d}$
Möglichkeiten für die zweite Position in den anderen Spalten; $\frac{1}{2}$
da es kein geordnetes Ziehen ist)

% 2006-11-01

Damit ist die Wahrscheinlichkeit im gesamten Geheimtext~$c$ an zwei zufällig
gewählten Positionen die gleichen Buchstaben zu finden
\begin{gather}
  \label{eq:koinzi_poly}
  I(c) =
     \frac{\frac{l(l-d)}{2d}\cdot I_{z} + \frac{l^{2}(d-1)}{2d}\cdot I_{d}}%
          { \frac{l(l-1)}{2} }
\end{gather}

Da man den Koinzidenzindex~$I(c)$ für den verschlüsselten Text mit der
\autoref{eq:koinzi} bestimmen kann, kann man so einen Schätzwert für die
Periodenlänge~$d$ der Verschlüsselung aus \autoref{eq:koinzi_poly} ableiten.
\begin{gather}
  \label{eq:fried-d}
  d = \frac{l(I_{d}-I_{z})}{I_{d} - lI_{z} +(l-1)I(c)}
\end{gather}

Diese Schätzung kann man mit den Ergebnissen aus einem Kasiski-Test oder einem
Brute-Force-Angriff vergleichen, um die Möglichkeiten für die wahre
Periodenlänge genauer einzuschränken.

\subsection{Möglichkeiten der Verteidigung gegen die Angriffe}

Ausgangspunkt für eine Verteidigung ist der Umstand, dass die oben formulierten
Tests nur für kleine Periodenlängen ($d\ll l$) funktionieren!
\begin{itemize}
 \item Eine Abwehrstrategie wäre also die Periodenlänge zu vergrößern.
  Praktisch wurde dies bei der \highl{Enigma} umgesetzt. Im deutschen Patent
  wurde 1920 mit drei Rotoren gearbeitet, die eine Periodenlänge von $26^{3}$
  ergaben. Im späteren Einsatz im Krieg wurde eine Maschine mit fünf Rotoren,
  die eine Periodenlänge von $26^{5}$ hatte, gearbeitet.

 \item Ein anderer Weg wäre, gar keine Wiederholung zu verwenden, sprich das
  Schlüsselwort so lang wie den Text wählen. Dies kann eine Textstelle aus
  einem vorher gewählten Buch sein -- Schlüssel ist dann (Seite, Zeile,
  Buchstabe). Aber dann funktioniert wieder die Häufigkeitsanalyse, weil der
  Roman die Charakteristik einer natürlichen Sprache hat. (In diese Kategorie
  fällt auch das anhängen des Klartextes an das Schlüsselwort.)

  Also müsste man für den "`Schlüsselroman"' einen Zufallstext wählen, was zu
  dem absolut sicherem, aber unpraktikablen \highl{One-Time-Pad} führt.
\end{itemize}

\chapter{Transpositionsverfahren}

Bei einer \highl{Transpositionschiffre} werden die Buchstaben des Klartexts auf
gezielte Art und Weise untereinander vertauscht, so dass der Text
verschlüsselt wird. Das Klartextalphabet ist also gleich dem
Geheimtextalphabet ($\Sigma=\Gamma$) und insbesondere bleibt die
Häufigkeitsverteilung der Buchstaben gleich, so dass ein Angriff über eine
\highl{Häufigkeitsanalyse} wirkungslos bleibt.

Es gibt zwei verschiedene Ansätze der Verschlüsselung:
\begin{itemize}
 \item Bei der \highl{Blocktransposition} wird der Klartext~$m$ in Blöcke
  einer festen Länge~$k$ eingeteilt und jeder Block~$m_{i}$ wird derselben
  Permutation~$\pi$ unterworfen, wodurch sich der Geheimtextblock~$c_{i}$
  ergibt.
  \begin{gather*}
    c_{i_{\pi(1)}}c_{i_{\pi(2)}}\dotso c_{i_{\pi(k-1)}}c_{i_{\pi(k)}} =
       m_{i_{1}} m_{i_{2}}\dotso m_{i_{k-1}}m_{i_{k}}
  \end{gather*}

  Als Angriff auf einen durch Blocktransposition verschlüsselten Text erweist
  sich der folgende, etwas plumpe Ansatz als sehr gut: Rate die Blocklänge
  (ein Teiler der Geheimtextlänge) und errate innerhalb von Blöcken eine
  Permutation, so dass sich bekannte Anagramme ergeben.

 \item Die \highl{Spaltentransposition} ist eine erweiterte
  Blocktransposition. Der Klartext wird wieder in Blöcke einer festen
  Länge~$k$ zerlegt und diese werden jeder für sich einer Permutation~$\pi$
  unterworfen. Danach wird der Geheimtext gebildet, indem man erst alle ersten
  Buchstaben aller Blöcke, dann die zweiten usw. aufschreibt.

  Anschaulich kann man sich den Ablauf so vorstellen, dass der Text
  zeilenweise in eine Tabelle fester Breite eingetragen. Dann werden die
  kompletten Spalten vertauscht und der Text wird anschließend spaltenweise
  ausgelesen.

  Verwendet man als Permutation der Spalten die Identität, so erhält man die
  \highl{Gartenzaunchiffre}: Die Zeichen werden zeilenweise eingetragen und
  spaltenweise wieder ausgelesen.

  Als Angriffsmöglichkeit ist wieder das Erraten der Blocklänge und
  anschließendes Suchen nach Anagrammen in jedem Block eine gute Variante.
\end{itemize}

\begin{figure}[ht]
  \centering
  \begin{tabular}{*{6}{>{\ttfamily}c}}
    \multicolumn{1}{c}{1.} & \multicolumn{1}{c}{2.} & \multicolumn{1}{c}{3.}
       & \multicolumn{1}{c}{4.} & \multicolumn{1}{c}{5.} &
       \multicolumn{1}{c}{6.}\\\\
    k&r&y&p&t&o\\
    l&o&g&i&e&u\\
    n&d&d&a&t&e\\
    n&s&i&c&h&e\\
    r&h&e&i&t&a
  \end{tabular}
  \quad $\rightarrow$ \quad
  \begin{tabular}{*{6}{>{\ttfamily}c}}
    \multicolumn{1}{c}{1.} & \multicolumn{1}{c}{2.} & \multicolumn{1}{c}{3.}
       & \multicolumn{1}{c}{4.} & \multicolumn{1}{c}{5.} &
       \multicolumn{1}{c}{6.}\\
    \multicolumn{1}{c}{$\pi(2)$} & \multicolumn{1}{c}{$\pi(4)$} &
       \multicolumn{1}{c}{$\pi(5)$} & \multicolumn{1}{c}{$\pi(6)$} &
       \multicolumn{1}{c}{$\pi(1)$} & \multicolumn{1}{c}{$\pi(3)$}\\
    r&p&t&o&k&y\\
    o&i&e&u&l&g\\
    d&a&t&e&n&d\\
    s&c&h&e&n&i\\
    h&i&t&a&r&e
  \end{tabular}
  % \begin{gather*}
  %   \renewcommand*{\coladdtolabel}[1]{}
  %   \begin{gmatrix}
  %     k&r&y&p&t&o\\
  %     l&o&g&i&e&u\\
  %     n&d&d&a&t&e\\
  %     n&s&i&c&h&e\\
  %     r&h&e&i&t&a
  %     \colops
  %     \add{1}{0}
  %     \add{5}{3}
  %     \add{4}{2}
  %     \add{3}{1}
  %     \add{0}{4}
  %     \add{2}{5}
  %   \end{gmatrix}
  % \end{gather*}
  \caption{Veranschaulichung der Spaltentransposition}
  \label{fig:sp-trans}
\end{figure}

\begin{bsp}
  Der Klartext lautet \texttt{kryptologie\,und\,datensicherheit}. Die
  Blockgröße~$k$ soll 6 sein und die Permutation $\pi = (1, 5, 3, 6, 4, 2)$.
  Wenn man den Text jetzt in ein Gitter einträgt, bleibt die letzte Zelle
  links unten leer. Diese füllt man einfach mit einem vorher vereinbarten
  Zeichen, bei uns \texttt{a}. siehe \autoref{fig:sp-trans}. Wenn man dann den
  Text spaltenweise von oben nach unten ausliest, ergibt sich der Geheimtext
  \texttt{rodsh\,piaci\,tetht\,oueea\,klnnr\,ygdie}.
\end{bsp}

\begin{bsp}
\begin{verbatim*}
IAEE KCWE NUCE TOEE KRAM DEZN EDNZ AIFA TRWN IRRS UBSN WKRE ELNT EURE
RKNS IKZI MIKF VNUH ANENK
\end{verbatim*}
Die Länge des Textes sind 77~Zeichen. Damit ergeben sich als mögliche
Spaltenlängen $7$ oder $11$.
\begin{verbatim*}
IEZRWEK
ATNWKRF
EOENRKV
EEDIENN
KENRESU
CKZRLIH
WRASNKA
EAIUTZN
NMFBEIE
UDASUMN
CETNRIK
\end{verbatim*}
\begin{verbatim*}
IEEEANSLRIU
ANEZIINNKMH
EUKNFRWTNIA
ECREARKESKN
KEADTSRUIFE
CTMNRUERKVN
WODZWBEEZNK
\end{verbatim*}
  Die erste Zeile für $k=11$ enthält zu viele Konsonanten und die letzte Zeile
  zu viele Vokale für einen deutschen Text.

  Idee: 1. und letzte Spalte liegen nebeneinander, da auf ein \textit{c} sehr
  oft ein \textit{k} oder ein \textit{h} folgt.

  Die sechste Spalte kommt vor die erste und dann können wir das Wort in der
  ersten Zeile erraten "`zwei"': 3., 5., 1., 6., 2., 4. Insbesondere
  die zweite Zeile ist aufschlussreich. Als Wort springt hier
  "`Kraft"' ins Auge. Wenn die Spalte entsprechend angeordnet werden,
  ergibt sich schnell der Klartext: "`zwei kernkraftwerke von denen
  eines kuerzlich krank war sitzen auf einem baum und stricken"'
\end{bsp}

% 13.11.06

\chapter{Blockchiffren}
\section{Allgemeines}

Wir bleiben zunächst noch bei den symmetrischen Verschlüsselungsverfahren und
versuchen durch eine Vergrößerung des Schlüsselraums die Verfahren sicherer zu
machen. Im Folgenden beschränken wir uns auf (rechnerfreundliche) Bitfolgen,
d.\,h. wir arbeiten mit Teilmengen von $\Z_{2}^{*}$.

\begin{defini}[Blockchiffre]
  Bei einer \highl{Blockchiffre} wird der Klartext in Blöcke einer frei
  wählbaren, aber festen Länge~$n$ (z.\,B. 32, 64 oder 128~Bit) zerlegt. Diese
  wird als \highl{Blocklänge} bezeichnet. Eine Verschlüsselungsfunktion~$f
  \colon\mathcal{M}\times\mathcal{K}\rightarrow\mathcal{C}$ erzeugt unter
  Verwendung eines Schlüssels~$k\in\mathcal{K}$ Geheimtextblöcke~$c=f(m,k)$ der
  \textit{gleichen} Länge.
\end{defini}

Damit eine Entschlüsselung des Textes möglich ist, muss die Verschlüsselung
bijektiv sein und da sie von $\Z_{2}^{n}$ auf $\Z_{2}^{n}$ abbildet, ist sie
eine Permutation der $2^{n}$ möglichen Blöcke. Es gibt also $2^{n}!$
mögliche Funktionen zur Verschlüsselung.

Ein kleines Gedankenspiel: Für die Blocklänge~$n=64$ gibt es $2^{64}!$
mögliche Verschlüsselungen und damit genau soviele Schlüssel. Um einen solchen
Schlüssel abspeichern zu können, benötigt man $l=\log_{2}(2^{64}!)$~Bit.
Mit Hilfe der Stirling-Formel kann man die Größe eines solchen Schlüssels
abschätzen:
\begin{align*}
  2^{n}! &\approx \sqrt{2\pi\cdot 2^{n}} \cdot
     \Bigl(\frac{2^{n}}{e}\Bigr)^{2^{n}}\\
  l &\approx \log_{2} \big(\sqrt{2\pi} \cdot 2^{32} \cdot
     \Big(\frac{2^{64}}{e}\Big)^{2^{64}} \big)
     \leq 64 \cdot 2^{64} = 2^{6+64}
\end{align*}
Es würden also zum Abspeichern \textit{eines} Schlüssels für eine Nachricht
$\frac{1}{8}\cdot 2^{20}\approx 10^{5}$~Pebibyte benötigt. In der Praxis kann
man also nur mit "`kleinen"' Teilmengen des Schlüsselraums arbeiten.

Für affinlineare Chiffren werden beispielsweise $\{0,1\}$-Matrizen vom Typ
$64\times 64$ verwendet, deren Determinante~1 ist. Die Darstellung des
Schlüssels ist also mit weniger als $64\cdot64 = 2^{12}$~Bit (im
Vergleich zu $2^{70}$~Bit) möglich.

Die Hintereinanderschaltung von \textit{verschiedenen} Blockchiffren führt zu
einer Erhöhung der Sicherheit. Oft realisiert man eine abwechselnde Folge von
Substitutionen und Transpositionen mit dem Ziel die folgenden beiden
\highl[Verschlüsselung!Eigenschaften der]{Eigenschaften der Verschlüsselung}, die auf \textsc{Claude Shannon}, den
Begründer der Informationstheorie, zurückgehen, zu erreichen:
\help{Können diese Eigenschaften nicht schon eher kommen? Im 1.\,Kapitel}
\begin{itemize}
 \item \highl{Diffusion}: Eine Änderung eines Klartextbits bewirkt die
  Änderung von vielen Bits des Geheimtexts.
 \item \highl{Konfusion}: Jedes Bit des Chiffretextes hängt von mehr als einem
  Bit des Schlüssels ab.
\end{itemize}

% Einschub, kam nie in der Vorlesung dran

\section{Blockverknüpfungsmodi}

Bei der Verschlüsselung können gleiche Blöcke gleich verschlüsselt werden
--~in Analogie zur monoalphabetischen Verschlüsselung~-- oder sie werden in
Abhängigkeit von ihrer Position im Klartext auf verschiedene Weise
verschlüsselt --~in Analogie zur polyalphabetischen Verschlüsselung.

\begin{figure}
  \begin{minipage}[t]{.45\linewidth}
    \input{ecb.pdf_t}
    \caption{Electronic Code Book}
    \label{fig:ecb}
  \end{minipage}%
  \begin{minipage}[t]{.55\linewidth}
    \input{cbc.pdf_t}
    \caption{Cipher Block Chaining}
    \label{fig:cbc}
  \end{minipage}%
\end{figure}

Die erste Variante bezeichnet man als \highl{Electronic Code Book Mode} (\highl{ECB}).
Jeder Block wird unabhängig von seiner Position mit Hilfe des Schlüssels durch
die Funktion~$f$ in einen Geheimtextblock überführt. (siehe~\autoref{fig:ecb})
\begin{align*}
  c_{i} &= E_{K}(m_{i})& m_{i} &= D_{K}(c_{i})
\end{align*}

Dies hat den Vorteil, dass die Verschlüsselung aller Blöcke parallel ablaufen
kann. Jedoch bleiben die Anomalien des Klartextes (häufigeres Auftreten
bestimmter Blöcke) erhalten. Da sich Änderungen an einem Klartext- oder
Chiffretextblock nur auf genau einen Klartext bzw. Chiffretextblock auswirken,
könnte ein Angreifer gezielt Daten verändern, ohne dass es bemerkt wird.
Jedoch bietet dieser Umstand auch die Möglichkeit einzelne Blöcke gezielt zu
entschlüsseln oder zu verändern, ohne die ganze Nachricht entschlüsseln zu
müssen. Für eine Dateiverschlüsselung z.\,B. könnte gezielt der neue
Klartextblock verschlüsselt und in dem Geheimtext ersetzt werden.

Beim \highl{Cipher Block Chaining Mode} (\highl{CBC}) wird der Klartextblock vor der
Verschlüsselung mit dem Ergebnis der Verschlüsselung des vorherigen Blocks
verknüpft, um für gleiche Klartextblöcke unterschiedliche Geheimtextblöcke zu
erzeugen. Dies bringt jedoch die Nachteile mit sich, dass die Verschlüsselung
der Blöcke nicht mehr parallel ablaufen kann und dass bei einer Änderung eines
Klartextblocks alle folgenden Geheimtextblöcke neu berechnet werden müssen.
(siehe~\autoref{fig:cbc})
\begin{align*}
  c_{i} &= E_{K}(m_{i}\oplus c_{i-1}) & m_{i} &= D_{K}(c_{i}) \oplus c_{i-1}
\end{align*}

Eine Veränderung des $r$"=ten Geheimtextblocks ändert nur den $r$"=ten
Block und den
folgenden Klartextblock:
\begin{align*}
  D_{K}(\tilde{c_{r}}) \oplus c_{r-1} &\ne m_{r}\\
  D_{K}(c_{r+1}) \oplus \tilde{c_{r}} &\ne m_{r+1}\\
  D_{K}(c_{r+2}) \oplus c_{r+1} &= m_{r+2}
\end{align*}

\begin{figure}
  \centering
  \input{cfb.pdf_t}
  \caption{Cipher Feedback}
  \label{fig:cfb}
\end{figure}

\highl{Cipher Feedback Mode} (\highl{CFB}) ist ähnlich zu CBC. Der vorherige
Geheimtextblock wird verschlüsselt und dieses Ergebnis mit dem Klartextblock
verknüpft, um Anomalien im Klartext auszugleichen. (siehe~\autoref{fig:cfb})
\begin{align*}
  c_{i} &= E_{K}(c_{i-1}) \oplus m_{i} & m_{i} &= E_{K}(c_{i-1}) \oplus c_{i}
\end{align*}

Die Verschlüsselungsfunktion~$f$ muss nicht umkehrbar sein, da man zur
Entschlüsselung ebenfalls die Verschlüsselungsfunktion verwendet.

\begin{figure}
  \centering
  \input{ofb.pdf_t}
  \caption{Output Feedback}
  \label{fig:ofb}
\end{figure}

Für den \highl{Output Feedback Mode} (\highl{OFB}) wird aus einem Initialwert eine
Folge von verschlüsselten Blöcken generiert, die mit den Klartextblöcken
verknüpft, die Geheimtextblöcke ergeben. (siehe~\autoref{fig:ofb})
\begin{align*}
  c_{i} &= m_{i} \oplus s_{i} & m_{i} &= c_{i}\oplus s_{i} & s_{i} &=
     E_{K}(s_{i-1})
\end{align*}

Dies bringt zwei Vorteile mit sich: Zum Einen kann eine solche Folge schon
vorab generiert werden, wodurch die eigentliche Verschlüsselung, bei Vorliegen
des Klartextes, sehr schnell geht. (Vorteilhaft z.\,B. bei Streaming) Zum
Anderen kann ein Klartextblock direkt ausgetauscht werden, ohne dass man die
folgenden Blöcke oder die verschlüsselte Folge neu berechnen muss:
$\tilde{c_{i}} = c_{i} \oplus m_{i} \oplus \tilde{m_{i}}$.

\begin{table}
  \centering
  \begin{tabular}{l|cccc}
    mode& Schreibzugriff & Manipulation zerstört \dots& Anomalien im Text\\
    \hline
    ECB& wahlfrei& diesen Block& unverändert\\
    CBC& linear& aktuellen u. nächsten Block& verwischt\\
    CFB& linear& aktuellen u. nächsten Block& verwischt\\
    OFB& wahlfrei& diesen Block& verwischt
  \end{tabular}
  \caption{Übersicht der Eigenschaften von ECB, CBC, CFB und OFB}
\end{table}

% 6.11.06

\section{Crashkurs über Restklassenringe und Matrizen darüber}
\label{sec:restklassen}

Zwei Zahlen~$a,b\in\Z$ sind zueinander \highl[Kongruenz]{kongruent modulo~$k$}, wenn sie
bei der Division durch $k$ den gleichen Rest ($0\leq r<k$) lassen:
\begin{gather*}
 \exists r\in\Z\colon a= b+ r\cdot k
\end{gather*}
Wir schreiben dafür $a\equiv_{k} b$ oder $a\equiv b\pmod{k}$.

Das zerlegt die ganzen Zahlen in genau $k$~\highl[Restklasse]{Restklassen} $[a]_{k}$. Die
Menge dieser Restklassen bezeichnet mal als \highl{Faktormenge}~$\Z_{k}$.
\begin{align*}
  [a]_{k} &= \Set{a+lk | l\in\Z} = a+k\cdot\Z
     &&\text{für~} a\in\{0,\dotsc,k-1\} \\
  \Z_{k} &\coloneq \nicefrac{\Z}{\equiv_{k}}
     = \{ [0]_{k}, [1]_{k}, \dotsc, [k-1]_{k} \}
\end{align*}
Als Kurzschreibweise verwendet man $\Z_{k} = \{0,1,2,\dotsc,k-1\}$.

Auf dieses Restklassensystem kann man die Addition und Multiplikation auf
folgende Weise übertragen:
\begin{align*}
  [a]_{k} + [b]_{k} &\coloneq [a+b]_{k} &&\text{Nullelement:~}[0]_{k}\\
  [a]_{k} \cdot [b]_{k} &\coloneq [a\cdot b]_{k} &&\text{Einselement:~}[1]_{k}\\
\end{align*}

Für jedes $[a]_{k}$ existiert ein \highl[Element!inverses]{inverses Element bzgl. Addition}
$-[a]_{k} \coloneq [-a]_{k} = [k-a]_{k}$. Ein Element $[a]_{k}$ heißt genau dann
\highl{Einheit} des Restklassensystems, wenn ein $[b]_{k}$ existiert, so dass
$[a]_{k} \cdot [b]_{k} = [1]_{k}$. In diesem Fall heißt $[b]_{k}$
\highl[Element!inverses]{inverses Element bzgl. Multiplikation} zu $[a]_{k}$.

\begin{lemma}
  \label{lem:5}
  Die Eulersche $\phi$-Funktion $\phi(k)$ ist die Anzahl der der
  positiven ganzen Zahlen $a\leq k$ an, die zu dieser teilerfremd
  sind:
  \begin{gather*}
    \phi(k) \coloneq\abs{\Set{1\leq a\leq k | \ggT (a,k)=1}}
  \end{gather*}
  In $\Z_{k}$ gibt es genau $\phi(k)$ Einheiten.

  \begin{proof}
\emph{Im Beweis stimmt ebenfalls etwas nicht. Sei $k=7$. Dann wäre
  $[2]_{7}$ eine Einheit, denn $2\cdot4=1+7\Z$. Aber
  $\ggT(2,4)\neq1$. Andererseits ist $\ggT(2,3)=1$, aber $2\cdot3=6+7\Z$.}
    $[a]_{k}$ ist eine Einheit in $Z_{k}$ \gdw ein $[b]_{k}$
    mit $[a]_{k}\cdot [b]_{k} = [a\cdot b]_{k} = [1]_{k} = 1+k\Z$ existiert,
    d.\,h. es gibt ein $b$ und ein $l$, so dass $ab= 1+kl$, also $ab-kl=1$. Dies
    gilt \gdw $\ggT(a,b)=1$.
    % \help{Wieso gilt $ab-kl=1\Leftrightarrow \ggT(a,b)=1$? Ist $\ggT(a,b)$ ein
    %   Schreibfehler und soll $\ggT(a,k)$ sein? Dann käme die Beziehung aus dem
    %   erweiterten euklidischen Algorithmus, der aber an dieser Stelle noch
    %   nicht bekannt ist.}
  \end{proof}
\end{lemma}

Für das Produkt zweier Zahlen~$p$ und $q$, die zueinander teilerfremd sind,
ist $\phi(p\cdot q)=\phi(p)\cdot\phi(q)$, d.\,h. $\phi$ ist multiplikativ.
Falls $p$ eine Primzahl ist, dann ist $\phi(p)=p-1$. Es gibt also
$\phi(p)=p-1$ Einheiten in $\Z_{p}$, womit $\Z_{p}$ ein Körper ist.

Die algebraische Struktur $\Z_{k} = [\Z_{k},+,\cdot]$ mit dem
Nullelement~$[0]_{k}$ und dem Einselement~$[1]_{k}$ bezeichnet mal als
\highl[Ring!kommutativer]{kommutativen Ring}.

In der Kryptologie wird häufig mit dem Restklassenring modulo~$26$ gearbeitet:
$\Z_{26} = \{0,1,\dotsc,25\}$. Im Grunde sind alle endlichen Alphabete
kommutative Ringe, was den Vorteil hat, dass man mit Buchstaben rechnen kann.
Dies haben wir bereits bei der Caesar-Chiffre ausgenutzt.

Der Ring $\Z_{26}$ hat genau 12~Einheiten, da $\phi(\abs{\Z_{26}}) =
\phi(2\cdot13) = \phi(2)\cdot\phi(13) = 1\cdot12$. Diese sind:
$1,3,5,7,9,11,15,17,19,21,23,25$.

Wir betrachten $n\times n$-Matrizen, deren Einträge Elemente
aus einem beliebigen kommutativen Ring~$[R,+\cdot]$ sind.
\begin{gather*}
  R^{n\times n} \coloneq \Set{ \begin{pmatrix}
                       r_{11} & r_{12} & \dotso & r_{1n}\\
                       r_{21} & r_{22} & \dotso & r_{2n}\\
                       \vdots & \vdots & & \vdots\\
                       r_{n1} & r_{n2} & \dotso & r_{nn}
                     \end{pmatrix}
                    | r_{ij}\in R, 1\leq i,j \leq n}
\end{gather*}
Die Matrizenaddition und -multiplikation ist dabei wie üblich.

In der Kryptologie betrachten wir speziell die Matrizen $\Z_{k}^{n\times n}$.

Als \highl[Zeilenvektor]{Zeilen-} (\autoref{eq:zeilenvek}) bzw.
\highl[Spaltenvektor]{Spaltenvektoren} (\autoref{eq:spaltenvek}) bezeichnet
man Matrizen der folgenden Form:
\begin{align}
  R^{1\times n} &= \Set{ \begin{pmatrix}b_{1} & b_{2} & \dotso & b_{n}\end{pmatrix}
                    | b_{i}\in R, 1\leq i \leq n}\label{eq:zeilenvek}\\
  R^{n\times1} &= \Set{ \begin{pmatrix}b_{1} & b_{2}&\dotso&b_{n}\end{pmatrix}^{T}
                    | b_{i}\in R, 1\leq i \leq n}\label{eq:spaltenvek}
\end{align}

Als eine \highl{Permutation}~$\sigma$ bezeichnet man eine Umordnung der
Elemente eine Menge. Mit $S_{n}$ bezeichnet man die Menge der Permutationen
einer Menge mit $n$~Elementen
(\highl[Gruppe!symmetrische]{symmetrische Gruppe}).
\begin{gather*}
  S_{n} = \Set{ \sigma | \sigma\colon \{1,\dotsc,n\} \rightarrow
     \{1,\dotsc,n\}}
\end{gather*}

Für eine Permutation~$\sigma\in S_{n}$ bezeichnet man ein Paar
$(i,j)\in\{1,\dotsc,n\}^{2}$ als \highl{Fehlstand},
wenn $i<j$ und $\sigma(i)>\sigma(j)$ gilt.

Die \highl{Determinante} einer quadratischen Matrix~$A\in R^{n\times
  n}$ mit $A=(a_{ij})_{n\times n}$ und $a_{ij}\in R$ kann man auf zwei
Weisen berechnen.

Die Formel von \textsc{Leibniz} für die Determinante einer Matrix lautet:
\begin{gather*}
  \det A \coloneq \sum_{\sigma\in S_{n}} \sgn(\sigma) \cdot
     \prod_{i=1}^{n} a_{i\sigma(i)}\\
  \sgn(\sigma) = \begin{cases}
                   +1 &:\text{die Anzahl der Fehlstände ist gerade}\\
                   -1 &:\text{die Anzahl der Fehlstände ist ungerade}
                 \end{cases}
\end{gather*}

\begin{bsp}
  Die Determinante einer $1\times1$-Matrix~$A=(a_{11})$ ist $\det A = a_{11}$,
  da die einzig mögliche Permutation~$\sigma=
  (\begin{smallmatrix}1\\1\end{smallmatrix})$ das Vorzeichen~$+1$ hat.
  \begin{gather*}
    \det A = \sum_{\sigma\in S_{1}} \sgn(\sigma) \cdot \prod_{i=1}^{1}
       a_{i\sigma(i)} = \sum_{\sigma\in S_{1}} \sgn(\sigma) a_{11}
  \end{gather*}

  Für eine $2\times2$-Matrix~$A$ gibt es zwei Permutationen~$\sigma_{1},
  \sigma_{2}\in S_{2}$:
  \begin{gather*}
    \sigma_{1}=\begin{pmatrix}1&2\\1&2\end{pmatrix},\; \sgn(\sigma_{1})=+1
       \qquad
       \sigma_{2}=\begin{pmatrix}1&2\\2&1\end{pmatrix},\; \sgn(\sigma_{2})=-1
  \end{gather*}
  Entsprechend ergibt sich die Determinante als
  \begin{align*}
    \det A &= \sum_{\sigma\in S_{2}} \sgn(\sigma) \cdot
       \prod_{i=1}^{2} a_{i\sigma(i)}
       = \sum_{\sigma\in \{\sigma_{1},\sigma_{2}\}} \sgn(\sigma) \cdot
       a_{1\sigma(1)}\cdot a_{2\sigma(2)}\\
    &= \sgn(\sigma_{1}) \cdot a_{1\sigma(1)} \cdot a_{2\sigma(2)} +
       \sgn(\sigma_{2}) \cdot a_{1\sigma(1)} \cdot a_{2\sigma(2)}
       = a_{11} a_{22} - a_{12}a_{21}
  \end{align*}
\end{bsp}

Die andere Möglichkeit ist das Verfahren von \textsc{Laplace}, bei dem nach einer Zeile
oder Spalte entwickelt wird:
\begin{gather*}
  \det A = \sum_{j=1}^{n} (-1)^{i+j} a_{ij} A_{ij}
\end{gather*}
wobei $A_{ij}$ diejenige Matrix ist, die durch Streichen der $i$"=ten Zeile und
$j$"=ten Spalte aus $A$ entsteht.

Eine Matrix $A$ besitzt eine zu ihr \highl[Matrix!inverse]{inverse Matrix}~$A^{-1}$, d.\,h. es gilt
\begin{gather*}
  A\cdot A^{-1} = A^{-1}\cdot A = E_{n} =
     \left(\begin{smallmatrix}
       1\\
       & 1 & & \text{\Large \smash{0}}\\
       & & \ddots\\
       & \text{\Large \smash{0}} & & 1\\
       & & & & 1\
     \end{smallmatrix}\right)_{n\times n}
\end{gather*}
genau dann, wenn die Determinante~$\det A$ ein inverses Element in
$[R,+,\cdot]$ besitzt, also genau dann, wenn
$\det A$ eine Einheit des Rings $[R,+,\cdot]$ ist.

Dabei gilt: $A^{-1}= (\det A)^{-1} B$, wobei $(b_{ij})=(-1)^{i+j}\cdot
\det A_{ji}$.

\section{Affinlineare Blockchiffren}
\label{sec:afflin}

Die Zeichen des Klartexts werden durch Elemente aus $\Z_{k}$ codiert und der
Klartext wird in Blöcke der Länge~$n$ eingeteilt, die einzeln nach demselben
Schema verschlüsselt werden.

Der Schlüssel ist ein Paar $(A,b)$, wobei $A\in\Z_{k}^{n\times n}$ und
$b\in\Z_{k}^{1\times n}$ ist. Zur Verschlüsselung eines
Blockes~$m=(\begin{matrix}m_{1}& \dotso& m_{n}\end{matrix})
\in\Z_{k}^{1\times n}$ wird die lineare Abbildung
\begin{gather*}
  c = m\cdot A+b
\end{gather*}
verwendet. Diese Verschlüsselung ist weder eine Substitution (ein Eintrag
$c_{i}$ hängt im Allgemeinen von allen $m_{1},\dotsc, m_{n}$ ab) noch keine
Transposition.

Aber nicht alle Verschlüsselungen dieser Art sind auch eindeutig, d.\,h. eine
Entschlüsselung ist möglich. Dafür muss zu der Matrix~$A$ die inverse
Matrix~$A^{-1}$ existieren, was genau dann der Fall ist, wenn $\ggT(\det A,
k)=1$, also die Determinante von $A$ eine Einheit von $\Z_{k}$ ist.

Die Entschlüsselung erfolgt dann mit der Abbildung
\begin{gather*}
  m=(c-b)A^{-1}
\end{gather*}

Der Spezialfall $b=0$, also $c=m\cdot A$, ist die \highl{Hill-Chiffre} (1929)
und der Spezialfall $A=E_{n}$, also $c=m+b$, ist die
\highl{Vigenère-Chiffre} mit dem Schlüsselwort~$b$.

Man kann auch eine \highl{Blocktransposition} als eine affinlineare
Abbildung beschreiben. Sei $\sigma$ die für die Blocktransposition genutzte Permutation
von $\{1,\dotsc,n\}$. Mit $b=0$ und der Matrix~$P_{\sigma} =
(p_{ij})_{n\times n}$ mit
\begin{gather*}
  p_{ij} =
     \begin{cases}
       0 & \sigma(i) \ne j\\
       1 & \sigma(i) = j
     \end{cases}
\end{gather*}
ergibt sich der erwünschte Effekt, dass
\begin{gather*}
  \begin{pmatrix} m_{1}& m_{2} & \dotso & m_{n} \end{pmatrix}
     \cdot
     P_{\sigma} =
     \begin{pmatrix}
       m_{\sigma(1)}& m_{\sigma(2)} & \dotso & m_{\sigma(n)}
     \end{pmatrix}
\end{gather*}
und es gilt $P_{\sigma}^{-1} = P_{\sigma^{-1}}$.

% 8.11.06

\subsection{Kryptoanalyse affinlinearer Blockchiffren}

Sind $n+1$ Klartextblöcke~$m_{0},\dotsc,m_{n}$ und die dazugehörigen
Geheimtextblöcke~$c_{0},\dotsc, c_{n}$ bekannt --~ein
\highl[Angriff!Known-Plaintext-]{Known-Plaintext-Angriff}~--, kann man folgende zwei Matrizen definieren:
\begin{align*}
  M &=
     \begin{pmatrix}
       m_{1}-m_{0}\\
       \vdots\\
       m_{n}-m_{0}
     \end{pmatrix}_{n\times n}
     & C &=
     \begin{pmatrix}
       c_{1}-c_{0}\\
       \vdots\\
       c_{n}-c_{0}
     \end{pmatrix}_{n\times n}
\end{align*}

Es gilt also
\begin{gather*}
  C =
     \begin{pmatrix}
       c_{1}-c_{0}\\
       \vdots\\
       c_{n}-c_{0}
     \end{pmatrix} =
     \begin{pmatrix}
       (m_{1}A+b) - (m_{0}A+b)\\
       \vdots\\
       (m_{n}A+b) - (m_{0}A+b)\\
     \end{pmatrix} =
     \begin{pmatrix}
       (m_{1}-m_{0})A\\
       \vdots\\
       (m_{n}-m_{0})A\\
     \end{pmatrix} =
     M\cdot A
\end{gather*}

Wenn $\det M$ eine Einheit in $\Z_{k}$ ist, dann existiert auch $M^{-1}$.
Hieraus folgt dann $A=M^{-1}C$ und weiter $b= c_{0}-m_{0}A$.

\begin{bemerk}
  Dies kommt nicht zu selten vor, dass $\det M$ eine Einheit ist, denn es gilt:
  \begin{gather*}
    \limsup_{k\rightarrow\infty} \frac{\phi(k)}{k} = 1
       \qquad\text{und}\qquad
       \lim_{k\rightarrow\infty} \frac{\phi(k)}{k^{1-\delta}} = \infty
  \end{gather*}
  für $\delta>0$.

  Für $\Z_{26}$ gibt es z.\,B. $\phi(26)=12$~Einheiten.
\end{bemerk}

\begin{bemerk}
  In einer halbgeordneten\footnote{Eine Halbordnung ist eine
    transitive, reflexive und antisymmetrische Ordnungsrelation.}
  Menge kann man definieren:
  \begin{gather*}
    \limsup_{k\rightarrow\infty} x_{k} = \inf\Set{ \sup\{ x_{l} | l\geq
       k\}\colon k\in\N}
  \end{gather*}
  In vollständigen Verbänden existiert stets der Limes superior und Limes
  inferior und es gilt $\liminf_{k\rightarrow\infty} x_{k} \leq
  \limsup_{k\rightarrow\infty} x_{k}$.
\end{bemerk}

Für \highl[Hill-Chiffre]{Hill-Chiffren} (d.\,h. $b=0$) genügen $n$~Paare $(m_{j},c_{j})$, da
die Matrix~$C$ nicht als $(c_{i}-c_{0})$ definiert werden muss, um den Anteil
von $b$ zu eliminieren. Damit können auch für die Matrix~$M$ direkt die
Klartextblöcke verwendet werden.

\begin{bsp}
  Es sei $k=26$ und $n=2$. Der Klartext sei "`HERBST"' und der Geheimtext sei
  "`SOMMER"'. Die Aufgabe ist den Schlüssel $(A,b)$ zu bestimmen.

  Der Klartext "`HERBST"' wird durch $\underbrace{7~4}_{m_{0}}~%
  \underbrace{17~1}_{m_{1}}~\underbrace{18~19}_{m_{2}}$ und der Geheimtext
  "`SOMMER"' durch $\underbrace{18~14}_{c_{0}}~%
  \underbrace{12~12}_{c_{1}}~\underbrace{4~17}_{c_{2}}$ codiert.

  Damit kann man nun die Matrizen~$M$ und $C$ bestimmen:
  \begin{gather*}
    M =
       \begin{pmatrix}
         m_{1}-m_{0}\\
         m_{2}-m_{0}
       \end{pmatrix}
       =
       \begin{pmatrix}
          17-7 & 1-4\\
          18-7 & 19-4
       \end{pmatrix}
       =
       \begin{pmatrix}
          10 & 23\\
          11 & 15
        \end{pmatrix}\\
    C =
       \begin{pmatrix}
         c_{1}-c_{0}\\
         c_{2}-c_{0}
       \end{pmatrix}
       =
       \begin{pmatrix}
         12-18& 12-14\\
         4-18& 17-14
       \end{pmatrix}
       =
       \begin{pmatrix}
         20 & 24\\
         12 & 3
       \end{pmatrix}
  \end{gather*}
  \textit{(Beachte: Die Elemente sind aus $\Z_{26}$, immer den Rest der
  Division durch 26 verwenden.)}

  Nun kann man die Determinante von $M$ bestimmen und da diese eine Einheit
  ist, existiert $M^{-1}$.
  \begin{gather*}
    \det M =
       \begin{pmatrix}
          10 & 23\\
          11 & 15
        \end{pmatrix} = 10\cdot15 - 23\cdot11 = 1\\
    M^{-1} = (\det M)^{-1} \cdot B
       = 1 \cdot \begin{pmatrix}15 & 3\\15 & 10\end{pmatrix}
  \end{gather*}
  \textit{(Für die Bestimmung von $B$ siehe \autoref{sec:restklassen}.)}

  Damit lässt sich jetzt die Matrix~$A$ und der Vektor~$b$ bestimmen.
  \begin{gather*}
    A = M^{-1}\cdot C =
       \begin{pmatrix}15 & 3\\15 & 10\end{pmatrix}\cdot
       \begin{pmatrix}20 & 24\\12 & 3\end{pmatrix}
       = \begin{pmatrix}24 & 5\\4 & 0\end{pmatrix}\\
    b = c_{0}-m_{0}
       = \begin{pmatrix}18 & 14\end{pmatrix}
       - \begin{pmatrix}7 & 4\end{pmatrix}
       \cdot \begin{pmatrix}24 & 5\\4 & 0\end{pmatrix}
       = \begin{pmatrix}18 & 14\end{pmatrix}
       - \begin{pmatrix}2 & 9\end{pmatrix}
       = \begin{pmatrix}16 & 5\end{pmatrix}
  \end{gather*}
\end{bsp}

Der einzige Schutz bei affinlinearen Verschlüsselungen besteht darin, den
Schlüsselraum möglichst groß zu machen, um die Berechnungen bei einem Angriff
aufwendiger werden zu lassen.

\section{Feistel-Chiffre}

Die Idee zur Feistel-Chiffre wurde 1971 bei IBM in
dem Projekt "`\href{http://de.wikipedia.org/wiki/Lucifer\_(Kryptographie)}{Lucifer}"'
entwickelt und ist heute Grundlage für viele symmetrische Blockchiffren unter
anderem dem heute am häufigsten eingesetzten Verschlüsselungsalgorithmus DES
--~dazu später mehr in \autoref{sec:des}. Als Erfinder der Feistel"=Chiffre
gilt
\href{http://de.wikipedia.org/wiki/Horst_Feistel}{\textsc{Horst Feistel}}, ein
Mitarbeiter des Projekts.

Bei der Feistel"=Chiffre werden die Klartextblöcke durch eine alternierende Folge von
Substitutionen und Transpositionen verschlüsselt. Die Substitutionen werden in
sogenannten \highl[$S$-Box]{$S$-Boxen} durchgeführt und dienen dazu, die
Konfusionseigenschaft der Verschlüsselung zu sichern. Die Transpositionen
werden in sogenannten \highl[$P$-Box]{$P$-Boxen} (von Permutation)
durchgeführt, um die Diffusionseigenschaft der Verschlüsselung zu
erzeugen.\footnote{Konfusion und Diffusion sind nach \textsc{Claude Shannon} zwei
wichtige Eigenschaften einer Verschlüsselung.}

Einen einzelnen Durchlauf
von Substitution und Transposition bezeichnet man als \highl{Runde}. Eine
(Block"~)""Chiffre mit mehreren Runden bezeichnet man als
\highl[Blockchiffre!iterierte]{iterierte Blockchiffre.} Die
einzelnen Schlüssel für jede Runde (\highl{Rundenschlüssel} genannt) werden
dabei aus einem (Haupt"~)""Schlüssel
erzeugt.

Eine Nachricht~$m\in\Z_{2}^{n}$ der Länge~$n$ (o.\,B.\,d.\,A. sei $n$ gerade)
wird in zwei gleichlange Teile~$L_{0}$ und $R_{0}$ zerlegt. Aus diesen beiden
wird unter Verwendung des Rundenschlüssels~$k_{i}$ durch die Zuordnung in
\autoref{eq:feistel} ein neuer linker Teil~$L_{1}$
und ein neuer rechter Teil~$R_{1}$ gewonnen. Diese beiden Zeichenketten
wiederum werden als Eingabe für die nächste Runde verwendet. Die
\highl{Rundenzahl}~$r$ bestimmt dabei, wie oft ein solcher Durchlauf
stattfindet. In der letzten Runde wird die leicht modifizierte Vorschrift aus
\autoref{eq:feistel-last} verwendet, bei der die Transposition entfällt.

\begin{align}\label{eq:feistel}
  \begin{split}
    L_{i} &= R_{i-1}\\
    R_{i} &= L_{i-1} \oplus f_{k_{i}}(R_{i-1})
  \end{split}
     &\text{für~}i=1,\dotsc,r-1\\
  \label{eq:feistel-last}
  \begin{split}
    L_{r} &= L_{r-1} \oplus f_{k_{r}}(R_{r-1})\\
    R_{r} &= R_{r-1}
  \end{split}
\end{align}

Dieses Schema bezeichnet man als \highl{Feistel-Netzwerk} und eine
Verschlüsselung, die danach arbeitet, nennt man eine \highl{Feistel-Chiffre}.
\begin{gather*}
  (L_{i-1}, R_{i-1})
     \xrightarrow{\text{Substitut.}}
     \bigl(L_{i-1} \oplus f_{k_{i}}(R_{i-1}), R_{i-1} \bigr)
     \xrightarrow{Transposit.}
     \bigl(R_{i-1}, L_{i-1}\oplus f_{k_{i}}(R_{i-1}) \bigr)
\end{gather*}
Dabei bezeichnet $\oplus$  das Exclusive-Oder \texttt{xor} bzw. die
Addition modulo 2.

\begin{figure}
  \centering
  \input{feistel.pdf_t}
  \caption{Schematische Darstellung des Feistel-Netzwerks}
  \label{fig:feistel}
\end{figure}
  \todo{Die Grafik ragt über die Ränder hinaus.}

Für die Entschlüsselung einer Nachricht kann man den gleichen Algorithmus mit
der umgekehrten Schlüsselfolge $k_{i}'\coloneq k_{r+1-i}$ (für $i=1,\dotsc,r$) auf
$c=(L_{0}', R_{0}')=(L_{r}, R_{r})$ anwenden und einfach die verschlüsselte
Nachricht nochmals verschlüsseln. Dies hat zum Einen den Vorteil, dass man die
gleiche Hard"~/""Software auf der Sender- und Empfängerseite einsetzen kann,
und zum Anderen kann die Funktion~$f$ sehr kompliziert sein, da man nicht
deren inverse Funktion benötigt.

Bei der Entschlüsselung gilt in allen Runden $i=1,\dotsc,r$ der Zusammenhang
$(L_{i}', R_{i}') = (R_{r-i}, L_{r-i})$ und für die letzte Runde ergibt sich
dann der Klartext der Nachricht als $(L_{r}', R_{r}') = (L_{0}, R_{0})$, da
die Ausgabe des letzten Schritts die vertauschte Ausgabe der normalen Runden
ist.

\begin{align*}
  (L_{1}', R_{1}') &= \bigl(R_{0}',\; L_{0}' \oplus f_{k_{1}'}(R_{0}')\bigr)
     &\text{nach \eqref{eq:feistel}}\\
  &= \bigl(R_{r},\; L_{r}\oplus f_{k_{r}}(R_{r}) \bigr) &\text{nach IV.}\\
  &= \bigl(R_{r-1},\; \bigl(L_{r-1} \oplus f_{k_{r}}(R_{r-1})\bigr) \oplus
     f_{k_{r}}(R_{r-1}) \bigr) &\text{nach \eqref{eq:feistel-last}}\\
  &= (R_{r-1}, L_{r-1}) &\text{da~}a\oplus a=0\displaybreak[0]\\[1.5ex]
  (L_{n}', R_{n}') &= \bigl(R_{n-1}',\; L_{n-1} \oplus f_{k_{n}'}(R_{n-1}')
     \bigr) & \text{nach \eqref{eq:feistel}}\\
  &= \bigl(L_{r-n+1},\; R_{r-n+1} \oplus f_{k_{r+1-n}}(L_{r-n+1})\bigr)
     &\text{nach IV.}\\
  &= \bigl(R_{r-n},\; \bigl(L_{r-n}\oplus f_{k_{r-n+1}}(R_{r-n})\bigr) \oplus
     f_{k_{r+1-n}}(R_{r-n})\bigr) &\text{nach \eqref{eq:feistel}}\\
  &= (R_{r-n}, L_{r-n})
\end{align*}

% 15.11.

Da die Schlüsselfolge $k_{1},\dotsc, k_{r}$ für die Ver- und Entschlüsselung
aus dem gleichen (Haupt"~)""Schlüssel erzeugt wird, ist die Feistel"=Chiffre
eine symmetrische Verschlüsselung.

Die Sicherheit der gesamten Verschlüsselung beruht auf der Eigenschaft, dass
die Substitution, genauer die Funktion~$f_{k_{i}}$, eine nichtlineare
Transformation ist. Wäre $f_{k_{i}}$ eine lineare Transformation, so wäre auch
die Verkettung von Substitution und Transposition\footnote{$\begin{pmatrix}R&L
\end{pmatrix} = \begin{pmatrix}L& R\end{pmatrix}\cdot
(\begin{smallmatrix}0& 1\\1& 0\end{smallmatrix})$} in jeder Runde eine lineare
Transformation. Man könnte also den gesamten Verschlüsselungsvorgang mit einer
einzigen linearen Gleichung beschreiben. Die Funktion $\oplus$ ist
linear, da sich leicht zeigen lässt, dass $f(ax+by)=af(x)+bf(y)$ mit
$f(x)= f(x_1, x_2)= x_1\oplus x_2= x_1 + x_2 \mod 2$ für $x_1, x_2 \in
\mathbb{F}_2$ folgt.

Ist die Funktion~$f$ eine kryptographisch sichere Pseudozufallsfunktion, so
haben \textsc{Michael Luby} und \textsc{Charles Rackoff} gezeigt\cite{luby}, reichen drei Runden um eine
Pseudozufallspermutation zu erreichen. Mit vier Runden bekommt man sogar eine
starke Pseudozufallspermutation.\footnote{Geklaut aus der
\href{http://en.wikipedia.org/wiki/Feistel_cipher}{englischen Wikipedia}, die
selbst auf \cite{luby} verweist.}

% Angenommen: $f_{K_{i}}$ ist linear:
% \begin{gather*}
%   f_{K_{i}}(R_{i-1}) = R_{i-1}\cdot A_{i} + b\qquad
%      A_{i}\in \Z_{2}^{(n\times n)}, b_{i} \in \Z_{2}^{(1\times n)}
% \end{gather*}
% dann ist die Substitution:
% \begin{gather*}
%   (L_{i-1}\oplus f_{K_{i}}(R_{i-1}), R_{i-1}) = (L_{i-1}, R_{i-1})\cdot
%      \begin{pmatrix}
%        E_{n} & 0_{n}\\
%        A_{i} & E_{n}
%      \end{pmatrix}
%      + (b_{i}, 0)
% \end{gather*}

\section{DES -- Data Encryption Standard}\label{sec:des}

Der \highl{Data Encryption Standard} (\highl{DES}) wurde in den
1970ern von IBM für eine Ausschreibung des US~National Bureau of
Standards\footnote{wurde später in
  \href{http://www.nist.gov/}{National Institute of Standards and
    Technology (NIST)} umbenannt} entwickelt. Er basiert auf den
vorangegangenen Entwicklungen des Projekts \highl{Lucifer}, das die
Feistel"=Chiffre entwickelt hatte. Am 23.\,November 1976 wurde DES als
Standard für die Verschlüsselung in den amerikanischen Bundesbehörden
anerkannt und im Januar 1977 erfolgte die Veröffentlichung als FIPS
PUB~46\cite{des}.

Die International Organization for Standardization~(ISO) übernahm den
Algorithmus unter der Bezeichnung "`Data Encipherment No.\,1"'~(DEA-1) in ihr
Verzeichnis.

Die Kryptographen \textsc{Eli Biham} und \textsc{Adi Shamir} entwickelten gegen Anfang
der 90er Jahre die \highl[Kryptoanalyse!differentielle]{differentielle
Kryptoanalyse} als Spezialform der Kryptoanalyse. Dabei wird untersucht, wie
sich der Geheimtext bei unterschiedlichen Eingaben ändert. Das Verfahren
wandten sie auch auf DES an.\cite{des-diff-ana}\cite{des-diff-16-ana}
Es zeigte sich, dass der DES einer differentiellen Kryptoanalyse stand hält,
da man $2^{47}$ frei gewählte Klartexte dafür benötigt. Nach Angaben von IBM
war dieser Angriff seit 1974 bekannt und es wurde entsprechende Gegenmaßnahmen
bei der Entwicklung getroffen.\cite{des-copper}

Die fortschreitende Weiterentwicklung der Rechenkraft führte letztlich
dazu, dass ein Brute-Force-Angriff gegen DES erfolgreich ist. So
wurde 1997 das erste Mal eine verschlüsselte Nachricht gebrochen. Ein
Jahr später gelingt es der Electronic Frontier Foundation~(EFF) mit
dem eigens dafür angefertigten Supercomputer "`Deep Crack"', der
88~Milliarden Schlüssel pro Sekunde testen konnte, binnen 56~Stunden eine
Verschlüsselung zu brechen. Ein halbes Jahr später, im Januar~1998,
gelang es durch die Zusammenarbeit von Deep Crack und
\href{http://distributed.net}{distributed.net} einen DES"=Schlüssel in
22~Stunden und 15~Minuten zu ermitteln --~mehr als 245 Milliarden
Schlüssel wurden pro Sekunde getestet.

Im Jahr~2004 wird die Absetzung von DES als Standard für die
Verschlüsselung der amerikanischen Bundesbehörden widerrufen, was ein
Jahr später realisiert wird. Seit 2002 ist der Advanced Encryption
Standard~(AES) als neuer Algorithmus in Kraft.

Der Data Encryption Standard ist eine symmetrische Blockchiffre und arbeitet
mit einem Feistel-Netzwerk (\autoref{fig:feistel}). Die Schlüssellänge für die
Verschlüsselung beträgt 64~Bit, wobei ein Bit pro Byte als Prüfbit verwendet
wird, was den effektiven Schlüsselraum~$\mathcal{K} =\{0,1\}^{56}$ auf 56~Bit
reduziert.

DES arbeitet mit 16 Runden. Aus dem Schlüssel~$k\in\mathcal{K}$ werden
16~Teilschlüssel $k_{1}, k_{2},\dotsc, k_{16}$ der Länge 48~Bit
generiert, die jeweils in einer Runde verwendet
werden.

% \begin{figure}
%   \begin{gather*}
%     % Eine Runde "`Zeichnen für arme Leute"' :-))
%        \xrightarrow[64]{m}
%        \raisebox{-1.6ex}{\framebox{\rule{0pt}{5.5ex}$IP$}}\:
%        \begin{split}
%          \xrightarrow[32]{}\\
%          \xrightarrow[32]{}\\
%        \end{split}
%        \stackrel{k_{1}\downarrow 48}%
%        {\raisebox{-1.6ex}{\framebox{\rule{0pt}{5.5ex}1.~Runde}}}
%        \begin{split}
%          \xrightarrow[32]{}\\
%          \xrightarrow[32]{}\\
%        \end{split}
%        \stackrel{k_{2}\downarrow 48}%
%        {\raisebox{-1.6ex}{\framebox{\rule{0pt}{5.5ex}2.~R.}}}
%        \dotso
%        \stackrel{k_{15}\downarrow 48}%
%        {\raisebox{-1.6ex}{\framebox{\rule{0pt}{5.5ex}15.~R.}}}
%        \begin{split}
%          \xrightarrow[32]{}\\
%          \xrightarrow[32]{}\\
%        \end{split}
%        \stackrel{k_{16}\downarrow 48}%
%        {\raisebox{-1.6ex}{\framebox{\rule{0pt}{5.5ex}16.~R.}}}
%        \begin{split}
%          \xrightarrow[32]{}\\
%          \xrightarrow[32]{}\\
%        \end{split}
%        \:\raisebox{-1.6ex}{\framebox{\rule{0pt}{5.5ex}$IP^{-1}$}}
%        \xrightarrow[64]{c}
%        % und wer hat jetzt Lust das Bild auszumalen?
%   \end{gather*}
%   \caption{Schema für den Ablauf des DES}
%   \label{fig:des}
% \end{figure}

Die Nachricht wird in Blöcke~$m$ der Länge~64 aufgeteilt und nach einer
initialen Permutation\footnote{Die initiale Permutation hat keinen
Einfluss auf die Sicherheit des Algorithmus'. Sie wurde damals
eingeführt, um das Laden der Daten in den Chip zu vereinfachen. Da die
Realisierung der $IP$ in Software jedoch schwieriger ist, wird sie manchmal
weggelassen.} ($IP$) in den 16~Runden transformiert und anschließend noch einmal mit
$IP^{-1}$ permutiert.

\begin{figure}
  \centering
  \input{des.pdf_t}
  \caption{Schematische Darstellung des Ablaufs in einer Runde beim DES}
  \label{fig:des-runde}
\end{figure}

In der $i$-ten~Runde wird gemäß des \highl[Feistel-Netzwerk]{Feistel-Netzwerks}
die Eingabe in eine linke und reche Hälfte $(L,R)$ geteilt. Die Ausgabe der
Runde $(L', R')$ wird durch $L'=R$ und $R'=L\oplus f_{k_{i}}(R)$ erzeugt,
wobei die Verschlüsselungsfunktion~$f$ wie folgt aufgebaut ist:
\begin{enumerate}
 \item Diffusionsschritt: Aus den 32~Bit von $R$ wird ein 48-Bit-Wort $R_{1}$
  erzeugt.
 \item Verknüpfung mit dem Rundenschlüssel: $R_{2}= R_{1}\oplus k_{i}$.
 \item Konfusionsschritt: aus $R_{2}$ wird durch eine nicht lineare
  Transformation~$S$ ein 32-Bit-Wort $R_{3}$ erzeugt. Dazu wird $R_{2}$ in
  8~Worte der Länge~6 zerlegt und diese werden jeweils in einer eigenen $S$-Box
  $S_{i}$ ($1\leq i\leq8$) zu 8~Worten der Länge~4 verarbeitet. Diese
  aneinander gereiht ergeben das 32-Bit-Wort $R_{3}$.
 \item Permutation: Die Ausgabe von $f$ wird durch eine Blocktransposition
  ($P$-Box) aus $R_{3}$ erzeugt.
\end{enumerate}
Der Ablauf ist in \autoref{fig:des-runde} dargestellt. Für die genauen
Vorschriften zur Berechnung der Diffusion, Konfusion und Permutation siehe
FIPS PUB~46\cite{des}. Leider ist deren mathematischer Hintergrund nur
teilweise bekannt\cite{des-copper} und sie können nur als starre Operationen verstanden
werden.

Aber es lässt sich zeigen, dass die beiden Eigenschaften einer Verschlüsselung
nach \textsc{Claude Shannon} erfüllt sind: Die Änderung der Eingabe in einer $S$-Box
in einem Bit ändert die Ausgabe in mindestens zwei Bit --~\highl{Diffusion}~--
und jedes Ausgabebit hängt nach fünf Runden von allen Schlüssel- und Klartextbits ab
--~\highl{Konfusion}.

$DES_{k}\colon\Z_{2}^{64}\rightarrow\Z_{2}^{64}$ sei die gesamte
Transformation (vom $IP$ bis zum $IP^{-1}$) des DES. Da der DES aufgrund
seines kurzen Schlüssels nicht mehr als sicher gilt, aber im Laufe der Jahre
sehr viele Implementationen des Algorithmus' in Hardware und Software
geschaffen wurden, schaltet man einfach mehrere DES-Verschlüsselungen
hintereinander, um die Sicherheit zu erhöhen.

Diese Kaskadierung von mehreren DES-Verschlüsselungen ist nur deshalb
sinnvoll, weil $DES$ keine \highl{Gruppeneigenschaft} besitzt, d.\,h. für zwei
Schlüssel~$k_{1}$ und $k_{2}$ gibt es im Allgemeinen keinen Schlüssel~$k_{3}$,
so dass $DES_{k_{3}}$ die gleiche Abbildung beschreibt wie $DES_{k_{1}}\circ
DES_{k_{2}}$. Wäre $DES$ abgeschlossen bzgl. Verkettung (besäße also die
Gruppeneigenschaft), so könnte man statt der Verkettung $DES_{k_{1}}\circ
DES_{k_{2}}$ die einfache Verschlüsselung $DES_{k_{3}}$ angreifen, der
Schlüsselraum hätte sich also nicht vergrößert. Es gilt sogar, dass die Gruppe
von Verschlüsselungen, die durch beliebige Verkettungen von
DES-Verschlüsselungen erzeugt wird, mehr als $10^{2499}$ Verschlüsselungen
umfasst.\cite[S.\,258]{menezes}\cite{wiener}

\begin{itemize}
 \item Eine Variante ist es, den Geheimtext noch einmal zu verschlüsseln:
  ($DES_{k_{1}} \circ DES_{k_{2}}$)
  \begin{itemize}
   \item Wenn $k_{1}=k_{2}$ ist, bringt dies keine wesentliche Erhöhung der
    Sicherheit, da es einfach nur die Rundenzahl erhöht.

   \item Der Fall $k_{1}\ne k_{2}$ schafft eine echte Vergrößerung des
    Schlüsselraums auf $2^{112}$~Schlüssel. Jedoch kann man mit einem
    \highl[Angriff!Meet-in-the-Middle-]{Meet-in-the-Middle-Angriff} die
    maximale Anzahl der Versuche auf $2^{57}$ beschränken, benötigt dafür aber
    extrem viel Speicherplatz. Ist zu einem Klartext~$m$ der Geheimtext~$c$
    bekannt (\highl[Angriff!Known-Plaintext-]{Known-Plaintext-Angriff}), kann
    man damit das Paar~$(k_{1},k_{2})$ ermitteln.

    \begin{enumerate}
     \item Berechne und speichere $DES_{k_{1}}(m)$ für alle Schlüssel~$k_{1}$
      ($2^{56}$~Stück).
     \item Berechne und speichere $DES^{-1}_{k_{2}}(c)$ für alle
      Schlüssel~$k_{2}$ ($2^{56}$~Stück).
     \item Vergleiche beide Listen auf identische Einträge.
    \end{enumerate}

    Somit hat man bei $n$~Schlüsseln nach $2n$~Berechnungen (anstelle von
    $n^{2}$) und $O(n\log n)$~Vergleichen das Schlüsselpaar~$(k_{1},k_{2})$
    gefunden, für das gilt $DES_{k_{2}}(DES_{k_{1}}(m))=c$.

    Unter Umständen gibt es mehrere Schlüsselpaare, die die Bedingung
    erfüllen. Dann benötigt man ein zweites Klartext-Chiffretext-Paar und muss
    damit das Verfahren nochmal wiederholen.
  \end{itemize}

 \item Eine Verkettung der Form $DES_{k_{1}} \circ DES_{k_{2}}^{-1} \circ
  DES_{k_{3}}$ bezeichnet man als \highl{Triple-DES} (\highl{3DES}). Der
  Standard schlägt folgende Kombinationen von Schlüsseln vor:
  \begin{itemize}
   \item $k_{1}=k_{2}=k_{3}$: Damit ergibt sich der einfache DES; Die Idee
    dieser Variante ist, dass man mit einer Triple-DES-Implementation
    weiterhin einen einfachen DES unterstützen kann.

   \item $k_{1}=k_{3}$ unabhängig von $k_{2}$: Diese Variante lässt sich
    leicht mit einem
    \highl[Angriff!Chosen-Plaintext-]{Chosen-Plaintext-Angriff}, der ungefähr
    $2^{56}$~Schlüssel und $2^{56}$~Speicherplätze benötigt, brechen.

   \item alle drei Schlüssel unabhängig voneinander: Damit erreicht man eine
    echte Vergrößerung des Schlüsselraums.
  \end{itemize}
\end{itemize}

\begin{bemerk}
  Nach dem Prinzip der Feistel"=Chiffre wäre die
  Entschlüsselung~$DES^{-1}_{k}$ eine Verschlüsselung~$DES_{k^{R}}$ mit dem
  umgekehrten Schlüssel $k^{R}$. Da aber der DES noch eine Erzeugung der
  Teilschlüssel aus $k$ umfasst, ist $k^{R}$ nicht der permutierte Schlüssel,
  der bei der Entschlüsselung $DES^{-1}_{k}$ verwendet wird.
\end{bemerk}

% 20.11.

\subsection{Ein Beispiel einer vereinfachten DES-Verschlüsselung}
\label{sec:des-bsp}

Zur Vereinfachung des ganzen, sei die Blocklänge $n=12$ (statt 64) und der
(Haupt"~)""Schlüssel~$k$ habe die Länge 9 (statt 64). Damit sind die beiden
Teilblöcke~$L$ und $R$ 6~Bit lang. Die initiale Permutation $IP$ und die
Permutation im 4.\,Schritt seien die Identität, sprich diese Schritte
entfallen.

Die Rundenschlüssel $k_{1},\dotsc,k_{r}\in\Z_{2}^{8}$ werden aus
dem Schlüssel~$k=(\begin{matrix}\kappa_{0}&\dotso&\kappa_{8}\end{matrix})$
nach folgender Vorschrift erzeugt:
\begin{gather*}
  k_{i+1} =
     \begin{pmatrix}
       \kappa_{i\bmod9}& \kappa_{i+1\bmod9}& \dotso& \kappa_{i+7\bmod9}
     \end{pmatrix}
     \qquad 0\leq i < r
\end{gather*}
Dadurch wiederholen sich die Rundenschlüssel zyklisch ab der 10.~Runde;
$k_{i} = k_{i+9} = k_{i+18} = \dotsb$.

Die Diffusion $D\colon \Z_{2}^{6} \mapsto \Z_{2}^{8}$ für den ersten Schritt
sei folgende lineare Abbildung
\begin{align*}
  D(\alpha) &=
     D(\begin{pmatrix}\alpha_{1}& \alpha_{2}& \dotso &\alpha_{6}\end{pmatrix})
     =
     \begin{pmatrix}
       \alpha_{1}& \alpha_{2}& \alpha_{4}& \alpha_{3}& \alpha_{4}& \alpha_{3}&
       \alpha_{5}& \alpha_{6}
     \end{pmatrix}\\
  &= \alpha \cdot
     \begin{pmatrix}
       1& 0& 0& 0& 0& 0& 0& 0\\
       0& 1& 0& 0& 0& 0& 0& 0\\
       0& 0& 0& 1& 0& 1& 0& 0\\
       0& 0& 1& 0& 1& 0& 0& 0\\
       0& 0& 0& 0& 0& 0& 1& 0\\
       0& 0& 0& 0& 0& 0& 0& 1
     \end{pmatrix}
\end{align*}

Es soll auch nur zwei $S$-Boxen geben, die aus einer Eingabe von 4~Bit eine
Ausgabe von 3~Bit erzeugen. In Anlehnung an den Standard seien diese in Form
einer $2\times8$-Tabelle mit Einträgen aus $\{0,\dotsc,7\}$ gegeben.
\begin{gather*}
  S_{1} =
     \begin{pmatrix}
       5& 2& 1& 6& 3& 4& 7& 0\\
       1& 4& 6& 2& 0& 7& 5& 3
     \end{pmatrix}\\
  S_{2} =
     \begin{pmatrix}
       4& 0& 6& 5& 7& 1& 3& 2\\
       5& 3& 0& 7& 6& 2& 1& 4
     \end{pmatrix}
\end{gather*}
Für eine Eingabe~$\alpha=(\begin{matrix}\alpha_{1}&\dotso&\alpha_{4}
\end{matrix})$ ist das Ergebnis der Transformation in der
$(\alpha_{1}+1)$-ten~Zeile und in der $(2^{2}\cdot\alpha_{2}+2\cdot\alpha_{3}+
\alpha_{4})$-ten~Spalte abzulesen. Das erste Bit kodiert also die Zeile (0 für
die erste, 1 für die zweite) und die verbleibenden drei Bits beschreiben als
Binärzahl interpretiert die Spalte (000 die erste, 111 die achte).

\begin{bsp}
  Wie sieht nun der Ablauf in der 4.\,Runde aus, wenn der
  Schlüssel~$k=(0100\,11001)$ lautet und die Eingabe $(001\,111\: 101\,011)$
  ist?

  Der Rundenschlüssel~$k_{4}$ lautet also $(0110\,0101)$. Für die
  Rundenfunktion~$f(101\,011)$ ergeben sich folgende Teilergebnisse:
  \begin{enumerate}
   \item Diffusion: $R_{1} = D(101\,011) = (1001\,0111)$
   \item Addition des Rundenschlüssels:
    $R_{2} = (1001\,0111)\oplus (0110\,0101) = (1111\,0010)$
   \item Konfusion: Zerlegung von $R_{2}$ in zwei Teile und Ersetzung anhand
    der $S$-Boxen $S_{1}(1\,111) = 3 = (011)$ und $S_{2}(0\,010) = 6 = (110)$.
  \end{enumerate}

  Das Ergebnis der 4.\,Runde lautet also $(101\,011\:011\,110)$.
\end{bsp}

\subsection{Differentielle Kryptoanalyse des DES mit einer Runde}

Die \highl[Kryptoanalyse!differentielle]{differentielle Kryptoanalyse} wurde
Ende der 1980er von \textsc{Eli Bahim} und \textsc{Adi Shamir} entwickelt. Dabei wird die
statistische Verteilung der Abstände der Ausgaben (vom gesamten oder von
Teilen des Algorithmus') in Abhängigkeit von den Abständen der Eingaben
untersucht. Treten einige Abstände häufiger als andere auf, so kann man darauf
aufbauend, versuchen den Schlüssel zu ermitteln. Diese Methode des Angriffs
war IBM beim Entwurf des DES bereits bekannt und so wurden entsprechende
Gegenmaßnahmen ergriffen; siehe \cite{des-copper}.

Um mit einer differentiellen Kryptoanalyse den
Schlüssel~$k=(\kappa_{1}\dotso\kappa_{r})$ erlangen zu können, muss sich der
Angreifer zu jedem beliebigen Klartext den Geheimtext beschaffen können
(\highl[Angriff!Chosen-Plaintext-]{Chosen-Plaintext-Angriff}). Außerdem muss
er die Kenntnis über alle Teile des Algorithmus' haben. Die differentielle
Kryptoanalyse des DES stützt sich auf zwei Punkte:
\begin{itemize}
 \item Da der Diffusionsschritt unabhängig vom Rundenschlüssel~$k_{i}$ ist,
  kann man also das Ergebnis der Diffusion für einen beliebigen Klartext
  berechnen.

  Danach kommt die Addition des Rundenschlüssels. Dabei gilt aber,
  dass die Differenz~$a\oplus b$ zwischen zwei Blöcken~$a$ und $b$
  sich nicht ändert, wenn zu jedem Block derselbe Wert (Rundenschlüssel)
  addiert wird: $a\oplus b = (a\oplus k_{i}) \oplus (b\oplus k_{i})$.

  Für zwei Klartexte kann man also aus der Kenntnis über die Ergebnisse der
  Diffusion auf die Differenz der Ergebnisse der Schlüsseladdition schließen.

 \item Dieses Wissen über die Eingabe in die $S$-Box und die Ausgabe der
  $S$-Box, den Geheimtext (wobei man wieder die Berechnung der $P$-Box
  rückgängig machen kann), kann man ausnutzen, um die Menge der möglichen
  Eingabewerte in die $S$-Box einzugrenzen. Damit kann man dann die Menge der
  möglichen Schlüssel eingrenzen bzw. mit mehreren Klartext-Geheimtext-Paaren
  den Schlüssel bestimmen.
\end{itemize}

Für zwei Eingabeblöcke $a,\tilde{a}\in\Z_{2}^{m}$ und einen $S$-Box
$S\colon\Z_{2}^{m}\rightarrow\Z_{2}^{n}$ des Konfusionsschritts heißt $a^{*} =
a\oplus \tilde{a}\in\Z_{2}^{m}$ \highl{Eingabedifferenz} (Input"=Differenz)
und $S_{1}(a)\oplus S_{1}(\tilde{a})\in\Z_{2}^{n}$ \highl{Ausgabedifferenz}
(Output"=Differenz). Beim DES ist $m=6$ und $n=4$, in dem Beispiel in
\autoref{sec:des-bsp} ist $m=4$ und $n=3$.

Für ein festes $a^{*}\ne0\in\Z_{2}^{m}$ gibt es genau $2^{m-1}$
Mengen\footnote{Man hat $2^{m}$ Möglichkeiten für die Wahl von $a$.
$\tilde{a}$ ist dann fest $\tilde{a}=a\oplus a^{*}$. Da die Menge ungeordnet
ist, entfällt die Hälfte der Möglichkeiten.} der Form $\{a,\tilde{a}\}$, für
die $a\oplus \tilde{a}=a^{*}$ ist. Theoretisch sind $2^{n}$ verschiedene
Ausgabedifferenzen $S(a)\oplus S(\tilde{a})\in\Z_{2}^{n}$ möglich, jedoch sind
für einige Eingabedifferenzen (insgesamt gibt es $2^{m}-1$) die Ergebnisse
einiger $S$-Boxen nicht gleichverteilt.

\begin{bsp}
  \label{bsp:4}
  Die $S$-Box sei die $S_{1}$ aus \autoref{sec:des-bsp} und die
  Eingabedifferenz sei $a^{*}=(0011)$. Es ergeben sich damit folgende Mengen
  $\{a,\tilde{a}\}$ mit ihren Ausgabedifferenzen. Die Ausgabedifferenz $(011)$
  tritt dabei in 6 von 8~Fällen auf.
  \begin{gather*}
    \begin{array}{c*{4}{|c}}
      a & \tilde{a}& S_{1}(a)& S_{1}(\tilde{a})& S_{1}(a)\oplus
      S_{1}(\tilde{a})\\
      \hline
      (0000)& (0011)& (101)& (110)& (011)\\
      (0001)& (0010)& (010)& (001)& (011)\\
      (0100)& (0111)& (011)& (000)& (011)\\
      (0101)& (0110)& (100)& (111)& (011)\\
      \hline
      (1000)& (1011)& (001)& (010)& (011)\\
      (1001)& (1010)& (100)& (110)& (010)\\
      (1100)& (1111)& (000)& (011)& (011)\\
      (1101)& (1110)& (111)& (101)& (010)
    \end{array}
  \end{gather*}
\end{bsp}

% 22.11.

Die Eingabe der $i$-ten~Runde sei der Block $(L_{i-1}, R_{i-1})$, wobei für
$f_{k_{i}}$ nur $R_{i-1}$ relevant ist. Der Ablauf ist nun wie folgt:
\begin{enumerate}
 \item Diffusion: $d = D(R_{i-1})$
 \item Schlüsselverknüpfung: $a = d\oplus k_{i}$
 \item Konfusionsschritt: Zerlegung von $a$ in Blöcke~$a^{\ell}$ der Länge~$m$
  und Transformation dieser in der jeweiligen $S$-Box $S_{\ell}$.
 \item (Permutationsschritt:) Dieser muss nicht betrachtet werden, da man
  diesen Schritt ausgehend vom Geheimtext einfach rückgängig machen kann.
\end{enumerate}

Teilt man bereits das Ergebnis der Diffusion $D(R_{i-1})$ in Blöcke~$d^{\ell}$
und den Rundenschlüssel~$k_{i}$ in Blöcke~$k_{i}^{\ell}$ entsprechend der
$S$-Box, in die das Ergebnis der Schlüsselverknüpfung $D(R_{i-1})\oplus k_{i}$
gelangt, so kann man das Ergebnis der Rundenfunktion wie folgt darstellen:
\begin{align*}
  f_{k_{i}}(R_{i-1})
     &= \begin{pmatrix}
           S_{1}(a^{1})& S_{2}(a^{2}) & \dotso& S_{\ell}(a^{\ell})& \dotso
        \end{pmatrix}\\
     &= \begin{pmatrix}
           S_{1}(d^{1}\oplus k_{i}^{1})& S_{2}(d^{2}\oplus k_{i}^{2}) &
           \dotso& S_{\ell}(d^{\ell}\oplus k_{i}^{\ell})& \dotso
        \end{pmatrix}
\end{align*}

Für zwei verschiedene Eingaben $R_{i-1}$ und $\tilde{R}_{i-1}$ in der
$i$-ten~Runde ist die Eingabedifferenz der $\ell$-ten~$S$-Box
\begin{gather}
  \label{eq:eing-diff}
  a^{\ell} \oplus \tilde{a}^{\ell}
     = (d^{\ell} \oplus k_{i}^{\ell}) \oplus (\tilde{d}^{\ell}\oplus
       k_{i}^{\ell})
     = d^{\ell} \oplus \tilde{d}^{\ell}
\end{gather}
Man kann also aus der Ausgabe des Diffusionsschritts (1.\,Schritt)
Rückschlüsse auf die Eingabe des Konfusionsschritts (3.\,Schritt) ziehen. Die
Ausgabedifferenz der $\ell$-ten~$S$-Box ist
\begin{gather*}
  S_{\ell}(a^{\ell}) \oplus S_{\ell}(\tilde{a}^{\ell})
     = S_{\ell}(d^{\ell}\oplus k_{i}^{\ell}) \oplus
       S_{\ell}(\tilde{d}^{\ell}\oplus k_{i}^{\ell})
\end{gather*}

Sind die Ausgaben des Diffusionsschritts~$d^{\ell}$ und $\tilde{d}^{\ell}$ und
die Ausgabedifferenz des Konfusionsschritts~$S_{\ell}(a^{\ell})\oplus
S_{\ell}(\tilde{a}^{\ell})$ bekannt, so kann man mit Hilfe dieser Größen über
die bekannte Verteilung der Eingabe- und Ausgabedifferenzen für die $S$-Box
$S_{\ell}$ die Menge der möglichen Eingaben $\{a^{\ell},\tilde{a}^{\ell}\}$ in
die $S$-Box bestimmen. Über die Beziehung $a^{\ell} = d^{\ell}\oplus
k_{i}^{\ell}$ ergibt sich so eine Einschränkung für den
Teilrundenschlüssel~$k_{i}^{\ell}$.

\begin{bsp}
  Das Beispiel bezieht sich auf den vereinfachten DES aus
  \autoref{sec:des-bsp}. Es soll nur um die Betrachtung der $S$-Box $S_{1}$
  ($\ell=1$) gehen. Die Ausgaben des Diffusionsschritts seien $d^{1}=(0101)$
  und $\tilde{d}^{1}=(0110)$. Die Ausgabedifferenz der $S$-Box sei $(010)$.

  Die Eingabedifferenz der $S$-Box ist nach \autoref{eq:eing-diff}
  $d^{1}\oplus \tilde{d}^{1} = (0011)$. Laut der Aufstellung in
  \autoref{bsp:4} sind als Eingabe $a^{1}$ in die $S$-Box die Werte
  $\{(1001), (1010), (1101),\linebreak[0] (1110)\}$ möglich.

  Daraus ergeben sich durch die Beziehung $k_{i}^{1} = d^{1}\oplus a^{1}$ als
  mögliche Teilrundenschlüssel $\{(1100), (1111), (1000), (1001)\}$.
\end{bsp}

Mit mehreren Klartextblöcken kann man so verschiedene Schlüsselmengen
ermitteln. Der tatsächliche Schlüssel liegt im Durchschnitt aller
Schlüsselmengen.

\subsection{Differentielle Kryptoanalyse des DES mit drei Runden}

Diese Überlegungen für eine Runde, lassen sich auch auf ein System mit drei
Runden erweitern. $(L_{0}, R_{0})$ und $(\tilde{L}_{0}, R_{0})$ seien die
Eingabe, wobei der rechte Teil bei beiden gleich ist, und $(L_{3}, R_{3}),
(\tilde{L}_{3}, \tilde{R}_{3})$ die zugehörigen Geheimtextblöcke. $L_{3}$
bestimmt sich laut Feistel-Netzwerk (\autoref{eq:feistel} und
\autoref{eq:feistel-last}) als
\begin{gather*}
  L_{3} = L_{2}\oplus f_{k_{3}}(R_{2}) = R_{1}\oplus f_{k_{3}}(R_{2}) =
     L_{0}\oplus f_{k_{1}}(R_{0})\oplus f_{k_{3}}(R_{2})
\end{gather*}
Analog gilt $\tilde{L}_{3} = \tilde{L}_{0}\oplus f_{k_{1}}(R_{0})\oplus
f_{k_{3}}(\tilde{R}_{2})$. Die Ausgabedifferenz der dritten Runde ist also
\begin{gather*}
  L_{3}^{*} = L_{3} \oplus \tilde{L}_{3} = L_{0}\oplus \tilde{L}_{0}\oplus
     f_{k_{3}}(R_{2})\oplus f_{k_{3}}(\tilde{R}_{2})
\end{gather*}

Die Eingabedifferenz $L_{0}^{*} = L_{0}\oplus\tilde{L}_{0}$ ist bekannt. Da
die Permutation (4.\,Schritt) eine lineare Abbildung ($g(a)+g(b)=g(a+b)$) ist,
erhält man die Ausgabedifferenz des Konfusionsschritts
\begin{gather*}
  L_{3}^{*}\oplus L_{0}^{*} = f_{k_{3}}(R_{2}) \oplus f_{k_{3}}(\tilde{R}_{2})
     = P\bigl(S(a_{3})\bigr) \oplus P\bigl(S(\tilde{a}_{3})\bigr)
     = P\bigl(S(a_{3}\oplus\tilde{a}_{3})\bigr)
\end{gather*}

Da $R_{3}=R_{2}$ (\autoref{eq:feistel-last}) ist, kann man für
$f_{k_{3}}(R_{2})$ die Diffusion $D(R_{2})$ bestimmen. Damit hat wieder wieder
die Situation wie im Fall mit einer Runde erreicht: Man kennt die Ausgabe des
Diffusionsschritts für $f_{k_{3}}(R_{2})$ und $f_{k_{3}}(\tilde{R}_{2})$ und
man kennt die Ausgabedifferenz des Konfusionsschritts $S(a)\oplus
S(\tilde{a})$. Man ist also in der Lage, den Schlüssel für die 3.\,Runde zu
bestimmen. Mit diesem Schlüssel kann man dann $f_{k_{3}}(R_{2})$ und damit
$L_{2} = L_{3}\oplus f_{k_{3}}(R_{2})$ bestimmen.

Für den Schlüssel der zweiten Runde kann man direkt die Ausgabedifferenz des
Konfusionsschritts bestimmen, denn $R_{2} = L_{1}\oplus f_{k_{2}}(R_{1}) =
R_{0}\oplus f_{k_{2}}(R_{1})$. Die Diffusion $D(R_{1}) = D(L_{2})$ lässt sich
wieder berechnen und damit besteht wieder eine Situation wie im Fall mit einer
Runde. Danach verbleibt nur noch eine Runde.

% 27.11.

Beispiel:
\begin{align*}
  (L_{0}, R_{0})& = (000\,111, 011\,011)\\
  (L_{0}', R_{0}')& = (101\,110, 011\,011)\\
  (L_{3}, R_{3})& = (100\,101, 000\,011)\\
  (L_{3}', R_{3}')& = (011\,000, 100\,100)
\end{align*}

Ziel: Bestimme den Schlüssel~$K$ (bzw. Einschränkung der Möglichkeiten)

\begin{align*}
  R_{2}& = R_{3} = (000\,011)& D(R_{2})& =(0000, 0011) = (\tilde{A},\tilde{B})\\
  R_{2}'& = R_{3}' = (100\,100)& D(R_{2}')& =(1010, 1000) =
     (\tilde{A}',\tilde{B}')
\end{align*}

Eingabedifferenz in $S$-Box $S_{1} = \tilde{A}\oplus\tilde{A}' = (1010)$\\
Ausgabedifferenz von $S_{1}$: linke Hälfte von $L_{3}^{*}\oplus L_{0}^{*}$

linke Hälfte von $L_{3}^{*}\oplus L_{0}^{*}$
\begin{gather*}
  L_{3}^{*} = (100\,101)\oplus (011\,000) = (111\,101)\\
  L_{0}^{*} = (000\,111)\oplus (101\,110) = (101\,001)\\
  L_{3}^{*} \oplus L_{0}^{*} = (010\,100)
\end{gather*}

Die Ausgabedifferenz von $S_{1}$ ist $(010)$. kam in der Tabelle oben
(siehe \autoref{bsp:4}) zweimal vor. $A\in \{(0011), (1001)\}$

$K_{3}^{L} = A\oplus \tilde{A} = \{(0011), (1001)\}$ zwei Möglichkeiten.

\begin{gather*}
  S_{2} = \begin{pmatrix}
            4& 0& 6& 5& 7& 1& 3& 2\\
            5& 3& 0& 7& 6& 2& 1& 4
          \end{pmatrix}
     \qquad
     B^{*} = \begin{pmatrix}1& 0& 1& 1\end{pmatrix}
\end{gather*}

Eingabedifferenz der $S$-Box $S_{2}$:
\begin{gather*}
  \tilde{B}\oplus \tilde{B}' = (0011)\oplus (1000) = (1011)
\end{gather*}
Ausgabedifferenz der $S$-Box $S_{2}$: rechte Hälfte von $L_{3}^{*}\oplus
L_{0}^{*}$: $(100)$.

liefert die Schlüssel $K_{3}^{R}\in\{(1111),(0100)\}$ zwei Möglichkeiten
$\rightarrow$ vier Möglichkeiten für $K_{3}$ und damit acht Möglichkeiten für
$K$ statt 512.

\begin{gather*}
  \begin{array}{c|c|c|c|cl}
    \tilde{B}& \tilde{B}'& S_{2}(\tilde{B})& S_{2}(\tilde{B}')&
    S_{2}(\tilde{B})\oplus S_{2}(\tilde{B}')\\
    \hline
    (0000)& (1011)& (100)& (111)& (011)\\
    (0001)& (1010)& (000)& (000)& (000)\\
    (0010)& (1001)& (110)& (011)& (101)\\
    (0011)& (1000)& (101)& (101)& (000)\\
    (0100)& (1111)& (111)& (100)& (011)\\
    (0101)& (1110)& (001)& (001)& (000)\\
    (0110)& (1101)& (011)& (010)& (001)\\
    (0111)& (1100)& (010)& (110)& (100)& (*)
  \end{array}\\
  (*)\quad B=\{(0111), (1100)\}\qquad K_{3}^{R}= B\oplus \tilde{B} = \{(0100),
     (1111)\}
\end{gather*}

Brauchen ein zweites Klartextpaar: z.\,B. $(L_{0}, R_{0}) = (010\,111,
011\,011)$ und $(L_{0}', R_{0}') = (101\,110, 011\,011)$ mit $(L_{3}, R_{3}) =
(001\,010, 001\,011)$ und $(L_{3}', R_{3}') = (011\,000, 100\,100)$.

1.\,Aufgabe: Bestimme $K_{3}^{L}$ und $K_{3}^{R}$. 2.\,Aufgabe: Bestimme $K$.

Angenommen $K_{3} = (x_{1} x_{2} x_{3} x_{4} x_{5} x_{6} x_{7} x_{8})$.
Dann hat $K$ die Gestalt $K=(x_{p} x_{1} x_{2} x_{3} x_{4} x_{5} x_{6} x_{7})$.
\begin{align*}
  L_{3} = L_{2}\oplus f_{k_{3}}(R_{2})& = R_{1}\oplus f_{k_{3}}(R_{2})\\
  & L_{0}\oplus f_{k_{1}}(R_{0})
\end{align*}

\subsection{Differentielle Analyse des DES mit vier Runden}

Ansatz: "`Eigenschaft 2"': Es gibt einige Differenzen~$D$, so dass es
"`viele"' Eingabepaare mit der Differenz~$D$ gibt, derart dass die
Ausgabedifferenzen übereinstimmen.

Beispiel: $S$-Box $S_{1}$ liefert für $D=A^{*} = (0011)$ in 6~von 8~Fällen die
Ausgabedifferenz $(011)$. $S_{1}(A)\oplus S_{1}(A')$. Das heißt: Für $A^{*} =
(0011)$ erwarten wir mit einer Wahrscheinlichkeit von $\frac{3}{4}$ die
Ausgabedifferenz $(011)$.

$S$-Box $S_{2}$ liefert für
$D=B^{*}=(1100)$ in 4~von 8~Fällen die Ausgabedifferenz $(010)$.
Das heißt: Für $B^{*}=(1100)$ erwarten wir mit einer Wahrscheinlichkeit von
$\frac{1}{2}$ die Ausgabedifferenz $(010)$.

Idee: Für Paare von Klartextblöcken $(L_{0}, R_{0})$ wird $(L_{0}', R_{0}')$
mit $L_{0}\oplus L_{0}' = (0011)$ und $R_{0}\oplus R_{0}' = (1100)$ erwarten
wir (beim richtigen Schlüssel) mit Wahrscheinlichkeit $\frac{3}{4}-\frac{1}{2}
= \frac{3}{8}$ die Ausgabedifferenz $(011\,010)$.

% 29.11.

\subsection{Analyse für vier Runden}

Ansatz: Nichtgleichverteilung der Output-Differenzen.\\
Idee: Versuchen eine Situation nach einer Runde zu erreichen, so dass wir dann
die 3-Rundenanalyse ansetzten können.

Dazu wählen wir Paare von Klartextblöcken $(L_{0}, R_{0})$ und $(L_{0}',
R_{0}')$ mit folgenden Eigenschaften:
\begin{enumerate}
 \item $R_{0}^{*} = R_{0}\oplus R_{0}' = (001\,100)$

  Bei der Bildung von $f_{K_{1}}(R_{0})$ und $f_{K_{1}}(R_{0}')$ passiert
  folgendes:
  \begin{gather*}
    D(R_{0})\oplus D(R_{0}') = (00111100)
  \end{gather*}
  Input für $S_{1}$ ist $(0011)$ für $S_{2}$ ist es $(1100)$.

  für $(0011)$ erwarten wir mit Wahrscheinlichkeit $\frac{3}{4}$ den Output
  $(011)$ bei $S_{1}$ und für $(1100)$ erwarten wir mit Wahrscheinlichkeit
  $\frac{1}{2}$ den Output $(010)$ bei $S_{2}$.

  Wir betrachten die Outputs der beiden $S$-Boxen als unabhängig und erwarten
  deshalb mit Wahrscheinlichkeit $\frac{3}{4}\cdot\frac{1}{2}=\frac{3}{8}$
  eine gesamte Output-Differenz von $f_{K_{1}}(R_{0})\oplus f_{K_{1}}(R_{0}') =
  (011\,010)$

 \item $L_{0}^{*} = L_{0} \oplus L_{0}' = (011\,010)$

  $R_{1}= L_{0}\oplus f_{K_{1}}(R_{0}), R_{1}' = L_{0}'\oplus
  f_{K_{1}}(R_{0}')$. Für den Fall $f_{K_{1}}(R_{0}) \oplus f_{K_{1}}(R_{0}')
  = (011\,010)$ ergibt sich:
  \begin{align*}
    R_{1}\oplus R_{1}' &= (L_{0}\oplus L_{0}') \oplus (f_{K_{1}}(R_{0}) \oplus
       f_{K_{1}}(R_{0}))\\
    & = (011\,010) \oplus (011\,010) = (000\,000)
  \end{align*}
  Da $L_{1} = R_{0}$ und $L_{1}' = R_{0}'$ gilt mit Wahrscheinlichkeit
  $\frac{3}{8}$, dass $(L_{1}, R_{1})$ und $(L_{1}', R_{1}')$ die Eigenschaft
  $R_{1}=R_{1}'$ haben und $(L_{1}\oplus R_{1})\oplus (L_{1}', R_{1}') =
  (R_{0}\oplus R_{0}', 0\dotso 0) = (001\,100, 000000)$.
\end{enumerate}

Strategie: Wähle Klartextpaare $(L_{0}, R_{0})$ und $(L_{0}', R_{0}')$ mit der
Summe $(011\,010, 001\,100)$ und bestimme dazu $(L_{4}, R_{4})$ und $(L_{4}',
R_{4}')$. Angenommen es ist so, dass $R_{1}\oplus R_{1}' = (000\,000)$ (das
gilt in 3 von 8~Fällen), dann haben wir die Ausgangssituation zur Analyse der
Runden 2, 3 und 4 als 3-Rundenanalyse.

Dort, wo die Annahme korrekt ist, erhalten wir eine Menge möglicher Schlüssel
für $K_{4}^{L}$ bzw. $K_{4}^{R}$. Dort, wo die Annahme falsch ist (die
Mehrzahl der Fälle), erhalten wir irgendwelche (zufälligen) Bitfolgen von
acht Bit.

\subsection{Die Sicherheit von DES}

\begin{enumerate}
 \item Die Größe des Schlüsselraums ist $2^{56}$ (es genügt aber
  $2^{55}$~Schlüssel zu testen), mit erschöpfender Suche war dies 1977 de facto
  nicht möglich.

  1997: setzt die RSA-Data-Security US-\$~10\,000 für die Dechiffrierung
  eines DES-Textes aus. Nach 5 Monaten war der Schlüssel ermittelt von \textsc{Ronald
  Vesper} -- durch organisiertes Parallelrechnen via Internet (25\,\%
  des Schlüsselraums wurde getestet.)

  1998: setzt die RSA-Data-Security wieder einen Preis aus und nach 39~Tagen
  war wieder der Schlüssel gefunden, obwohl 85\,\% des Schlüsselraums
  durchsucht wurden.

  1999: Electronic Frontier Foundation, 1536 parallel arbeitende Spezialchips
  benötigen im Schnitt $4\frac{1}{2}$~Tage um den kompletten Schlüsselraum zu
  durchsuchen.

  Quelle:
  \href{http://w2.eff.org/Privacy/Crypto/Crypto_misc/DESCracker/HTML/19980716_eff_des_faq.html#howsitwork}{FAQ
  der EFF zum DES-Cracker} und
\href{http://cryptome.org/jya/cracking-des/cracking-des.htm}{Cracking
  DES von der EFF}

  2006: Ein Team der Universitäten Kiel und Bochum entwickeln
  COPACOBANA. Mit Kosten von etwa US-\$~10\,000 berechnet die Maschine
  65~Milliarden DES"=Schlüssel pro Sekunde.
 \item Es gibt bei DES \highl[Schlüssel!schwacher]{schwache Schlüssel}, die für alle Runden den gleichen
  Rundenschlüssel erzeugen. Aber man kann diese auch einfach beim Einsatz
  vermeiden.

 \item Differentielle Kryptoanalyse funktioniert nicht, wenn man die $S$-Boxen
  geeignet wählt. (Nicht-Gleichverteilung vermeiden.)
\end{enumerate}

% 4.12.

\subsubsection{DES und differentielle Kryptoanalyse}

Die differentielle Kryptoanalyse war den Designern des DES bekannt und deshalb
folgte die Verteidigung. $S$-Boxen sind so konstruiert, dass für höchstens ein
Viertel der Zweiermengen $\{A, A'\}$ die Ausgabedifferenzen $S(A)\oplus S(A')$
übereinstimmen. Mit der Folge, dass für einen Chosen-Plaintext-Angriff
$2^{47}$ Klartextblöcke benötigt werden. Ein Known-Plaintext-Angriff benötigt
$2^{55}$ Klartextblöcke. Dies ist nicht wesentlich weniger als für einen
Brute-Force-Angriff benötigt werden: $2^{56}$. Deshalb sind es 16~Runden!

\subsubsection{DES und lineare Kryptoanalyse}

Von \textsc{M.\,Matsui} auf der Konferenz EUROCRYPT im Jahre 1993 vorgestellt
(\cite{matsui1}). War den Designern von DES nicht bekannt.

Weder die $S$-Boxen noch die gesamte Verschlüsselung beschreiben eine
lineare Abbildung. Damit sicher gegen solche Angriffe.

Die Idee der \highl[Kryptoanalyse!lineare]{linearen Kryptoanalyse} ist: Approximation der
Verschlüsselung durch lineare Abbildungen. Ansatz: Bilde \texttt{xor} für
einige Klartextbits und \texttt{xor} für einige Geheimtextbits und verknüpfe
beide mit \texttt{xor}. Das Ergebnis ist ein einzelnes Bit, das als die
\texttt{xor}-Verknüpfung einiger Schlüsselbits interpretiert wird. Das Ganze
wieder für eine bestimmte Wahrscheinlichkeit~$p$. Wenn
$p\ne\frac{1}{2}$, Ausnutzung der Asymmetrie (insbesondere ist der
fünfte $S$-Boxtyp des DES dafür anfällig) liefert eine Einschränkung
der Schlüssel.

In der Arbeit von \textsc{M.\,Matsui} wurde gezeigt, dass man für einen
Known-Plaintext-Angriff nur $2^{43}$~Paare, d.\,h. sie ist besser als die
\highl[Kryptoanalyse!differentielle]{differentielle Kryptoanalyse}.

\section{International Data Encryption Algorithm (IDEA)}

Der \highl{International Data Encryption Algorithm} (kurz
\highl{IDEA}) wurde zu Beginn der neunziger Jahre des letzten
Jahrhunderts in einer Gemeinschaftsarbeit von \textsc{James Massey}
und \textsc{Xueija Lai} von der ETH~Zürich und der Ascom Systec~AG
entwickelt. Die Ascom Systec~AG hält bis 2010 bzw. 2011 das Patent für
IDEA. Der Algorithmus kann jedoch für nichtkommerzielle Verwendung
kostenlos benutzt werden. Daher wird er unter anderem im
PGP"=Verfahren eingesetzt.

IDEA arbeitet mit der Blocklänge von 64~Bit, einer Schlüssellänge von 128~Bit
und 8~Runden zuzüglich einer Abschlussrunde. Durch den riesigen Schlüsselraum
wird ein Brute-Force-Angriff gegenüber DES wesentlich erschwert.

\begin{figure}[ht]
  \centering
  \input{idea.pdf_t}
  \caption{Blockschema für den Ablauf der $i$-ten Runde der IDEA"=Verschlüsselung}
  \label{fig:idea}
\end{figure}

Der Ablauf jeder Runde ist in \autoref{fig:idea} dargestellt. Jeder
Klartextblock wird in vier Teilblöcke zu je 16~Bit zerlegt, die durch
Verknüpfung mit 6~Rundenschlüsseln bzw. den Ergebnissen der Verknüpfungen in
vier Teilblöcke von je 16~Bit transformiert werden. Als Verknüpfung werden die
drei Operationen Exklusives"=Oder~($\oplus$), Addition modulo
$2^{16}$~($\boxplus$) und Multiplikation modulo $2^{16}+1$~($\odot$) eingesetzt.

% \begin{enumerate}
%  \item $\alpha_{1} = x_{1}\odot k_{i_{1}}$
%  \item $\alpha_{2} = x_{2}\boxplus k_{i_{2}}$
%  \item $\alpha_{3} = x_{3}\boxplus k_{i_{3}}$
%  \item $\alpha_{4} = x_{4}\odot k_{i_{4}}$
%  \item $\beta_{1} = \alpha_{1} \oplus \alpha_{3}$
%  \item $\beta_{2} = \alpha_{2} \oplus \alpha_{4}$
%  \item $\gamma = \beta_{1} \odot k_{i_{5}}$
%  \item $\delta = \beta_{2} \boxplus \gamma$
%  \item $\epsilon = \delta \odot k_{i_{6}}$
%  \item $\zeta = \gamma \boxplus \epsilon$
%  \item $x_{1}' = \alpha_{1} \oplus \epsilon$
%  \item $x_{2}' = \alpha_{3} \oplus \epsilon$
%  \item $x_{3}' = \alpha_{2} \oplus \zeta$
%  \item $x_{4}' = \alpha_{4} \oplus \zeta$
% \end{enumerate}

Nach der 8.\,Runde folgt eine Schlussrunde:
\begin{align*}
  x_{1}' &= x_{1}\odot k_{9_{1}} &
     x_{2}' &= x_{2}\boxplus k_{9_{2}} &
  x_{3}' &= x_{3}\boxplus k_{9_{3}} &
     x_{4}' &= x_{4}\odot k_{9_{4}}
\end{align*}

Da IDEA andere algebraische Operationen einsetzt, wird er nicht als
Feistel-Chiffre bezeichnet. Dennoch ist er so konstruiert, dass die
Verschlüsselungsfunktion auch als Entschlüsselungsfunktion verwendet
werden kann.

Die Sicherheit von IDEA ist auf der Unverträglichkeit der drei
unterschiedlichen arithmetischen Operationen begründet. Es ist zwar eine
Klasse von \highl[Schlüssel!schwacher]{schwachen Schlüsseln} mit
$2^{65}$~Elementen bekannt, dennoch ist der Algorithmus durch die komplexen
Runden sicher gegen lineare und differentielle Kryptoanalyse.\cite{idea-save}

\section{RC-Familie}

In den 1990ern wurden von \textsc{Ronald Rivest} von der RSA Data Security eine Reihe
von Verschlüsselungsverfahren entwickelt, die als
\highl[RC-Familie]{RC"=Familie} (Ron's Code oder Rivest's Cipher)
zusammengefasst werden.\cite[Abs.\,3.6.2--4]{rsafaq}

\highl{RC2} bezeichnet eine Feistelchiffre, die mit 18~Runden und einer
Klartextblocklänge von 64~Bit arbeitet. Die Schlüssellänge muss ein Vielfaches
von acht sein und kann zwischen einschließlich 8 und 128~Bit gewählt werden.

RC2 wurde 1987 als Ersatz für DES entwickelt und ist als solcher auch
schneller und, bei geeigneter Wahl des Schlüssels, sicherer als DES. RC2
wurde, bis es 1996 von einem Unbekannten im Usenet veröffentlicht wurde,
geheim gehalten.

\highl{RC5} wurde 1994 ebenfalls für die RSA Data Security entwickelt und
weist ungewöhnlich viele Freiheiten bei der Wahl der Parameter auf. Die
Blocklänge kann 32, 64 oder 128~Bit sein. Die Schlüssellänge kann von 0 bis
2040~Bit und die Rundenanzahl von 0 bis 255 gewählt werden.

Es gibt drei Operationen: Schlüsselerweiterung, Ver- und Entschlüsselung. Bei
der Schlüsselerweiterung wird in Abhängigkeit von der Rundenanzahl eine
Tabelle für die Ver"~/""Entschlüsselung erzeugt. Die Ver"~/""Entschlüsselung
arbeitet mit Addition, exklusiven Oder und Bitrotation. Durch einen extrem
einfachen Aufbau ist der RC5"=Algorithmus leicht zu implementieren und zu
verifizieren.
\begin{align*}
  x_{1}' &= rot(x_{1} \oplus x_{2}, x_{2}) \boxplus K_{1} &
  x_{2}' &= rot(x_{2} \oplus x_{1}', x_{1}') \boxplus  K_{2}
\end{align*}

RC5 ist sicher gegen differentielle und lineare Kryptoanalyse.\cite{rc5save}

Um die Kriterien für die Ausschreibung des Advanced Encryption Standards zu
erfüllen, wurde RC5 etwas verändert und als \highl{RC6} eingereicht. Die
Blockgröße, Schlüssellänge und Rundenanzahl können aus den selben Bereichen wie
bei RC5 gewählt werden. RC6 wurde 1998 veröffentlicht und gelangte auch in die
letzte Ausscheidungsrunde für den AES.

% 6.12.

\section{Blowfish und Twofish}

Blowfish (1994), Twofish (1998) von Bruce Schneier

\begin{description}
 \item[Blowfish] variable Schlüssellänge (bis 448~Bit), $S$-Boxen
  schlüsselabhängig, 16~Runden, Blocklänge~64. Trotz aufwendiger $S$-Boxen
  ein schnell zu implementierender Algorithmus (\texttt{xor} und Addition von
  32-Bitwerten)

 \item[Twofish] Runde der letzten 5 AES-Kandidaten. Schlüssellänge: 128, 192,
  256, Blocklänge: 64, $8\times8$ $S$-Boxen, arithmetische Operationen in
  $\F_{2^{8}}$ endlicher Körper der Ordnung $2^{8}$ (anstelle von $\Z_{2}=\F_{2}$)
\end{description}

\section{Sonstige Blockchiffren}

\begin{description}
 \item[SAFER] 1995, Massey
 \item[CAST] 1990, 1997 -- wird bei PGP benutzt
 \item[Skipjack] NSA, 1990
 \item[KASUMI] Weiterentwicklung von MISTY, wird zur Verschlüsselung bei UMTS
  eingesetzt.
\end{description}

\section{Exkurs über endliche Körper}
\label{sec:endl-koerper}

\subsection{Endliche Körper von Primzahlordnung}

Wir wissen bereits aus \autoref{sec:restklassen}, dass sich die ganzen Zahlen
in Äquivalenzklassen modulo~$m$ zerlegen lassen:
\begin{gather*}
  \Z_{m} \coloneq \Z_{\nicefrac{}{\equiv (m)}}
     = \{ [0]_{m}, [1]_{m}, \dotsc, [m-1]_{m} \}
     = \{0,1,\dotsc,m-1\}
\end{gather*}
Damit ergibt sich für $m>1$ ein Ring $[\Z_{m}, +,\cdot]$ mit dem Nullelement
$0 \coloneq [0]_{m}$, dem Einselement $1 \coloneq [1]_{m}$ und insgesamt $\abs{\Z_{m}}=m$
Elementen. Ein Element $a\in\Z_{m}$ heißt genau dann Einheit, wenn es ein inverses
Element $b$ mit $a\cdot b=1$ gibt. Es gilt: $a$ ist Einheit in $\Z_{m}$ \gdw
$\ggT(a,m) = 1$ (\autoref{lem:5}).

$\Z_{m}^{*}$ bezeichnet die \highl[Einheiten!Menge der]{Menge der Einheiten} in $\Z_{m}$, also
gilt: $\abs{\Z_{m}^{*}} = \phi(m)$ (\autoref{lem:5}). Wenn $m=p$ eine Primzahl
ist, dann ist $\Z_{p}^{*} = \{1, 2,\dotsc,p-1\}$ (da $\phi(p)=p-1$) und
$\Z_{p}$ ein endlicher Körper der Ordnung~$p$.

\subsection{Polynomringe}

Es sei $[R, +,\cdot]$ ein (endlicher) Ring, z.\,B. $[\Z_{m}, +,\cdot]$, und
$x$ ist ein Symbol, das nicht im Ring vorkommt ($x\notin R$). Wir definieren
\highl[Polynom]{Polynome} vom Grad~$k$, mit $r_{i}\in R$ für $i=0,\dotsc,k$, wobei
$r_{k}\ne0$ ist, wie folgt:
\begin{gather*}
  p(x) \coloneq r_{k}\cdot x^{k} + r_{k-1}\cdot x^{k-1} + \dotsb+ r_{1} x^{1} + r_{0}
\end{gather*}
$R[x]$ bezeichnet die \highl[Polynom!Menge aller]{Menge aller Polynome} in $x$ über $R$.

Die Addition und Multiplikation von zwei Polynomen erfolgt wie üblich
komponentenweise. Damit bildet die Struktur $[R[x], +, \cdot]$ einen
(abzählbar unendlichen) \highl{Polynomring}.

Ein Polynom~$p\in R[x]$ heißt genau dann
\highl[Polynom!reduzibles]{reduzibel}\index{reduzibel}, wenn es zwei
Polynome~$r,s\in R[x]$ vom Grad größer 0 gibt, so dass man $p$ als Produkt von
$r$ und $s$ schreiben kann; $p(x) = r(x)\cdot s(x)$.

Ein Polynom~$p\in R[x]$ heißt genau dann
\highl[Polynom!irreduzibles]{irreduzibel}\index{irreduzibel}, wenn es nicht reduzibel
ist, d.\,h. es keine zwei Polynome $r,s\in R[x]$ gibt, so dass $p=r\cdot s$
ist.

Man kann sich die Bedeutung von irreduzibel wie die von prim für ganze Zahlen
vorstellen. Eine Zahl heißt prim, wenn sie keine (nichttrivialen) Teiler
besitzt und analog bezeichnet man ein Polynom als irreduzibel, wenn es sich
nicht als Produkt (nicht trivialer) Polynome darstellen lässt.

% 13.12.

\subsection{\texorpdfstring{$\F_{p^{k}}$}{Fpk} endlicher Körper der Ordnung
  \texorpdfstring{$p^{k}$}{pk}}

Analog zur Zerlegung der ganzen Zahlen in Restklassen anhand eines Moduls
definiert man die Zerlegung der Menge aller Polynome (mit Koeffizienten aus
$\Z_{p}$; $p$~prim) in Restklassen, wobei man die Faktormenge (Menge der
Restklassen) mit $\F_{p^{k}}$ identifiziert.

Dazu benötigt man ein irreduzibles Polynom~$m\in\Z_{p}[x]$ vom Grad~$k$, das
als \highl{Modulpolynom} dient. Zwei Polynome~$s,t\in\Z_{p}[x]$ sind in der
gleichen Restklasse, wenn sie bei der Division durch $m$ den gleichen
Rest~$r\in\Z_{p}[x]$ vom Grad kleiner~$k$ lassen:
\begin{align*}
  s(x) &= a(x)\cdot m(x) + r(x)\qquad\text{und}\qquad t(x) =b(x)\cdot m(x)+r(x)\\
  [r]_{m} &= \Set{ r(x) + l(x)\cdot m(x) | l\in\Z_{p}[x]}\\
  \nicefrac{\Z_{p}[x]}{m(x)} &= \Set{ [r(x)]_{m(x)} | r(x)\in \Z_{p}[x],
     r\text{~vom Grad $<$ dem Grad von $m$}}
\end{align*}
Das Polynom~$r$ heißt \highl{Repräsentant} von $s$ und $t$ in $\F_{p^{k}}$ und
hat die Form
\begin{gather*}
  r(x) = \rho_{k-1} x^{k-1} + \rho_{k-1} x^{k-2} + \dotsb+ \rho_{1} x + \rho_{0}
\end{gather*}
mit den Koeffizienten $\rho_{k-1},\rho_{k-2},\dotsc,\rho_{1},\rho_{0}\in
\Z_{p}$. Es gibt also $p^{k}$ verschieden Polynome dieser Form, also hat die
Menge $\nicefrac{\Z_{p}[x]}{m(x)}$ die Mächtigkeit $p^{k}$.
\begin{gather*}
  \F_{p^{k}} = \nicefrac{\Z_{p}[x]}{m(x)}
\end{gather*}

Für das Rechnen mit diesen Restklassen gilt: Die Addition~$\oplus$ und die
Multiplikation~$\odot$ erfolgen wie üblich bei Polynomen, nur dass bei der
Multiplikation noch eine Division durch den Modul $m(x)$ angeschlossen wird,
wobei der Rest das Ergebnis ist.

Die Multiplikation~$\odot$ hängt also von dem Modulpolynom~$m(x)$ ab. Jedoch
sind die Körper $\F_{p^{k}}[m(x)]$ und $\F_{p^{k}}[m'(x)]$ isomorph zu einander.
Es ist also völlig egal, welches Modulpolynom man wählt, die grundlegende
mathematische Struktur bleibt die gleiche. Daher kann man auch allgemein vom
$\F_{p^{k}}$ sprechen und muss nicht sagen, mit welchem Modulpolynom man
konkret arbeitet.

Bei AES verwendet man $p=2, k=8$, d.\,h. wir betrachen $\F_{2^{8}} = \F_{256}$
mit Koeffizienten aus $\Z_{2}$, und das Modulpolynom
\begin{gather*}
  m(x) = x^{8} + x^{4} + x^{3} + x +1
\end{gather*}

\begin{bsp}
  \label{bsp:1}
  Gegeben sind die beiden Polynome~$p,q\in\F_{2^{8}}$ mit $p(x)= x^{6} + x^{4}
  + x^{2} + x + 1$ und $q(x)= x^{7}+x+1$ und gesucht ist das
  Produkt $p\odot q$ gemäß obiger Definition.

  Zuerst die übliche, komponentenweise Multiplikation von Polynomen:
  \begin{multline*}
    (x^{6} + x^{4} + x^{2} + x + 1) \odot (x^{7}+x+1)\\
    \begin{array}{*{13}{r@{\;}}}
      = &x^{13} &+ x^{11} &+ x^{9} &+ x^{8} &+ x^{7}\\
      +&&&&&+ x^{7} &&+ x^{5} &&+ x^{3} &+ x^{2} &+ x\\
      +&&&&&&+ x^{6} &&+ x^{4} &&+ x^{2} &+ x &+1\\
      \cline{2-13}\\[-3mm]
      = &x^{13} &+ x^{11} &+ x^{9} &+ x^{8} &&+ x^{6} &+ x^{5} &+ x^{4}
      &+ x^{3} &&&+ 1
    \end{array}
  \end{multline*}
  (Hinweis: Die Koeffizienten $x^{7}, x^{2}$ und $x$ entfallen, da
  $1+1\pmod{2}\equiv0$ ist.)

  Jetzt muss dieses Polynom noch reduziert werden:
  \begin{gather*}
    \begin{array}{*{11}{r@{\;}}l}
      &(x^{13} &+ x^{11} &+ x^{9} &+ x^{8} &+ x^{6} &+ x^{5} &+ x^{4} &+ x^{3} &+ 1&)& :
      (x^{8} + x^{4} + x^{3} + x + 1)
      = \underbrace{x^{5} + x^{3}}_{=q(x)}\\[-4mm]
      \oplus\,&(x^{13} &&+ x^{9} &+ x^{8} &+ x^{6} &+x^{5}&&&&)\\
      \cline{1-11}\\[-3mm]
      &&x^{11} &&&&&+ x^{4} &+ x^{3} &+ 1\\
      &&\oplus\,(x^{11} &+ x^{7} &+ x^{6} &&&+ x^{4} &+x^{3}&&)\\
      \cline{3-11}\\[-3mm]
      &&&x^{7} &+ x^{6} &&&&&+1&&= r(x)
    \end{array}
  \end{gather*}

  Also ist
  \begin{gather*}
    (x^{6} + x^{4} + x^{2} + x + 1) \odot (x^{7} + x +1) = x^{7} + x^{6} +1
  \end{gather*}
\end{bsp}

Da es für die Multiplikation nur 65\,536 verschiedene Kombinationen
gibt, kann man diese auch vorher berechnen und in einer $256\times256$-Tabelle
abspeichern.

\subsection{Darstellung der Elemente aus \texorpdfstring{$\F_{256}$}{F256}}

\begin{enumerate}
 \item Darstellung als Polynom
  \begin{gather*}
    p(x) = b_{7} x^{7} + b_{6} x^{6} + \dotsb+ b_{1} x + b_{0}
  \end{gather*}
  mit $b_{7},\dotsc, b_{0} \in \{0,1\}$.

 \item Darstellung als eine Folge von Bits $(b_{7}, b_{6}, \dotsc, b_{0})$,
  wobei $b_{7},\dotsc, b_{0}$ die Koeffizienten aus der Polynomdarstellung
  sind.

  Für die Zahlen in \autoref{bsp:1} lautet die Darstellung
  \begin{gather*}
    (0,1,0,1,0,1,1,1) \odot (1,0,0,0,0,0,1,1) = (1,1,0,0,0,0,0,1)
  \end{gather*}

 \item Darstellung als zweistellige Hexadezimalzahl der Bitfolgen

  In unserem \autoref{bsp:1}: $57\odot 83 = C1$
\end{enumerate}

\subsection{Der erweiterte euklidische Algorithmus}

Mit dem \highl[Algorithmus!erweiterter euklidischer]{erweiterten euklidischen Algorithmus} bestimmt man zusätzlich
zum größten gemeinsamen Teiler zweier Zahlen~$a$ und $b$ zwei Zahlen~$u$ und
$v$, die folgende Gleichung erfüllen
\begin{gather}
  \label{eq:erw-euk-algo}
  \ggT(a,b) = u\cdot a+v\cdot b
\end{gather}

\begin{verbatim}
Eingabe: a, b;
begin
    b[0] := a; b[1] := b;
    u[0] := 1; v[0] := 0;
    u[1] := 0; v[1] := 1;
    i := 1;
    while not teilt(b[i], b[i-1]) do
    begin
        q[i] := b[i-1] div b[i];
        b[i+1] := b[i-1] - q[i] * b[i];
        u[i+1] := u[i-1] - q[i] * u[i];
        v[i+1] := v[i-1] - q[i] * v[i];
        i := i + 1;
    end
end
Ausgabe: ggT := b[i], u := u[i], v := v[i];
\end{verbatim}

\begin{lemma}\label{lem:6}
  Die oben gemachte Aussage, dass der erweiterte euklidische Algorithmus zwei
  Zahlen~$u$ und $v$ bestimmt, die die Gleichung $\ggT(a,b) = u\cdot a+v\cdot
  b$ erfüllen, ist korrekt.

  \begin{proof}
    Per Induktion können wir zeigen, dass für alle Schritte~$i$ gilt:
    $b_{0}\cdot u_{i} + b_{1}\cdot v_{i} = b_{i}$.

    Der Induktionsanfang für $i=1$ ist klar. Also gilt die Aussage
    für den $(i-1)$-ten und $i$-ten~Schritt. Für den $(i+1)$-ten~Schritt
    folgt dann
    \begin{align*}
      b_{0} u_{i+1} + b_{1} v_{i+1} &= b_{0} (u_{i-1} - q_{i} u_{i}) + b_{1}
         (v_{i-1}-q_{i}v_{i})\\
      &= (b_{0}u_{i-1} + b_{1} v_{i-1}) - q_{i} (b_{0} u_{i} + b_{1}v_{i})\\
      &= b_{i-1} - q_{i}b_{i} = b_{i+1}
    \end{align*}
  \end{proof}
\end{lemma}

% 18.12.

\begin{bsp}
  Seien $a=220=b_{0}$ und $b=26=b_{1}$ (ganze Zahlen) gegeben.
  \begin{gather*}
    \begin{array}{c|cccc}
      i& q_{i} & b_{i+1} & u_{i+1}& v_{i+1}\\
      \hline
      1& 8& 200-8\cdot 26=12& 1-8\cdot0=1& 0-8\cdot1=-8\\
      2& 2& 26-2\cdot 12=2& 0-2\cdot1=-2& 1-2\cdot(-8) = 17\\
    \end{array}
  \end{gather*}
  Abbruch im 3.\,Schritt, da $2\mid12$. Der größte gemeinsame Teiler von 220
  und 26 ist also 2 und es gilt:
  \begin{gather*}
    2 = -2\cdot 220 + 17\cdot 26 = -440 + 442
  \end{gather*}
\end{bsp}

\begin{bsp}
  \label{bsp:2}
  Seien $a=2668=b_{0}$ und $b=157=b_{1}$ gegeben.
  \begin{gather*}
    \begin{array}{c|cccc}
      i& q_{i} & b_{i+1} & u_{i+1}& v_{i+1}\\
      \hline
      1& 16& 2668-17\cdot 157=156& 1-16\cdot0=1& 0-16\cdot1=-16\\
      2& 1& 157-1\cdot 156=1& 0-1\cdot1=-1& 1-1\cdot(-16) = 17\\
    \end{array}
  \end{gather*}
  Abbruch im 3.\,Schritt, da $1\mid156$. 2668 und 157 sind also teilerfremd
  und es gilt:
  \begin{gather*}
    1 = -1\cdot 2668 + 17\cdot 157 = -2668 + 2669
  \end{gather*}
\end{bsp}

Mit Hilfe des erweiterten euklidischen Algorithmus' lässt sich zu einem
Element des $\F_{256}$ das \highl[Inverse!multiplikative]{multiplikative Inverse} bestimmen. Dazu muss
man den \highl[Algorithmus!erweiterter euklidischer]{erweiterten euklidischen Algorithmus} auf Polynome anwenden,
was aber keine Änderungen am Algorithmus selbst erfordert. Man muss nur
beachten, dass man für die einzelnen Operationen ($+$, $-$, $\cdot$ und $div$)
die entsprechenden Operationen für den $\F_{256}$ ($\oplus$,
$\oplus$\footnote{Wenn man sich die Verknüpfungstabellen für $\oplus$, $-$ und
\texttt{xor} aufschreibt, sieht man, dass alle drei Operationen äquivalent sind.},
$\odot$ und Polynomdivision) verwendet.

Es sei $p(x)\in\F_{256}$ mit $p(x)\ne0$. Da $m(x)$ irreduzibel ist, sind
$p(x)$ und $m(x)$ teilerfremd zu einander, d.\,h. der größte gemeinsame Teiler
von $p(x)$ und $m(x)$ ist 1. Also liefert der erweiterte euklidische
Algorithmus nach \autoref{eq:erw-euk-algo} zwei Polynome $u(x)$ und $v(x)$
mit der Eigenschaft, dass sich 1 als
\begin{gather*}
  1 = p(x) u(x) + m(x) v(x)
\end{gather*}
darstellen lässt. Daraus folgt: $p(x)\odot u(x) =1$, $u$ ist also das Inverse
zu $p$ bezüglich~$\odot$.

\begin{bsp}
  Gegeben seien $a(x) = m(x) = x^{8} + x^{4} + x^{3} + x +1 = b_{0}$ und
  $b(x) = x^{7} + x^{6} + x^{3} + x + 1 = b_{1}$. (Elemente des $\F_{256}$)

  \begin{enumerate}[1.\,{Schleifendurchlauf}]
   \item $(x^{8} + x^{4} + x^{3} + x + 1) : (x^{7} + x^{6} + x^{3} + x +1) =x+1$\\
    $\oplus (x^{8} +x^{7} + x^{4} + x^{2} +x)$\\
    ---\\
    $x^{7} + x^{3} + x^{2} + 1$\\
    $\oplus (x^{7} + x^{6} + x^{3} +x +1)$\\
    ---\\
    $x^{6} + x^{2} + x$

    Es ergibt sich also:
    \begin{align*}
      q_{1}(x) &= x + 1\\
      b_{2}(x) &= b_{0}(x) - q_{1}(x)\cdot b_{1}(x) = x^{8} + x^{4} + x^{3} +
         x +1 - (x+1)\\
         &\qquad\cdot(x^{7} + x^{6} + x^{3} + x + 1) = x^{6}+x^{2}+x\\
      u_{2}(x) &= u_{0}(x) - q_{1}(x)\cdot u_{1}(x) = 1 - (x+1)\cdot0 = 1\\
      v_{2}(x) &= v_{0}(x) - q_{1}(x)\cdot v_{1}(x) = 0 - (x+1)\cdot1 = x+1
    \end{align*}

   \item $(x^{7} + x^{6} + x^{3} + x + 1) : (x^{6} + x^{2} + x) = x+1$\\
    $\oplus(x^{7} + x^{3} + x^{2})$\\
    ---\\
    $x^{6} + x^{2} + x + 1$\\
    $\oplus(x^{6} + x^{2} + x)$\\
    ---\\
    1

    Die Zwischenergebnisse:
    \begin{align*}
      q_{2}(x) &= x+1\\
      b_{3}(x) &= b_{1}(x) - q_{2}(x)\cdot b_{2}(x)\\
      &= (x^{7} +x^{6} +x^{3} +x +1) - (x+1)\cdot (x^{6}+x^{2}+x) = 1\\
      u_{3}(x) &= u_{1}(x) - q_{2}(x)\cdot u_{2}(x)
         = 0 - (x+1)\cdot 1 = x+1\\
      v_{3}(x) &= v_{1}(x) - q_{2}(x)\cdot v_{2}(x)
         = 1 - (x+1)\cdot (x+1) = x^{2}
    \end{align*}
  \end{enumerate}

  Es gilt also nach \autoref{eq:erw-euk-algo}
  \begin{align*}
    u(x)\cdot a(x) + v(x) \cdot b(x)
       &= (x+1) (x^{8} +x^{4} +x^{3} +x +1) + x^{2} (x^{7} +x^{6} +x^{3} +x +1)\\
       &= x^{9} +x^{5} +x^{4} +x^{2} +x
          +x^{8} +x^{4} +x^{3} +x +1\\
         &\qquad +x^{9} +x^{8} +x^{5} +x^{3} +x^{2} = 1
  \end{align*}
  woraus folgt, dass $v(x) a(x) = u(x) m(x) + 1$. Also ist $v(x) \odot a(x) =
  1$ und somit ist $v$ das Inverse bzgl. $\odot$ zu $a$: $v(x) = a^{-1}(x)$.

  Oder als Bitfolgen geschrieben: $a(x) = (1100\,1011)$ und $a^{-1}(x) =
  (0000\,0100)$
\end{bsp}

\subsection{Polynome über dem Körper \texorpdfstring{$\F_{256}$}{F256}}
\label{sec:f256x}

Wir betrachten den Polynomring $\nicefrac{\F_{256}[x]}{(x^{4}+1)}$. Die
Elemente sind Polynome höchstens dritten Grades.
\begin{gather*}
  c(x) = c_{3} x^{3} + c_{2} x^{2} + c_{1} x + c_{0}
\end{gather*}
dabei sind die Koeffizienten~$c_{i}\in\F_{256}$ und erlauben die folgende
Darstellung:

\begin{bsp}
  \begin{enumerate}
   \item als Polynom: $c(x) = 01 x^{3} + 03 x^{2} + A1 x + 02$
   \item Binär: $[0000\,0001, 0000\,0011, 1010\,0001, 0000\,0010]$
   \item Hexadezimal: $[01, 03, A1, 02]$
  \end{enumerate}
\end{bsp}

Für das Rechnen mit den Elementen aus $\nicefrac{\F_{256}[x]}{(x^{4}+1)}$ gilt
wieder, dass die Addition $a\oplus b$ komponentenweise mit \texttt{xor} erfolgt
\begin{gather*}
  a(x)\oplus b(x) = (a_{3}\oplus b_{3}) x^{3} + (a_{2} \oplus b_{2}) x^{2} +
     (a_{1}\oplus b_{1}) x + (a_{0} \oplus b_{0})
\end{gather*}
und die Multiplikation $a\otimes b$ in zwei Schritten abläuft
\begin{enumerate}
 \item zuerst die Multiplikation mit einem Polynom $c(x) = a(x)\odot b(x) = c_{6} x^{6} + \dotsb+
  c_{1} x^{1} + c_{0}$, wobei folgendes gilt
  \begin{align*}
    c_{6}& = (a_{3}\odot b_{3})\\
    c_{5}& = (a_{3}\odot b_{2})\oplus (a_{2}\odot b_{3})\\
    c_{4}& = (a_{3}\odot b_{1})\oplus (a_{2}\odot b_{2})\oplus
       (a_{1}\odot b_{3})\\
    c_{3}& = (a_{3}\odot b_{0})\oplus (a_{2}\odot b_{1})\oplus
       (a_{1}\odot b_{2})\oplus (a_{0}\odot b_{3})\\
    c_{2}& = (a_{2}\odot b_{0})\oplus (a_{1}\odot b_{1})\oplus
       (a_{0}\odot b_{2})\\
    c_{1}& = (a_{1}\odot b_{0})\oplus (a_{0}\odot b_{1})\\
    c_{0}& = (a_{0}\odot b_{0})
  \end{align*}

 \item Anschließend muss noch eine Faktorisierung modulo $(x^{4}+1)$
  durchgeführt werden. Entweder führt man die drei Schritte der
  Polynomdivision $c(x) : (x^{4}+1)$ durch oder man verwendet die Eigenschaft
  $x^{i}\pmod{x^{4}+1} = x^{i\pmod{4}}$ und erhält so das modulare Produkt
  \begin{align*}
    d(x) &= a(x)\odot b(x) \pmod{x^{4}+1}
       = c_{6} x^{6} + \dotsb+ c_{1} x^{1} + c_{0} \pmod{x^{4}+1}\\
    &= c_{6} x^{2} + c_{5} x + c_{4} + c_{3} x^{3} + c_{2} x^{2} + c_{1} x +
       c_{0}\\
    &= \underbrace{c_{3}}_{=d_{3}} x^{3}
       + \underbrace{(c_{6}\oplus c_{2})}_{=d_{2}} x^{2}
       + \underbrace{(c_{5}\oplus c_{1})}_{=d_{1}} x
       + \underbrace{(c_{4}\oplus c_{0})}_{=d_{0}}
  \end{align*}
  mit den Koeffizienten
  \begin{align*}
    d_{3}& = (a_{3}\odot b_{0}) \oplus (a_{2}\odot b_{1}) \oplus
       (a_{1}\odot b_{2}) \oplus (a_{0}\odot b_{3})\\
    d_{2}& = (a_{2}\odot b_{0})\oplus (a_{1}\odot b_{1})\oplus
       (a_{0}\odot b_{2}) \oplus (a_{3}\odot b_{3})\\
    d_{1}& = (a_{1}\odot b_{0})\oplus (a_{0}\odot b_{1}) \oplus
       (a_{3}\odot b_{2})\oplus (a_{2}\odot b_{3})\\
    d_{0}& = (a_{0}\odot b_{0})\oplus (a_{3}\odot b_{1})\oplus
       (a_{2}\odot b_{2})\oplus (a_{1}\odot b_{3})
  \end{align*}

  Matrixschreibweise:
  \begin{gather*}
    \begin{pmatrix}
      d_{3}\\
      d_{2}\\
      d_{1}\\
      d_{0}
    \end{pmatrix} =
       \begin{pmatrix}
         a_{0}& a_{1}& a_{2}& a_{3}\\
         a_{3}& a_{0}& a_{1}& a_{2}\\
         a_{2}& a_{3}& a_{0}& a_{1}\\
         a_{1}& a_{2}& a_{3}& a_{0}
       \end{pmatrix} \cdot
       \begin{pmatrix}
         b_{3}\\
         b_{2}\\
         b_{1}\\
         b_{0}
       \end{pmatrix}
  \end{gather*}
\end{enumerate}

\begin{bsp}
  \begin{gather*}
    [00,00,00,01] \otimes [47, 08, 1F, 2B] = [47, 08, 1F, 2B]\\
    [01,00,00,00]\otimes [2B, 1F, 08, 47] = [47, 2B, 1F, 08]
  \end{gather*}
\end{bsp}

Der Ring $R=\nicefrac{\F_{256}[x]}{(x^{4}+1)}$ ist kein Körper, d.\,h. nicht
jedes Element $c(x)\in R$ besitzt ein Inverses. AES
benutzt
\begin{gather*}
  c(x) = 03 x^{3}+ 01 x^{2} + 01 x + 02
\end{gather*}
mit dem Inversen $c^{-1}(x) = 0B x^{3} + 0D x^{2} + 09 x + 0E$

\section{Der Advanced Encryption Standard -- AES}

\subsection{Historischer Abriss}
\begin{description}
 \item[1997:] macht die US-Standardisierungsbehörde eine \emph{öffentliche}
  Ausschreibung für  ein Verfahren als Nachfolger von DES. Forderungen an das
  Verfahren: öffentlich, lizenzfrei, weltweit verfügbar, schneller als
  Triple-DES. Vorgaben: Blocklänge min. 128 und Schlüssellänge von 128, 192,
  256.

 \item[1998:] Wurden 15~Verfahren eingereicht. (darunter auch MAGENTA von der
  deutschen Telekom, das schon in der Präsentation gebrochen wurde)

 \item[1999:] 5~Kandidaten in der Endrunde: Twofish (Platz~2, weil $\F_{256}$ und
  nicht $\F_{2}$), RC6, MARS (IBM, David Coppersmith), Serpent (ähnlich DES,
  über 32 Runden, Platz 3), Rijndael

 \item[2000:] Wird Rijndael als Sieger bekannt gegeben.

 \item[2002:] Rijndael wird als AES (FIPS~197, siehe~\cite{fips197}) veröffentlicht.
\end{description}

Durch die Forderung, dass AES öffentlich sein soll, ist der mathematische
Hintergrund für AES bekannt, während z.\,B. der Grund für die Wahl der
$S$-Boxen bei DES unbekannt ist. --~IBM kannte bereits seit den 1970ern die
differentielle Kryptoanalyse.~-- Damit ist auch für jedermann nachprüfbar, ob
AES korrekt arbeitet.

\subsection{Beschreibung des Verfahrens von Rijndael}

Das Verfahren von Rijndael ist eine iterierte Blockchiffre, deren Block- und
Schlüssellänge unabhängig voneinander 128, 192 oder 256~Bit betragen können.
Davon abhängig ergibt sich die Rundenzahl als 10, 12 oder 14~Runden. Das
Verfahren ist keine Feistel-Chiffre, weil es eine ganz andere Struktur hat.
Die Ein- und Ausgabe jeder Runde wird nicht nur in zwei, sondern min.\,16~Blöcke
geteilt, die alle auf die gleiche Weise transformiert werden.

Für AES wurden 128~Bit als Blocklänge festgelegt, woraus sich 10~Runden für
einen 128~Bit Schlüssel, 12~Runden bei einem 192~Bit Schlüssel und 14~Runden
für einen 256~Bit langen Schlüssel ergeben. Aus dem Schlüssel werden
$r+1$~Rundenschlüssel von je 128~Bit Länge erzeugt, wobei $r$ die Rundenzahl
ist. Jede Runde bis auf die letzte besteht aus vier Schritten
(\autoref{fig:aes}):
\begin{enumerate}
 \item \highl{AddRoundKey} -- Verknüpfung mit dem Rundenschlüssel
 \item \highl{SubBytes} -- nichtlineare Transformation als Schutz vor
  differenzieller und linearer Kryptoanalyse
 \item \highl{ShiftRows} -- Diffusion der Bits innerhalb einer Zeile
 \item \highl{MixColumns} -- Diffusion der Bits innerhalb einer Spalte
\end{enumerate}
In der letzten Runde wird statt dem MixColumns-Schritt nochmal ein
AddRoundKey-Schritt mit dem $(r+1)$-ten~Schlüssel vorgenommen.

% 20.12.

\subsection{Notationen für AES}

Es werden Bytes von je 8~Bit verwendet, die somit als Elemente des Körpers
$\F_{256}$ interpretiert werden können; $a=a_{7}a_{6}\dotso a_{0}\in\F_{256}$.
Ein Eingabeblock~$S$ von 128~Bit Länge wird in eine Folge von 16~Bytes
zerlegt $S = a^{(0)}a^{(1)}\dotso a^{(14)}a^{(15)}$, die auf eine
$4\times4$-Matrix spaltenweise übertragen werden:
\begin{gather*}
  S =
     \begin{pmatrix}
       a^{(0)}& a^{(4)}& a^{(8)}& a^{(12)}\\
       a^{(1)}& a^{(5)}& \hdots\\
       a^{(2)}& \vdots& \ddots \\
       a^{(3)}& a^{(7)}& a^{(11)}& a^{(15)}
     \end{pmatrix} =
     \begin{pmatrix}
       a^{(0,0)}& a^{(0,1)}& a^{(0,2)}& a^{(0,3)}\\
       a^{(1,0)}& a^{(1,1)}& \hdots\\
       a^{(2,0)}& \vdots & \ddots\\
       a^{(3,0)}& a^{(3,1)}& a^{(3,2)}& a^{(3,3)}
     \end{pmatrix}
     = (a^{z,s})_{4\times4}
\end{gather*}

\begin{figure}
  \centering
  \input{aes-runde.pdf_t}
  \caption{Schema für die $i$-ten~Runde des AES}
  \label{fig:aes}
\end{figure}

Die Eingabe des ersten Schritts (\highl{AddRoundKey}) in der $i$-ten~Runde wird mit
$S_{i,a}$ bezeichnet und das Ergebnis des ersten Schritts wird als Eingabe des
zweiten Schritts (\highl{SubBytes}) verwendet und mit $S_{i,b}$ bezeichnet
\begin{gather*}
  S_{i,a} =
     \begin{pmatrix}
       a^{(0,0)}& a^{(0,1)}& a^{(0,2)}& a^{(0,3)}\\
       \vdots &&& \vdots\\
       a^{(3,0)}& \hdotsfor{2} & a^{(3,3)}
     \end{pmatrix}
     \qquad S_{i,b} =
     \begin{pmatrix}
       b^{(0,0)}& b^{(0,1)}& b^{(0,2)}& b^{(0,3)}\\
       \vdots &&&\vdots \\
       b^{(3,0)}& \hdotsfor{2} & b^{(3,3)}
     \end{pmatrix}
\end{gather*}
Das Ergebnis des zweiten Schritts wird als Eingabe des dritten Schritts
(\highl{ShiftRows}) verwendet und mit $S_{i,c}$ bezeichnet. Das Ergebnis des
dritten Schritts wird als Eingabe für den vierten Schritt
(\highl{MixColumns}) verwendet und mit $S_{i,d}$ bezeichnet. Die
Ausgabe des vierten Schritts ist gleichzeitig die Ausgabe der $i$-ten~Runde und
somit wieder die Eingabe~$S_{i+1,a}$ für den ersten Schritt in der
$(i+1)$-ten~Runde. siehe \autoref{fig:aes}

Für die Elemente des Rings $\nicefrac{\F_{256}[x]}{x^{4}+1}$ verwendet man
die Polynomdarstellung oder die Hexadezimalschreibweise
\begin{gather*}
  a(x) = 03x^{3} + 01x^{2} + 01x + 02\quad\text{bzw.}\quad a = [03, 01, 01, 02]
\end{gather*}

\subsection{Beschreibung der einzelnen Schritte}

Die Grundlagen aus \autoref{sec:endl-koerper} können jetzt dazu verwendet
werden, die Arbeitsweise des AES auf mathematisch fundierten Regeln
aufzubauen, um z.\,B. die Invertierbarkeit aller Operationen für den
Entschlüsselungsalgorithmus zu sichern. Die Struktur, die durch den $\F_{256}$
% \help{Kann man vielleicht auch auf diesem mathematischen Wege einige
%   Eigenschaften, z.\,B. Konfusion und Diffusion oder Sicherheit gegen
%   differenzielle und lineare Kryptoanalyse nachweisen? Oder kann man zeigen,
%   dass Muster im Klartext bei der Verschlüsselung verwischt werden? Was ist
%   mit der Gruppeneigenschaft? Kann man zeigen, dass AES keine
%   Gruppeneigenschaft besitzt?}
%% Antwort Jens Kubieziel: Ja, kann man. Auf einige der Sachen wird in
%% dem Buch zu AES von Rijmen und Daemen eingegangen. Weiterhin gibt
%% es IIRC von Kaissa Nyberg einige Veröffentlichungen, die die obigen
%% Fragen beantworten. Da das im Skript zu weit führen würde, habe ich
%% das auskommentiert.
repräsentiert wird, ist dabei die Grundlage, denn ihre Elemente können mit den
Bytes, den Elementen in die jeder Eingabeblock zerlegt wird, assoziiert
werden.

\subsubsection{AddRoundKey}
Die Verknüpfung mit dem Rundenschlüssel, um die Ausgabe vom Schlüssel abhängig
zu machen, ist nicht weiter spektakulär:
\begin{gather*}
  S_{i, b} = S_{i,a} \oplus K_{i}
\end{gather*}

\subsubsection{SubBytes}

Für jedes Byte $b^{(z,s)}\in\F_{256}$ ($z,s\in\{0,\dotsc,3\}$) der Eingabe $S_{i,b} =
(b^{(z,s)})_{4\times4}$ werden zwei Transformationen ausgeführt:
\begin{enumerate}
 \item Bestimme das multiplikative Inverse $(b^{(z,s)})^{-1} = \tilde{b}^{(z,s)}
  \tilde{b}_{7}\tilde{b}_{6}\dotso\tilde{b}_{0}$ zu $b^{(z,s)}$ in $\F_{256}$.
  Falls $b^{(z,s)}= 00$, dann ist $\tilde{b}^{(z,s)} = 00$.

 \item Bestimmte Operationen lassen sich mit gewissen Darstellungen einer
  Struktur besser (einfacher) beschreiben als mit anderen Darstellungen. Daher
  ist es manchmal günstig die Darstellung zu wechseln. Der Polynomring
  $\nicefrac{\F_{2}[x]}{x^{8}+1}$ ist isomorph zu $\F_{256}$, d.\,h. beide
  beschreiben die gleiche Struktur. Man kann also die Elemente des Körpers
  $\F_{256}$ auch als Elemente des Polynomrings $\nicefrac{\F_{2}[x]}{x^{8}+1}$
  auffassen, d.\,h. $\tilde{b}^{(z,s)}\in\nicefrac{\F_{2}[x]}{x^{8}+1}$, und
  mit diesen weiter rechnen.

  Auf das Inverse $\tilde{b}^{(z.s)}$ wendet man folgende
  Abbildung an:
  \begin{gather*}
    c^{(z,s)} = [1,1,1,1,0,0,0,1] \otimes \tilde{b}^{(z,s)} + [0,1,1,0,0,0,1,1]
  \end{gather*}
  Analog zu den Rechenregeln, wie sie im \autoref{sec:f256x} hergeleitet
  wurden, ergibt sich folgende affine Abbildung mit dem Ergebnis $c^{(z,s)} =
  c_{7}c_{6}\dotso c_{0}$
  \begin{gather*}
    \begin{pmatrix}
      c_{0}\\ c_{1}\\ c_{2}\\ c_{3}\\ c_{4}\\ c_{5}\\ c_{6}\\ c_{7}
    \end{pmatrix} =
       \begin{pmatrix}
         1& 0& 0& 0& 1& 1& 1& 1\\
         1& 1& 0& 0& 0& 1& 1& 1\\
         1& 1& 1& 0& 0& 0& 1& 1\\
         1& 1& 1& 1& 0& 0& 0& 1\\
         1& 1& 1& 1& 1& 0& 0& 0\\
         0& 1& 1& 1& 1& 1& 0& 0\\
         0& 0& 1& 1& 1& 1& 1& 0\\
         0& 0& 0& 1& 1& 1& 1& 1
       \end{pmatrix} \cdot
       \begin{pmatrix}
         \tilde{b}_{0}\\
         \tilde{b}_{1}\\
         \tilde{b}_{2}\\
         \tilde{b}_{3}\\
         \tilde{b}_{4}\\
         \tilde{b}_{5}\\
         \tilde{b}_{6}\\
         \tilde{b}_{7}
       \end{pmatrix} +
       \begin{pmatrix}
         1\\ 1\\ 0\\ 0\\ 0\\ 1\\ 1\\ 0
       \end{pmatrix}
  \end{gather*}
\end{enumerate}

Die praktische Umsetzung der SubBytes-Transformation erfolgt durch eine
\highl{lookup-table}, d.\,h. man berechnet einmal für alle möglichen Eingaben
die Ergebnisse und speichert sie in einer Tabelle im Programm ab. Das Programm
schlägt dann nur noch in der Tabelle das Ergebnis nach und berechnet nichts
mehr.

\begin{table}
  \centering
  {\ttfamily
    \begin{tabular}{c|*{16}{c}}
      $S_{8}$& 0& 1& 2& 3& 4& 5& 6& 7& 8& 9& A& B& C& D& E& F\\
      \hline
      00& 63& 7C& 77& 7B& F2& 6B& 6F& C5& 30& 01& 67& 2B& FE& D7& AB& 76\\
      10& CA& 82& C9& 7D& FA& 59& 47& F0& AD& D4& A2& AF& 9C& A4& 72& C0\\
      20& B7& FD& 93& 26& 36& 3F& F7& CC& 34& A5& E5& F1& 71& D8& 31& 15\\
      30& 04& C7& 23& C3& 18& 96& 05& 9A& 07& 12& 80& E2& EB& 27& B2& 75\\
      40& 09& 83& 2C& 1A& 1B& 6E& 5A& A0& 52& 3B& D6& B3& 29& E3& 2F& 84\\
      50& 53& D1& 00& ED& 20& FC& B1& 5B& 6A& CB& BE& 39& 4A& 4C& 58& CF\\
      60& D0& EF& AA& FB& 43& 4D& 33& 85& 45& F9& 02& 7F& 50& 3C& 9F& A8\\
      70& 51& A3& 40& 8F& 92& 9D& 38& F5& BC& B6& DA& 21& 10& FF& F3& D2\\
      80& CD& 0C& 13& EC& 5F& 97& 44& 17& C4& A7& 7E& 3D& 64& 5D& 19& 73\\
      90& 60& 81& 4F& DC& 22& 2A& 90& 88& 46& EE& B8& 14& DE& 5E& 0B& DB\\
      A0& E0& 32& 3A& 0A& 49& 06& 24& 5C& C2& D3& AC& 62& 91& 95& E4& 79\\
      B0& E7& C8& 37& 6D& 8D& D5& 4E& A9& 6C& 56& F4& EA& 65& 7A& AE& 08\\
      C0& BA& 78& 25& 2E& 1C& A6& B4& C6& E8& DD& 74& 1F& 4B& BD& 8B& 8A\\
      D0& 70& 3E& B5& 66& 48& 03& F6& 0E& 61& 35& 57& B9& 86& C1& 1D& 9E\\
      E0& E1& F8& 98& 11& 69& D9& 8E& 94& 9B& 1E& 87& E9& CE& 55& 28& DF\\
      F0& 8C& A1& 89& 0D& BF& E6& 42& 68& 41& 99& 2D& 0F& B0& 54& BB& 16
    \end{tabular}
  }
  \caption{Die Substitutionsbox $S_{8}$ für den SubBytes-Schritt im AES;
    Quelle: Seite~16 in \cite{fips197}}
  \label{tab:s8-aes}
\end{table}

Die Tabelle ist die $S$-Box\footnote{da sie je 8~Bit verarbeitet, wird
sie mit $S_{8}$ bezeichnet}, die zweidimensional mit 16~Zeilen und
16~Spalten dargestellt wird. Die niederwertigen Bits $b_{3}, b_{2},
b_{1}$ und $b_{0}$ der Eingabe bestimmen die Spalte in der Tabelle und die
Bits $b_{7}, b_{6}, b_{5}$ und $b_{4}$ die Zeile. (siehe~\autoref{tab:s8-aes})

Beispiel: $S_{8}(1011\,0101)$, Zeile~11 und Spalte~5. \autoref{tab:s8-aes}
liefert $D5$. $S_{8}(1011\,0101) = (1101\,0101)$.

\begin{gather*}
  c^{(z,s)} = S_{8}(b^{(z,s)})
\end{gather*}

\subsubsection{ShiftRows}
Rechnen in $\nicefrac{\F_{256}[x]}{x^{4}+1}$ zeilenweise:
\begin{align*}
  [d^{(0,0)}, d^{(0,1)}, d^{(0,2)}, d^{(0,3)}]
     &= [c^{(0,0)}, c^{(0,1)}, c^{(0,2)}, c^{(0,3)}] \otimes 01x^{4}\\
  [d^{(1,0)}, d^{(1,1)}, d^{(1,2)}, d^{(1,3)}]
     &= [c^{(1,0)}, c^{(1,1)}, c^{(1,2)}, c^{(1,3)}] \otimes 01x^{3}\\
  [d^{(2,0)}, d^{(2,1)}, d^{(2,2)}, d^{(2,3)}]
     &= [c^{(2,0)}, c^{(2,1)}, c^{(2,2)}, c^{(2,3)}] \otimes 01x^{2}\\
  [d^{(3,0)}, d^{(3,1)}, d^{(3,2)}, d^{(3,3)}]
     &= [c^{(3,0)}, c^{(3,1)}, c^{(3,2)}, c^{(3,3)}] \otimes 01x
\end{align*}

Praktisch bedeutet das, dass die Elemente in der $k$-ten~Eingabezeile um $k$
Plätze nach links rotiert werden.
\begin{gather*}
  \begin{pmatrix}
    d^{(0,0)}& d^{(0,1)}& d^{(0,2)}& d^{(0,3)}\\
    d^{(1,0)}& d^{(1,1)}& d^{(1,2)}& d^{(1,3)}\\
    d^{(2,0)}& d^{(2,1)}& d^{(2,2)}& d^{(2,3)}\\
    d^{(3,0)}& d^{(3,1)}& d^{(3,2)}& d^{(3,3)}
  \end{pmatrix} =
     \begin{pmatrix}
       c^{(0,0)}& c^{(0,1)}& c^{(0,2)}& c^{(0,3)}\\
       c^{(1,1)}& c^{(1,2)}& c^{(1,3)}& c^{(1,0)}\\
       c^{(2,2)}& c^{(2,3)}& c^{(2,0)}& c^{(2,1)}\\
       c^{(3,3)}& c^{(3,0)}& c^{(3,1)}& c^{(3,2)}
     \end{pmatrix}
\end{gather*}

\subsubsection{MixColumns}
Auf die Eingabe $S_{i,d}$ wird spaltenweise die
Abbildung~$S_{32}$\footnote{$S_{32}$, weil die Abbildung 32~Bit verarbeitet}
angewendet.
\begin{gather*}
  \begin{pmatrix}
    e^{(0,s)} \\ e^{(1,s)}\\ e^{(2,s)}\\ e^{(3,s)}
  \end{pmatrix} = S_{32}\left(
     \begin{pmatrix}
       d^{(0,s)} \\ d^{(1,s)}\\ d^{(2,s)}\\ d^{(3,s)}
     \end{pmatrix}
     \right)
\end{gather*}
Diese entspricht folgender Berechnung im $\nicefrac{\F_{256}[x]}{x^{4}+1}$:
\begin{gather*}
  [e^{(0,s)}, e^{(1,s)}, e^{(2,s)}, e^{(3,s)}] =
      [03, 01, 01, 02] \otimes [d^{(0,s)}, d^{(1,s)}, d^{(2,s)}, d^{(3,s)}]
\end{gather*}
Die Matrixschreibweise für die Operation $\otimes$ (\autoref{sec:f256x}) ergibt
\begin{align}
  \notag
  \begin{pmatrix}
    e^{(0,s)}\\ e^{(1,s)}\\ e^{(2,s)}\\ e^{(3,s)}
  \end{pmatrix} &=
     \begin{pmatrix}
       02& 03& 01& 01\\
       01& 02& 03& 01\\
       01& 01& 02& 03\\
       03& 01& 01& 02
     \end{pmatrix} \cdot
     \begin{pmatrix}
       d^{(0,s)}\\ d^{(1,s)}\\ d^{(2,s)}\\ d^{(3,s)}
     \end{pmatrix}\\
  \label{eq:aes-s32}
  &= \begin{pmatrix}
       02\odot (d^{(0,s)}\oplus d^{(1,s)}) \oplus d^{(1,s)} \oplus
       d^{(2,s)} \oplus d^{(3,s)}\\
       02\odot (d^{(1,s)} \oplus d^{(2,s)}) \oplus d^{(0,s)} \oplus
       d^{(2,s)} \oplus d^{(3,s)}\\
       02\odot (d^{(2,s)} \oplus d^{(3,s)}) \oplus d^{(0,s)} \oplus
       d^{(1,s)} \oplus d^{(3,s)}\\
       02\odot (d^{(3,s)} \oplus d^{(0,s)}) \oplus d^{(0,s)} \oplus
       d^{(1,s)} \oplus d^{(2,s)}
     \end{pmatrix}
\end{align}

Die praktische Umsetzung mit einer lookup-table ist nicht möglich, da für
die $2^{32}$ möglichen Eingabewerte je 32~Bit Speicherplatz benötigt werden,
was 127\,Gigabit entspricht, was sich praktisch nur schwer umsetzen lässt.

\begin{figure}
  \centering
  \input{aes-s32.pdf_t}
  \caption{Schematische Darstellung der $S$-Box $S_{32}$ für MixColumns im
    AES}
  \label{fig:s32}
\end{figure}

\begin{gather}
  \label{eq:xtime}
  \mathrm{xtime}(p_{7}p_{6}\dotso p_{0}) =
     \begin{cases}
       \pi_{6}\pi_{5}\pi_{4}\pi_{3}\:\pi_{2}\pi_{1}\pi_{0} 0&\colon \pi_{7}=0\\
       (\pi_{6}\pi_{5}\pi_{4}\pi_{3}\:\pi_{2}\pi_{1}\pi_{0} 0) \oplus (0001\,1011)&
       \colon \pi_{7} = 1
     \end{cases}
\end{gather}

Aber durch eine geschickte Umordnung der Operanden, wie es in
\autoref{eq:aes-s32} geschehen ist, kann man eine sehr symmetrische Struktur
(\autoref{fig:s32}) erreichen. Die Funktion $\mathrm{xtime}\colon\F_{256}\rightarrow
\F_{256}$ (\autoref{eq:xtime}) berechnet dabei für ein $p\in\F_{256}$ das
Produkt
\begin{align*}
  02\odot p &= x \odot p(x)
     = x \cdot (\pi_{7}x^{7}+\dotsb+ \pi_{1}x + \pi_{0}) \pmod{m(x)}\\
     &= \pi_{7} x^{8} + \pi_{6}x^{7} + \dotsb+ \pi_{1}x^{2} + \pi_{0}x
     \pmod{x^{8}+x^{4}+x^{3}+x^{1}+1}
\end{align*}
Die Polynomdivision ergibt (nach einem Schritt) das Restpolynom
\begin{multline*}
  \pi_{6}x^{7} + \pi_{5} x^{6} + \pi_{4}x^{5} + (\pi_{3}\oplus \pi_{7})x^{4}
     + (\pi_{2}\oplus \pi_{7})x^{3} + \pi_{1}x^{2} + (\pi_{0}\oplus\pi_{7})x
     + \pi_{7}\\
  = [\pi_{6}, \pi_{5}, \pi_{4}, (\pi_{3}\oplus\pi_{7}),
     (\pi_{2}\oplus\pi_{7}), \pi_{1}, (\pi_{0}\oplus\pi_{7}), \pi_{7}]
\end{multline*}

\subsection{Struktur des Entschlüsselungsalgorithmus}

Da jeder Verschlüsselungsschritt einen Umkehrschritt besitzt ist die
Entschlüsselung der Nachricht gesichert:
\begin{enumerate}
 \item AddRoundKey$^{-1} = $AddRoundKey ist einfach ein \texttt{xor}
  mit demselben Schlüssel.

 \item SubBytes$^{-1}$ existiert, da die affine Abbildung eine
  Umkehrabbildung besitzt und das Inverse des Inversen das ursprüngliche
  Element im Körper liefert.

 \item ShiftRows$^{-1}$ ist einfach eine Rotation nach rechts.

 \item MixColumns$^{-1}$ existiert, da $a(x) = 02+01x+ 01x^{2} +
  03x^{3}$ im Ring $\nicefrac{\F_{256}[x]}{x^{4}+1}$ das inverse Polynom
  $a^{-1}(x)$ hat.
\end{enumerate}

\begin{bemerk}
  In der Beschreibung des Algorithmus' fehlt der Key-Schedule. Denn
  neben den eigentlichen Runden wird pro Runde ein Schlüssel
  errechnet, der dann mittels AddRoundKey benutzt wird.
\end{bemerk}

% 8.1.2007

\chapter{Public-Key-Kryptosysteme}

Die bisher behandelten Verschlüsselungsverfahren basierten alle darauf, dass
Alice und Bob über den gleichen Schlüssel (genauer: zwei quasi"=gleiche
Schlüssel) verfügen. Dieser Schlüssel musste von beiden geheim gehalten
werden, was auch zu dem Problem führte, dass beide vorher auf einem sicheren
Weg den geheimen Schlüssel verabreden mussten.

Dies ist oft nicht praktikabel, denn Schlüssel sollten auch nicht mehrfach
verwendet werden und vor jeder Kommunikation ein persönliches Treffen
abzuhalten, ist aufwendig.

Bei der \highl[Verschlüsselung!asymmetrische]{asymmetrischen
  Verschlüsselung} besitzt Bob, der Empfänger, ein Paar von
Schlüsseln. Der \highl[Schlüssel!öffentlicher]{öffentliche Schlüssel}
ist für alle Leute zugänglich und wird zum Verschlüsseln von
Nachrichten, deren Empfänger Bob ist, verwendet. Der
\highl[Schlüssel!privater]{private Schlüssel} wird von Bob
\emph{geheim} gehalten, denn damit kann er Nachrichten, die mit
seinem öffentlichen Schlüssel verschlüsselt wurden, entschlüsseln.

Der entscheidende Unterschied zu den symmetrischen Verschlüsselungsverfahren
ist der, dass die Kenntnis des öffentlichen Schlüssels keine Rückschlüsse auf
den privaten Schlüssel erlaubt. Eine Nachricht, die also mit einem
öffentlichen Schlüssel chiffriert wurde, kann nur mit dem dazu passenden
geheimen Schlüssel dechiffriert werden.

\section{Das Problem des Tauschens geheimer Schlüssel}

Alice und Bob kommunizieren über einen unsicheren Kanal und wollen daher ihre
Nachrichten verschlüsseln. Dabei stehen sie vor dem Problem, dass sie ein Paar
geheim zuhaltender Schlüssel über diesen Kanal austauschen müssen.
(\textit{engl. secret key agreement problem})

Im Jahr 1976 stellten \textsc{Diffie} und \textsc{Hellman} in ihrer
Arbeit "`New directions in cryptography"'\cite{diffihellman} ein
Verfahren für dieses augenscheinlich unlösbare Problem vor.

\subsection{Das Protokoll von Diffie und Hellman}

\begin{table}
  \centering
  \begin{tabularx}{.85\linewidth}{*{2}{|c|>{\raggedright\arraybackslash}X}|}
    \hline
    Schritt& \multicolumn{1}{c|}{Alice}& Kanal& \multicolumn{1}{c|}{Bob}\\
    \hline
    1.& \multicolumn{3}{c|}{\rule{0mm}{6mm}\parbox{.6\linewidth}{\centering Beide einigen sich
       auf eine große Primzahl~$p$ und eine primitive Wurzel~$g$; $g$ und $p$
       sind öffentlich}}\\[2mm]
    2.& Wählt zufällig eine große Zahl~$a$, berechnet
       $\alpha=g^{a}\pmod{p}$; $a$ ist privat && Wählt zufällig
       eine große Zahl~$b$,  berechnet $\beta=g^{b}\pmod{p}$; $b$ ist privat\\
    3.& & $\xleftarrow{\beta} \xrightarrow{\alpha}$ &\\
    4.& $K=\beta^{a}\pmod{p}$& & $K=\alpha^{b}\pmod{p}$\\
    \hline
  \end{tabularx}
  \caption{Austausch eines geheimen Schlüssels in der Öffentlichkeit nach
    Diffie und Hellman}
  \label{tab:difhel-schl-tau}
\end{table}

Alice und Bob verabreden eine große Primzahl~$p$ und eine primitive
Wurzel~$g$, die beide öffentlich bekannt sein können. Danach wählt jeder für
sich eine zufällige, große Zahl~$a$ bzw. $b$. Alice berechnet daraus
$\alpha=g^{a}\pmod{p}$ und Bob berechnet $\beta=g^{b}\pmod{p}$. Diese beiden
Ergebnisse tauschen dann beide wieder aus, wobei die Zahlen öffentlich
zugänglich seien können. Jeder berechnet dann für sich das gemeinsame
Geheimnis~$k$. Wie \autoref{tab:difhel-schl-tau} zeigt, berechnet
Alice $k_{A}=\beta^{a}\pmod{p}$ und Bob $k_{B}=\alpha^{b}\pmod{p}$.
\begin{gather*}
  k_{A} \equiv \beta^{a} \equiv (g^{b})^{a}\equiv
     (g^{a})^{b} = \alpha^{b} = k_{B}\pmod{p}
\end{gather*}

Aus den öffentlichen Größen $\alpha,\beta,p$ und $g$ kann man nicht das
Geheimnis $k$ ermitteln, weil man dafür eine der beiden geheimen Zahlen~$a$
oder $b$ benötigt, um $\alpha^{b}$ bzw. $\beta^{a}$ berechnen zu können.
Könnte man eine der Zahlen~$a$ oder $b$ ermitteln, so wäre dies ein Weg, den
diskreten Logarithmus $a=\log_{g}\alpha\pmod{p}$ bzw.
$b=\log_{g}\beta\pmod{p}$ zu berechnen, was nach \autoref{sec:diskrlog} (in
Polynomialzeit) nicht möglich ist.

\subsection{Das Protokoll von Rivest und Sherman}

\begin{table}
  \centering
  \begin{tabularx}{.85\linewidth}{*{2}{|c|>{\raggedright\arraybackslash}X}|}
    \hline
    Schritt& \multicolumn{1}{c|}{Alice}& Kanal& \multicolumn{1}{c|}{Bob}\\
    \hline
    1.& Wählt zufällig 2 große Zahlen~$x,y$, berechnet $x\star y$; $x$ privat,
       $y,x\star y$ öffentlich
       &&\\
    2.& & $\xrightarrow{y,x\star y}$& \\
    3.& & & Wählt zufällig eine große Zahl~$z$, berechnet $y\star z$; $z$
       privat, $y\star z$ öffentlich\\
    4.& & $\xleftarrow{y\star z}$& \\
    5.& Berechnet $K_{A}=x\star(y\star z)$& & Berechnet $K_{B}=(x\star y)\star z$\\
    \hline
  \end{tabularx}
  \caption{Austausch eines geheimen Schlüssels in der Öffentlichkeit nach
    Rivest und Sherman}
  \label{tab:rivsher-schl-tau}
\end{table}

Alice wählt zufällig zwei große Zahlen~$x$ und $y$ und berechnet daraus $x\star y$,
wobei $\star$ eine zweistellige und assoziative Operation ist, die stark "`nicht
invertierbar"' ist, d.\,h. die Kenntnis von $x\star y$ und eines Operanden~$x$
oder $y$ erlaubt (in Polynomialzeit) keine Rückschlüsse auf den anderen
Operanden. Die Zahl~$x$ bleibt privat und die Zahlen~$y$ und
$x\star y$ übermittelt sie an Bob, wobei die Zahlen öffentlich zugänglich seien
können. Bob wählt sich dann zufällig eine große Zahl~$z$, die privat bleibt,
und berechnet $y\star z$. Dieses Ergebnis teilt er Alice mit und auch hier kommt
es nicht auf die Geheimhaltung an. Somit haben beide jetzt das gemeinsame
Geheimnis $k=x\star y\star z$. Die \autoref{tab:rivsher-schl-tau}
zeigt schematisch den Ablauf.
\begin{gather*}
  k_{A} = x\star(y\star z) = (x\star y)\star z = k_{B}
\end{gather*}

Damit Eve (der mitlauschende Angreifer) an das Geheimnis $k$ gelangt, muss sie entweder an
die Zahl $x$ oder $z$ gelangen. Da aber eine der Forderungen an die
Operation~$\star$ ist, dass man mit der Kenntnis von $x\star y$ und $y$ nicht
auf $x$ schließen kann, ist es für Eve nicht möglich, $x$ aus $x\star y$ bzw.
$z$ aus $y\star z$ zu berechnen. Würde Eve also an das Geheimnis kommen, würde $\star$ nicht die
gestellten Anforderungen erfüllen.

\section{Das Konzept der Einwegfunktion}
\label{sec:rsa-math}

Die Frage ist nun, ob es denn überhaupt eine solche Operation~$\star$ gibt und
wenn ja, wie sieht diese aus? In der Komplexitätstheorie gibt es das Konzept
der Einwegfunktion, das Funktionen beschreibt, die einfach zu berechnen, aber
"`schwer"' zu invertieren sind.

\begin{defini}
  Eine Funktion $f\colon\N\rightarrow\N$ ist genau dann eine
  \highl{Einwegfunktion}, wenn sie die folgenden Eigenschaften besitzt
  \begin{itemize}
   \item $f$ ist im worst case\help{Ist das wirklich der worst case?} in Polynomialzeit zu berechnen, d.\,h.
    $f\in\FP$ und 
   \item für fast alle $y\in W_{f}$ gibt es keinen probabilistischen
    Algorithmus, der im average case ein zugehöriges Urbild~$x$ mit $f(x)=y$
    in Polynomialzeit berechnet, d.\,h. $f^{-1}\notin\FP$.
  \end{itemize}
\end{defini}

\begin{bemerk}
  \label{bem:1}
  Aus der Komplexitätstheorie ist bekannt, dass eine solche Einwegfunktion nur
  dann existiert, wenn $\mathrm{P}\ne \NP$ ist.
\end{bemerk}

% 10.1.

\subsection{Modulare Exponentiation mit fester Basis und festem Modul}
\label{sec:diskrlog}
Im Folgenden sei $f_{a,n}\colon\Z_{n}\mapsto\Z_{n}$ wie folgt definiert:
\begin{gather*}
  f_{a,n}(m) \coloneq a^{m} \mod n
\end{gather*}

\begin{satz}\label{satz:1}
  Die Zahlenfunktion $f_{a,n}$ (wie sie oben definiert ist) gehört zur
  Klasse~$\FP$ der in Polynomialzeit berechenbaren Funktionen.

  \begin{proof}
    Folgende rekursive Prozedur, \highl{square-and-multiply-Algorithmus}
    genannt, berechnet $f_{a,n}(m)$.
    \begin{Verbatim}[gobble=4]
    function (a,m,n)
    begin
        if m = 0
        then return 1
        else
        begin
            if m gerade
            then return (function(a, m/2, n) ** 2) mod n
            else return (function(a, m-1, n) * a) mod n
        end
    end
    \end{Verbatim}

    Da in mindestens jedem zweiten Schritt der Exponent~$m$ halbiert wird,
    erfordert dieser Algorithmus zwischen $\log_{2}m$ und $2\cdot\log_{2}m$
    Durchläufe und hat somit eine Laufzeit von $O(\log_{2}m) = O(\abs{m})$. Da
    ist einzelnen Operationen mit $O(1)$ angenommen werden, ist dies ein
    Polynomialzeitalgorithmus.
  \end{proof}
\end{satz}

\begin{defini}
  Als \highl[Logarithmus!diskreter]{diskreten Logarithmus} bezeichnet man die inverse
  Abbildung~$f^{-1}_{a,n}$, die zu einem gegebenen Wert~$y$ einen Wert~$m$
  bestimmt, so dass $a^{m}\mod n = y$, falls ein solches $m$ existiert.
\end{defini}

Diese Abbildung~$f^{-1}_{a,n}$ ist jedoch \textit{keine} Funktion, da
$f_{a,n}$ nicht injektiv ist. Zum Beispiel ist das Ergebnis von $f_{5,21}$ für
$m_{1}=4$ und $m_{2}=10$ gleich.
\begin{gather*}
  f_{5,21}(5) = 5^{4}\mod{21} = 16 = 5^{10}\mod{21} = f_{5,21}(10)
\end{gather*}

\begin{dogma}
  Wir glauben, dass die Funktion~$f_{a,n}$ nicht $\FP$-invertierbar und damit
  ein Kandidat für eine Einwegfunktion ist.
\end{dogma}

Könnten wir beweisen, dass $f_{a,n}$ nicht $\FP$-invertierbar ist, dann wäre
damit eine echte Einwegfunktion gefunden und man könnte nach \autoref{bem:1}
zeigen, dass $\mathrm{P}\ne\NP$ ist.

\begin{bemerk}
  Wenn $f$ eine Einwegfunktion ist, dann kann auch der \textit{legitimierte}
  Empfänger aus dem Kryptogramm $c=f(m)$ die Botschaft $m$ nicht in
  Polynomialzeit zurückrechnen.
\end{bemerk}

\subsection{Falltür-Einwegfunktionen}

\begin{defini}
  Eine Zahlenfunktion~$f\colon X\rightarrow Y$ heißt genau dann
  \highl{Falltür-Einwegfunktion} (engl. trap door one way function), wenn
  sie die folgenden Bedingungen erfüllt:
  \begin{itemize}
   \item Die Funktion ist in Polynomialzeit berechenbar; $f\in\FP$
   \item $f$ ist mit der \highl{Falltürinformation} in Polynomialzeit
    umkehrbar;
    \begin{gather*}
      \exists g\in\FP~\exists \text{\:Falltürinformation\:}T~%
         \forall y\in W_{f}\colon f\bigl(g(y,T)\bigr) = y
    \end{gather*}
   \item $f$ ist ohne die Falltürinformation nicht in Polynomialzeit
    umkehrbar; $f$ ist nicht $\FP$-invertierbar
  \end{itemize}

  Diese Definition geht auf \textsc{Diffie} und \textsc{Hellman} zurück.
\end{defini}

\begin{bemerk}
  Eine solche Falltür-Einwegfunktion ist keine Einwegfunktion, denn es gibt
  einen Polynomialzeitalgorithmus, der die $\FP$-Invertierung ermöglicht.
\end{bemerk}

\subsection{Modulare Exponentation mit festem Exponenten und festem Modul}
\label{sec:mwurzel}
Analog zur Definition von $f_{a,n}$ im \autoref{sec:diskrlog} sei im Folgenden
$g_{n,m}\colon \Z_{n} \mapsto \Z_{n}$ so definiert
\begin{gather*}
  g_{n,m}(a) \coloneq a^{m} \mod n
\end{gather*}

\begin{satz}
  Die oben definierte Funktion $g_{n,m}$ ist in Polynomialzeit berechenbar,
  d.\,h. $g_{n,m}\in\FP$.

  \begin{proof}
    Der square-and-multiply-Algorithmus aus dem Beweis von \autoref{satz:1} kann
    ebenfalls zur Berechnung der Funktion~$g_{n,m}$ verwendet werden.
  \end{proof}
\end{satz}

\begin{defini}
  Die inverse Abbildung $g_{n,m}^{-1}\colon\Z_{n} \rightarrow \Z_{n}$
  bezeichnet man als \highl[Wurzel]{$m$-te~Wurzel}. $g^{-1}_{n,m}$ berechnet für
  ein gegebenes $y$, das $a$, so dass $a^{m}\mod n = y$ gilt, falls ein
  solches $a$ existiert.
\end{defini}

Hier gibt es das gleiche Problem wie beim diskreten Logarithmus, dass
$g_{n,m}$ nicht eindeutig ist, d.\,h. die $m$-te~Wurzel ist keine Funktion.
Beispielsweise ist die 4.\,Wurzel von 16 für $n=21$ gleich
\begin{gather*}
  g_{21,4}(5) = 5^{4}\mod{21} = 16 = 2^{4}\mod 21 = g_{21,4}(2)
\end{gather*}

Doch im Gegensatz zu $f_{a,n}$ lässt sich $g_{n,m}$ in Polynomialzeit
invertieren, wenn die Faktorisierung von $n$ als Falltürinformation zur
Verfügung steht. (Dies wird später in \autoref{satz:2} gezeigt.) Dazu ein
Exkurs in die Zahlentheorie.

\subsubsection{Exkurs in die Zahlentheorie}

Ansatzpunkt:
\begin{gather*}
  \Z_{n}^{*} \coloneq \Set{ i | 1\leq i < n, \ggT(i,n)=1}
\end{gather*}
ist eine multiplikative Gruppe der Ordnung $\phi(n)$.
\help{Ist das gleich der Menge der Einheiten in 4.10.1?}

\begin{satz}
  \label{satz:3}
  Von \textsc{Euler} stammt die folgende Erkenntnis: Es gilt für alle $x$ mit $1\leq x
  < n$ und $\ggT(x,n) = 1$ folgende Kongruenz:
  \begin{gather*}
    x^{\phi(n)} \equiv 1\pmod{n}
  \end{gather*}
  oder anders ausgedrückt: ein beliebiges Element einer Gruppe hoch der
  Ordnung der Gruppe ergibt das Einselement der Gruppe.

  Ein Spezialfall ist der kleine Satz von \textsc{Fermat}: Für alle Primzahlen~$p$ und alle
  $x$ mit $1\leq x < p$ gilt:
  \begin{gather*}
    x^{p-1} \equiv 1\pmod{p}
  \end{gather*}
\end{satz}

\begin{defini}
  \label{def:1}\todo{Die Definition muss eher kommen.}
  Eine Zahl~$a$ ($1\leq a< n$) heißt genau dann
  \highl[Wurzel!primitive]{primitive Wurzel} von $n$, wenn
  $a$ die folgenden Eigenschaften erfüllt
  \begin{itemize}
   \item $a$ und $n$ sind Teilerfremd ($\ggT(a,n)=1$) und
   \item der kleinste Exponent~$d$, der $a^{d}\equiv1\pmod{n}$ erfüllt, ist
    $\phi(n)$ --~$d$ heißt \highl{Ordnung} von $a$~-- oder anders formuliert:
    für alle $d<\phi(n)$ gilt $a^{d}\not\equiv 1\pmod{n}$
  \end{itemize}
\end{defini}

\begin{bsp}
  Für $n=5$ kommen als primitive Wurzeln die Zahlen $\Z_{5}^{*} = \{1,2,3,4\}$
  in Frage. Davon entfallen 1 (aus offensichtlichen Gründen) und 4, da $4^{2}
  \equiv 1\pmod{5}$. Es bleiben also 2 und 3 als primitive Wurzeln von 5.

  Für $n=11$ gibt es die Kandidaten $\Z_{11}^{*} = \{ 1,2,\dotsc,10\}$, von
  denen nur 2, 6, 7 und 8 primitive Wurzeln sind.

  Für $n=6$ sind $\Z_{6}^{*}=\{1,5\}$ mögliche primitive Wurzeln, von denen
  nur 5 die Bedingung $5^{d}\not\equiv1\pmod{6}$ für alle $d=1<\phi(6)=
  \phi(3\cdot2) = 1\cdot2$ erfüllt.

  \begin{gather*}
    \begin{array}[t]{*{4}{c}}
      a& a^{2}& a^{3}& a^{4}\\
      \hline
      2& 4& 3& 1\\
      3& 4& 2& 1\\
      4& 1& 4& 1
    \end{array} \quad
       \begin{array}[t]{*{10}{c}}
         a& a^{2}& a^{3}& a^{4}& a^{5}& a^{6}& a^{7}& a^{8}& a^{9}& a^{10}\\
         \hline
         2& 4& 8& 5& 10& 9& 7& 3& 6& 1\\
         3& 9& 5& 4& 1& 3& 9& 5& 4& 1\\
         4& 5& 9& 3& 1& 4& 5& 9& 3& 1\\
         5& 3& 4& 9& 1& 5& 3& 4& 9& 1\\
         6& 3& 7& 9& 10& 5& 8& 4& 2& 1\\
         7& 5& 2& 3& 10& 4& 6& 9& 8& 1\\
         8& 9& 6& 4& 10& 3& 2& 5& 7& 1\\
         9& 4& 3& 5& 1& 9& 4& 3& 5& 1\\
         10& 1& 10& 1& 10& 1& 10& 1& 10& 1
       \end{array}
  \end{gather*}
\end{bsp}

\begin{satz}
  \textsc{Carl Friedrich Gauß} hat gezeigt, dass
  \begin{itemize}
   \item $n$ besitzt primitive Wurzeln \gdw $n$ ist $1, 2$ oder $4$ oder $n$
    ist einfache oder doppelte Potenz einer Primzahl~$p>2$ ($n = p^{k}$
    oder $n=2\cdot p^{k}$).

   \item Falls $n$ primitive Wurzeln besitzt, dann sind es $\phi(\phi(n))$ Stück.
  \end{itemize}
\end{satz}

\begin{bemerk}
  \begin{itemize}
   \item 8 und 12 sind die kleinsten Zahlen, die keine primitiven Wurzeln haben
   \item $n=5$ hat $\phi(\phi(5)) =\phi(4) = 2$ primitive Wurzeln.
  \end{itemize}
\end{bemerk}

\begin{lemma}
  Damit lässt sich der \highl[Logarithmus!diskreter]{diskrete Logarithmus} $f_{a,n}^{-1}$ exakt als
  Funktion definieren, falls $a$ eine primitive Wurzel von $n$ ist.
  \begin{gather*}
    f_{a,n}^{-1}(y) \coloneq \log_{a} y \mod n
  \end{gather*}
  Dabei ist der Wert $\log_{a}x$ eindeutig als diejenige Zahl~$m$ bestimmt, für
  die $a^{m} \mod n = y$ gilt.
\end{lemma}

% 15.1.

\begin{lemma}\label{lem:1}
  Der \highl[Algorithmus!erweiterter euklidischer]{erweiterte euklidische Algorithmus} lässt sich in Polynomialzeit
  berechnen; $\ggT\in\FP$.

  \begin{proof}
    Der Satz von Lemé (1985) zeigt, dass die Anzahl der Schleifendurchläufe
    für zwei aufeinander folgende Fibonacci-Zahlen $f_{k-1}$ und $f_{k}$ am
    Größten ist. Dann werden höchstens
    \begin{gather*}
      \lfloor\log_{\frac{1}{2}(1+\sqrt{5})} (\sqrt{5}N) \rfloor -2
    \end{gather*}
    Schleifendurchläufe benötigt, wobei $N > f_{k}$ ist.
  \end{proof}
\end{lemma}

\begin{lemma}\label{lem:4}
  Seien $x,u>0$. Für alle Primzahlen~$p$ und $q$, die voneinander verschieden
  sind, gilt:
  \begin{gather*}
    x^{u}\equiv x\mod p\quad\text{und}\quad x^{u}\equiv x\mod q \Rightarrow
       x^{u}\equiv x\mod (p\cdot q)
  \end{gather*}

  \begin{proof}
    $x^{u}\equiv x\mod p$ bedeutet $x^{u}-x$ ist durch $p$ teilbar und
    entsprechend $x^{u}-x$ ist durch $q$ teilbar. Da $p$ und $q$ teilerfremd
    sind, ist $x^{u}-x$ durch $p\cdot q$ teilbar.
  \end{proof}
\end{lemma}

\begin{satz}
  \label{satz:2}
  Es gibt einen Polynomialzeitalgorithmus, der bei Eingabe von drei
  natürlichen Zahlen~$n$, $m$ und $y$, wobei $\ggT(m,\phi(n)) = 1$ und $n$ das
  Produkt zwei bekannter Primzahlen~$p$ und $q$ ist, eine Zahl $a$ mit der
  Eigenschaft $g_{n,m}(a) = a^{m}\mod n = y$ bestimmt, d.\,h. der Algorithmus
  berechnet die $m$-te~Wurzel $a=g_{n,m}^{-1}(y)$. Die Faktorisierung von $n$
  in $p\cdot q$ ist die
  \highl{Falltürinformation}.

  \begin{proof}
    Der Algorithmus besteht aus zwei Teilschritten:
    \begin{enumerate}
     \item Da $m$ und $\phi(n)$ teilerfremd zueinander sind, bestimmt der
      erweiterte euklidische Algorithmus in Polynomialzeit (\autoref{lem:1})
      zwei Zahlen~$u$ und $v$ (\autoref{lem:6}), so dass $1 = \ggT(\phi(n),m)
      = u\cdot\phi(n) + v\cdot m$.

     \item Mit dem Inversen $v$ von $m$ in $\Z_{\phi(n)}$ lässt sich $a$ nach
      \autoref{satz:1} mit dem square-and-multiply-Algorithmus in Polynomialzeit durch
      $a\coloneq f_{y,n}(v) = y^{v}\pmod{n}$ bestimmen.
    \end{enumerate}

    Die Behauptung ist nun, dass $y\equiv a^{m}\pmod{n}$ gilt. Dazu machen wir
    die Annahme, dass $y\equiv x^{m}\pmod{n}$ für irgendein $x$ ist und zeigen
    $x=a$.

    Aus der Annahme $y\equiv x^{m}\pmod{n}$ folgt $y=x^{m}-s\cdot n$ (für geeignetes
    $s$) und mit $a\equiv y^{v}\pmod{n}$ ergibt sich
    \begin{align*}
      a &\equiv (x^{m}-sn)^{v} \pmod{n}\\
      \intertext{Mithilfe des binomischen Satz' lässt sich der Klammerausdruck
        umschreiben zu}
      &\equiv \sum_{k=0}^{v} \binom{v}{k} (x^{m})^{v-k} (-sn)^{k} \pmod{n}\\
      &\equiv x^{m\cdot v} + \sum_{k=1}^{v} \binom{v}{k} x^{m(v-k)} (-s)^{k}
         n^{k} \pmod{n}\\
      \intertext{Da innerhalb des Summenzeichens Vielfache von $n$ auftreten,
        entfällt dieser Teil}
      &\equiv x^{m\cdot v}\pmod{n}\\
      \intertext{Da $u$ und $v$ so bestimmt sind, dass $u\cdot\phi(n)+v\cdot
        m=1$ gilt, ergibt sich mit $\tilde{u}=-u$}
      &\equiv x^{\tilde{u}\cdot\phi(n)+1}\pmod{n}
    \end{align*}

    \begin{enumerate}[1.\,{Fall}]
     \item Für $x\equiv0\pmod{p}$ gilt die Kongruenz trivialer Weise.
      \begin{gather*}
        a\equiv 0^{\tilde{u}\cdot\phi(n)+1} \equiv 0 \equiv x\pmod{p}
      \end{gather*}

     \item Mit $x\not\equiv0\pmod{p}$ sind die Bedingungen für den kleinen
      Satz von Fermat (\autoref{satz:3}) erfüllt und es gilt $x^{p-1}\equiv
      1\pmod{p}$, d.\,h. $x^{p-1} = r\cdot p+1$ für ein passendes $r$. Also
      ergibt sich für die Kongruenz:
      \begin{align*}
        a&\equiv x^{\tilde{u}\cdot\phi(n)+1} = x^{\tilde{u}\cdot(p-1)\cdot(q-1)}\cdot x =
           (x^{p-1})^{\tilde{u}\cdot(q-1)}\cdot x
        \equiv 1^{\tilde{u}\cdot(q-1)}\cdot x\equiv x\mod p
      \end{align*}
    \end{enumerate}
    Für alle $x$ ist also $a\equiv x\pmod{p}$.

    Genauso kann man $a\equiv x\pmod{q}$ zeigen. Nach \autoref{lem:4} gilt
    also $a\equiv x\pmod{n}$.
  \end{proof}
\end{satz}

\begin{dogma}
  Wir glauben, dass die \highl{Faktorisierung} (Zerlegung in Primfaktoren)
  einer Zahl nicht in Polynomialzeit berechenbar ist. Die Falltürinformation
  $p\cdot q=n$ ist also nicht $\FP$"=invertierbar.
\end{dogma}

\begin{bemerk}
  \label{bem:2}
  Der Algorithmus für \autoref{satz:2} verwendet im ersten Schritt $n$ und
  $\phi(n)$. Ist die Primfaktorzerlegung für $n$ (die Falltürinformation)
  nicht gegeben, so ist die Berechnung von $\phi(n)$ genauso schwer wie die
  Zerlegung von $n$ in Primfaktoren. (\autoref{lem:7}) Damit ist der
  Algorithmus laut unserem Dogma ohne die Falltürinformation nicht in
  Polynomialzeit berechenbar.

  Damit ist die Funktion $g_{n,m}$ ein Kandidat für eine
  Falltür"=Einwegfunktion.
\end{bemerk}

\begin{lemma}
  \label{lem:7}
\todo{Sollte man das mit der vorherigen Bemerkung zusammenlegen?}
  Die Berechnung von $\phi(n)$, ohne Kenntnis der Primfaktorzerlegung von $n$,
  ist genauso schwer wie die \highl{Faktorisierung} von $n$, d.\,h. die
  Zerlegung von $n$ in ihre Primfaktoren.

  \begin{proof}
    \begin{description}
     \item["`$\Rightarrow$"'] Falls die Faktorisierung $n=p\cdot q$ bekannt
      ist, lässt sich $\phi(n)$ leicht berechnen, da $\phi$ multiplikativ ist.
      (\autoref{sec:restklassen})
      \begin{gather*}
        \phi(n) = \phi(p\cdot q) = \phi(p)\cdot\phi(q) = (p-1)\cdot(q-1)
      \end{gather*}
      Es gilt also: $\phi$-Funktion $\leq_{m}^{p}$ Faktorisierung.

     \item["`$\Leftarrow$"'] Falls $\phi(n)$ bekannt ist (und $n$ das Produkt
      zweier Primzahlen ist), dann sind $p$ und $q$, so dass $n=pq$, leicht
      berechenbar.

      \begin{align*}
        \phi(n) &= (p-1)\cdot(q-1) = pq - p-q +1 = n - (p+q) +1
      \end{align*}
      Also lässt sich die Summe der beiden Primzahlen anhand der gegebenen
      Größen bestimmen:
      \begin{gather*}
        p+q = n-\phi(n) +1
      \end{gather*}

      Die Differenz $p-q$ lässt sich aus den gegebenen Größen auf die
      folgenden Weise bestimmen:
      \begin{gather*}
        (p-q)^{2} = p^{2} - 2pq + q^{2} = p^{2} + 2pq + q^{2} - 4pq = (p+q)^{2}
           - 4n\\
        p-q = \sqrt{(p+q)^{2}-4n}
      \end{gather*}

      Die gesamte Berechnung erfordert $O(1)$ viele Schritte, womit beide
      Probleme gleich schwer sind. Es gilt also: Faktorisierung $\leq_{m}^{p}$
      $\phi$-Funktion.
    \end{description}
  \end{proof}
\end{lemma}

\begin{bsp}
  Gegen seien $n=943 = 23\cdot41$ und $\phi(n)=22\cdot40=880$. Damit ergibt
  sich $p+q = 943-880+1 = 64$ und $p-q = \sqrt{64^{2}-4\cdot943} = 18$. Aus
  $(p+q)+(p-q)$ ergibt sich wie erwartet so $p=41$ und aus $(p+q)-(p-q)$
  ergibt sich $q=23$.
\end{bsp}

Wir haben jetzt zwei Funktionen, von denen wir annehmen, dass sie nicht
$\FP$"=invertierbar sind: der diskrete Logarithmus und die Faktorisierung von
Zahlen. Die Public-Key-Verfahren beruhen auf diesen Funktionen, wobei RSA auf
der Faktorisierung von Zahlen und Elgamal auf dem diskreten Logarithmus
basiert.

% 17.1.

\section{Das RSA-Verfahren}

Das \highl{RSA-Verfahren} wurde 1978 von \textsc{Ron Rivest},
\textsc{Adi Shamir} und  \textsc{Leonard
Adleman} entwickelt.
% JK: Untenstehendes ist ein Gerücht, was ich bislang nicht
% verifizieren konnte. Nach dem Buch von Singh wollten sie einen
% Algorithmus für DH finden.

% Das eigentliche Ziel ihrer Arbeit war den Ansatz von
% Diffie und Hellman, dass es Einwegfunktionen gibt, zu wiederlegen.
% Dies gelang ihnen nicht, jedoch entwickelten sie dabei das RSA-Verfahren.

\begin{table}
  \centering
  \begin{tabularx}{.85\linewidth}{*{2}{|c|>{\raggedright\arraybackslash}X}|}
    \hline
    Schritt& Alice& Kanal& Bob\\
    \hline
    1.& & & Wählt große Primzahlen $p,q$, bestimmt $n=p\cdot q$\\
    2.& & & Wählt große Zahl $d$ mit $\ggT(d,\phi(n)) = 1$\\
    3.& & & Berechnet das Inverse~$e$ in $\Z_{\phi(n)}$\\
    4.& & $\xleftarrow{n,e}$& \\
    5.& Chiffriert die Botschaft~$m\leq n-1$ durch $c\equiv m^{e}\pmod{n}$& & \\
    6.& & $\xrightarrow{c}$& \\
    7.& & & Dechiffriert $m\equiv c^{d}\pod{n}$\\
    \hline
  \end{tabularx}
  \caption{Das RSA-Verfahren}
  \label{tab:rsa}
\end{table}

Damit Bob verschlüsselte Nachrichten empfangen kann, muss er zwei große
Primzahlen~$p$ und $q$ und eine große Zahl~$d$ wählen, wobei
$d$ eine Einheit im Ring $\Z_{\phi(n)}$ ist, diese also die Bedingung
$\ggT(d, (p-1)(q-1))=1$ erfüllt. Danach
berechnet er das eindeutig bestimmte Inverse~$e$ in $\Z_{\phi(n)}$ von $d$
(mit Hilfe des erweiterten euklidische Algorithmus). Das Paar~$(n,e)$ ist der
öffentliche Schlüssel, $d$ ist der geheime Schlüssel von Bob. Die anderen
Größen werden im Folgenden nicht mehr benötigt.

Wenn Alice ihm eine Botschaft~$m$ zukommen lassen will, wobei $m\leq n-1$ ist,
muss sie diese als $c=m^{e}\pmod{n}$ verschlüsseln und das Kryptogramm~$c$ an
Bob senden. Bob kann daraus die Botschaft mit $m=c^{d}\pmod{n}$ berechnen.
\autoref{tab:rsa}
Diese beiden Berechnungen sind nach \autoref{satz:1} in Polynomialzeit
durchführbar.

Der Verschlüsselungsschritt entspricht der Berechnung der Funktion
$g_{n,e}(m)=c$ aus \autoref{sec:mwurzel} und der Entschlüsselungsschritt ist
der Algorithmus aus dem Beweis von \autoref{satz:2}, wobei $m=f_{c,n}(d)$ ist.
Das RSA-Verfahren ist also so konstruiert, dass
\begin{gather*}
  m \equiv c^{d} \equiv (m^{e})^{d} \equiv m^{ed} \equiv m^{k\cdot\phi(n)+1}
     \equiv m^{1} \pmod{n}
\end{gather*}

\begin{bemerk}
  \begin{itemize}
   \item RSA ist etwa 100 mal langsamer als AES. Daher verwendet man
    \highl{Hybridverfahren}: Die Daten werden mit AES (oder einem anderen
    symmetrischen Blockalgorithmus) verschlüsselt und nur der Schlüssel dafür
    wird über RSA ausgetauscht.

   \item Die Primzahlen $p$ und $q$ sollten in der Größenordnung
    von $10^{100}$ liegen, damit man $n$ nicht leicht faktorisieren kann. Es
    gibt unterschiedliche, probabilistische Verfahren, um eine Zahl auf prim
    zu testen; z.\,B. von Solovay und Strassen --~ca.\,170 Zahlen testen~--
    oder von Rabin und Miller --~ca.\,100 Zahlen testen.

   \item Die Zahl $d$ sollte möglichst groß sein, damit sie nicht durch probieren
    gefunden werden kann.

   \item $e$ ist mit dem erweiterten euklidischen Algorithmus in
    Polynomialzeit berechenbar.

   \item $c$ und $m$ sind nach \autoref{satz:1} ebenfalls in Polynomialzeit berechenbar.

   \item $p$ und $q$ mit $p\cdot q>10^{200}$ sollten um einige Dezimalstellen
    differieren, damit man nicht durch $\sqrt{pq}$ diese schon fast errät.

   \item $p-1$ und $q-1$ sollten große Primfaktoren besitzen und $p-1$ und
    $q-1$ sollten möglichst teilerfremd sein, d.\,h. $\ggT(p-1, q-1)$ sollte
    möglichst klein sein. siehe \autoref{sec:rsa-angriffe}

   \item Ein direkter Angriff würde bedeuten, da $c=m^{e}\pmod{n}$ ist, aus
    $c$ die $e$-te~Wurzel modulo~$n$ zu berechnen. Dies ist nach \autoref{bem:2}
    praktisch nicht machbar.

   \item Die Nachricht muss in Blöcke passender Länge zerlegt werden.
  \end{itemize}
\end{bemerk}

\begin{bsp}
  Bob wählt die zwei Primzahlen $p=47$ und $q=59$. Dann sind $n=pq = 2773$ und
  $\phi(n) = (p-1)(q-1) = 46\cdot58 = 2668$. Als seinen geheimen Schlüssel
  $d\in\Z_{\phi(n)}^{*}$ wählt er $d=157$. Laut \autoref{bsp:2} ist das
  Inverse davon $e=17$. Als Blocklänge ergibt sich so 2, da bei 26~Buchstaben
  die Kodierung für "`\texttt{zz}"' $2626\leq2773$ ist.

  Alice möchte Bob die Nachricht "`\texttt{dieser satz ist geheim}"' schicken.
  Diese kodiert sie durch ihre Position im Alphabet, wobei die Leerzeichen mit
  00 kodiert werden.
  \begin{gather*}
    0409~0519~0518~0019~0120~2600~0919~2000~0705~0805~0913
  \end{gather*}

  Man kann die Berechnung auch auf Quadrierungen und Multiplikationen
  zurückführen, wenn man $e$ als $e=17=2\cdot2\cdot2\cdot2+1$ schreibt. Der
  erste Block $m_{1}^{2} = 920$ wird dann als
  \begin{gather*}
    409^{17}\mod 2773
       = \bigl(\bigl((409^{2})^{2}\bigr)^{2}\bigr)^{2}\cdot490 \mod 2773
       = 2510
  \end{gather*}
  verschlüsselt. Damit die Operanden nicht zu groß werden, kann man nach jedem
  Quadrieren bzw. Multiplizieren modulo 2773 rechnen. Insgesamt ergibt sich
  als Geheimtext
  \begin{gather*}
    2510~1493~1787~1436~0505~0499~2244~0317~1692~0542~0180
  \end{gather*}

  Die Entschlüsselung erfolgt analog mit $d=157$ für den letzten Block wie
  folgt
  \begin{gather*}
    180^{157}\mod 2773 =
       \biggl(\Bigl(\Bigl(\bigl(\bigl((180^{2})^{2}\bigr)^{2}
       \cdot180\bigr)^{2}\cdot180\Bigr)^{2} \cdot180\Bigr)^{2}\biggr)^{2}
       \cdot180 \mod 2773 = 913
  \end{gather*}
\end{bsp}

% 22.1.

\begin{bemerk}
  Die Sicherheit von RSA beruht auf zwei Säulen:
  \begin{itemize}
   \item Die Nachricht~$m$ lässt sich als die $e$-te~Wurzel aus $c$ berechnen.
    Die Berechnung der $e$-te~Wurzel ist aber ohne die Kenntnis der
    Faktorisierung von $n$ nicht in Polynomialzeit durchführbar. (siehe~\autoref{bem:2})

   \item Die Nachricht~$m$ ließe sich auch durch den normalen
    Entschlüsselungsalgorithmus mit $d$ bestimmen. Die Berechnung von $d$ aus
    den öffentlichen Größen ist aber nur mit Kenntnis von $\phi(n)$ möglich,
    was wiederum nur bestimmt werden kann, wenn die Faktorisierung von $n$
    bekannt ist. (siehe~\autoref{lem:7})
  \end{itemize}

  % Falls die Faktorisierung von $n$ "`einfach"' ist, dann ist auch RSA
  % "`einfach"'. Es gilt: $RSA\leq_{m}^{p} Faktorisierung$.
  % Aber die umgekehrte Relation gilt nicht. Insbesondere muss RSA nicht
  % "`schwer"' sein, wenn das Faktorisierungsproblems "`schwer"' ist.
\end{bemerk}

\subsection{Angriffe auf RSA}
\label{sec:rsa-angriffe}

Ein Angriff auf das \highl[Faktorisierung]{Faktorisierungsproblem} ist
die \highl{$(p-1)$-Methode}\todo{Hat die Methode keinen schöneren Namen?} von
\textsc{Polard}. Die Idee ist, dass man den Primfaktor $p$ von $n=p\cdot q$ durch
$p=\ggT(n,k\cdot p)$ ermitteln kann, sofern $n$ kein Teiler von $k\cdot p$ ist.

Sei $\nu$ ein Vielfaches von $p-1$ und $a$ eine beliebige Zahl, die
teilerfremd zu $n$ ist. Damit ist $a$ auch teilerfremd zu $p$ und nach dem
kleinen Satz von \textsc{Fermat} (\autoref{satz:3}) gilt dann, dass $a^{\nu}\equiv
(a^{p-1})^{l}\equiv1\pmod{p}$ ist. Also ist $a^{\nu}-1$ ein Vielfaches von
$p$.

Als Kandidat für $\nu$ kommen Produkte von Primzahlpotenzen, die durch eine
Schranke~$S$ nach oben begrenzt sind, in Frage.
\begin{gather*}
  \nu = \prod_{\substack{q\text{~ist prim}\\q^{k}\leq S}} q^{k}
\end{gather*}
Falls hier ein $q$ Teiler von $p-1$ dabei ist, dann ist $\nu$ ein Vielfaches
von $p-1$. Falls $\ggT(n,a^{\nu}-1)=1$ ist, muss man die Schranke vergrößern.

Daher sollen $p$ und $q$ im RSA-Verfahren so gewählt werden, dass die
Primfaktoren von $p-1$ und $q-1$ möglichst groß sind.

\begin{bsp}
  Die zu faktorisierende Zahl sei $n=1\,878\,551$. Die kleinste Zahl, die
  teilerfremd zu $n$ ist, ist $a=2$.

  Der erste Ansatz sei $S_{1}=5$. Damit ist $\nu_{1} = 2^{2} \cdot 3 \cdot 5 =
  60$ das Produkt aller größten Potenzen von Primzahlen, die kleiner sind als
  $S_{1}$. Als $a^{\nu_{1}}-1\mod n$ ergibt sich so $1\,862\,178$. Leider sind die
  beiden Zahlen teilerfremd.

  Also ein neuer Versuch mit $S_{2}=13$. Damit ist $\nu_{2} = 2^{3} \cdot
  3^{2} \cdot 5\cdot7\cdot11\cdot13 = 360\,360$. Damit ergibt sich
  $a^{\nu_{2}}-1\mod n=1\,637\,610$. Der größte gemeinsame Teiler hiervon und $n$
  ist 17.

  Da $n$ das Produkt zweier Primzahlen ist, ist somit die Faktorisierung von
  $n$ gebrochen. Die beiden Primfaktoren sind 17 und $110\,503$.
\end{bsp}

Eine andere Möglichkeit, die \highl{Faktorisierung} einer Zahl~$n$ zu bestimmen, ist
das \highl[Sieb!quadratisches]{quadratische Sieb}. Dafür werden Zahlen~$a$ und $b$ so ermittelt,
dass gilt:
\begin{gather*}
  a^{2}\equiv b^{2}\pmod{n}\qquad\text{und}\qquad a\not\equiv \pm b\pmod{n}
\end{gather*}
Das heißt $n$ teilt $a^{2}-b^{2}=(a+b)(a-b)$, aber weder $a+b$ noch $a-b$.
Damit ist der größer gemeinsame Teiler von $a^{2}-b^{2}$ und $n$ ein nichttrivialer
Faktor von $n$.

\subsection{Abwandlungen von RSA}

RSA kann nicht als Primzahltest verwendet werden, da es auch mit Modulen
funktioniert, die nicht das Produkt zweier Primzahlen sind!

\begin{defini}
  Eine \highl{Carmichael-Zahl}~$c$ ist das Produkt von Primzahlen, so dass für
  alle Primfaktoren~$q$ von $c$ gilt: $q-1$ teilt $c-1$.

\todo{hier stimmt was mit dem Text nicht. Der erste Punkt steht schon oben.}
  \begin{itemize}
   \item $q-1$ teilt $c-1$ und
   \item für alle zu $q$ teilerfremden Zahlen~$a$ gilt $a^{q-1}\equiv
    1\pmod{q}$. (diese Eigenschaft ist aus der ersten ableitbar \gdw (wegen
    der ersten Eigenschaft) $a^{c-1}\equiv1\pmod{c}$ \gdw (wegen dem
    chin.\,Restsatz) $a^{c-1}\equiv1\pmod{c}$)
  \end{itemize}
\end{defini}

\begin{bsp}
  $561 = 3\cdot11\cdot17$ ist eine Carmichael-Zahl, denn 2, 10 und 16 sind
  Teiler von 560. Falls also eine Zahl~$a$ teilerfremd zu 3, 11 und 17 ist,
  dann ist $a^{560}\equiv1 \pmod{561}$, z.\,B. $14^{560}\equiv1\pmod{561}$,
  aber z.\,B. gilt $9^{560}\equiv375\pmod{561}$.
\end{bsp}

\begin{lemma}
  Das RSA-Verfahren funktioniert auch mit Modulen~$n$, die nicht das Produkt
  zweier Primzahlen~$p$ und $q$ sind.

  \begin{proof}
    Wir betrachten folgenden Modul~$n=p\cdot c$, wobei $c=\prod q_{i}$ eine
    Carmichael-Zahl ist. In dem Fall gilt nicht, dass $\phi(n)=(p-1)\cdot
    (c-1)$ ist. Verwendet man jedoch diese Annahme weiter und wählt ein $d$
    mit $\ggT(d,(p-1)(c-1))=1$ und bestimmt dazu ein $e$ mit $e\cdot d\equiv1
    \pmod{(p-1)(c-1)}$, so gilt dennoch $a^{ed}\equiv a\pmod{n}$.

    \begin{enumerate}[{Fall}~1:]
     \item Wir betrachten den Primteiler $p$ von $n$.
      \begin{enumerate}[{Fall~1\,}a:]
       \item Ist $p$ ein Teiler von $a$, dann ist $a^{ed}\equiv0\equiv a\pmod{p}$.
       \item Ist $p$ kein Teiler von $a$, dann sind $p$ und $a$ teilerfremd zu
        einander, da $p$ prim ist. Es ist also zulässig den kleinen Satz von
        Fermat (\autoref{satz:3}) anzuwenden. Aus $e\cdot d\equiv
        1\pmod{(p-1)(c-1)}$ folgt $e\cdot d = k(p-1)(c-1)+1$ für geeignetes
        $k$ und es ergibt sich
        \begin{gather*}
          a^{ed}\equiv a^{k(p-1)(c-1)}\cdot a\equiv (a^{p-1})^{k(c-1)}\cdot a
             \equiv 1\cdot a\equiv a\pmod{p}
        \end{gather*}
      \end{enumerate}

     \item Wir betrachten nun alle Primteiler $q_{i}$ von $n$.
      \begin{enumerate}[{Fall~2\,}a:]
       \item Wenn $q_{i}$ ein Teiler von $a$ ist, dann ist $a^{ed}\equiv0\equiv
        a\pmod{q_{i}}$.
       \item Ist $q_{i}$ kein Teiler von $a$, so darf wieder der kleine Satz
        von Fermat angewendet werden. Da $c$ eine Carmichael-Zahl ist, lässt
        sich $c-1$ auch als $l_{i}\cdot(q_{i}-1)$ schreiben und es gilt
        \begin{gather*}
          a^{ed}\equiv a^{k(p-1)(c-1)}\cdot a
             % \equiv a^{k(p-1) l_{i}(q_{i}-1)}\cdot a
             \equiv (a^{q_{i}-1})^{k\cdot l_{i}\cdot(p-1)} \cdot a
             \equiv a\pmod{q_{i}}
        \end{gather*}
      \end{enumerate}
    \end{enumerate}

    Es gilt also $a^{ed}\equiv a\pmod{p}$ und $a^{ed}\equiv a\pmod{q_{i}}$ für
    alle $q_{i}$. Nach dem chinesischen Restsatz folgt daraus
    $a^{ed}\equiv a\pmod{n}$.
  \end{proof}
\end{lemma}

"`Optimieren"' lässt sich der RSA-Algorithmus noch im folgendem Sinne:
\begin{lemma}
  Es ist für das RSA-Verfahren nicht notwendig, den privaten Schlüssel~$d$ so zu
  bestimmen, dass dieser teilerfremd zu $\phi(n)$ ist. Es ist ausreichend, wenn
  dieser teilerfremd zu $\kgV(p-1,q-1)$ ist. Der Vorteil zeigt sich bei der
  Berechnung des öffentlichen Schlüssels~$e$, da hierfür das Modul kleiner
  geworden ist. Für $p=11$ und $q=13$ beispielsweise ist $(p-1)(q-1)=120$, aber
  $\kgV(p-1,q-1)=60$.

  \help{Der Vorteil erschließt sich mir noch nicht. Wenn ich $d$ und $e$ aus
    dem Ring $\Z_{\kgV(p-1,q-1)}$ wähle, verschenke ich doch mögliche
    Schlüsselpaare und der Gewinn ist im Vergleich zum späteren Aufwand bei
    der Ver-/Entschlüsselung zu vernachlässigen.}

  \begin{proof}
    Der Beweis erfolgt analog zum Beweis von \autoref{satz:2}, nur das zu
    beachten ist, dass $d$ und $e$ Einheiten des $\Z_{\kgV(p-1,q-1)}$ sind.
    Bis zu der Kongruenz
    \begin{gather*}
      a\equiv x^{u\cdot\phi(n)+1}\pmod{n}
    \end{gather*}
    verläuft die Rechnung genauso. Für die Fallunterscheidung muss der Fall
    $x\not\equiv0\pmod{p}$ an die veränderte Situation angepasst werden:

    Nach dem kleinen Satz von Fermat (\autoref{satz:3}) gilt $x^{p-1} = r\cdot
    p+1$ (für passendes $r$) und das kleinste gemeinsame Vielfache lässt sich
    schreiben als $\kgV(p-1,q-1) = b\cdot (p-1)$ Also
    ergibt sich für die Kongruenz $a\equiv x\pmod{p}$ für alle $x$.
    \begin{align*}
      a&\equiv x^{u\cdot\kgV(p-1,q-1)+1} = x^{u\cdot b\cdot(p-1)}\cdot x =
         (x^{p-1})^{u\cdot b}\cdot x \equiv 1^{u\cdot b}\cdot x\equiv x\mod p
    \end{align*}

    Analog kann man wiederum zeigen, dass $a\equiv x\pmod{q}$ gilt, und nach
    \autoref{lem:4} folgt daraus $a\equiv x\pmod{n}$.
  \end{proof}
\end{lemma}

Es ist sinnvoll diese Optimierung in einem hybriden Verfahren anzuwenden.
\help{So richtig habe ich nicht verstanden warum.}

\section{Das Verfahren von Elgamal}
Das \highl{Elgamal-Verfahren} wurde 1985 von \textsc{Taher Elgamal} entwickelt und
beruht auf der Annahme, dass der diskrete Logarithmus (\autoref{sec:diskrlog})
eine Einwegfunktion ist. Da man für den diskreten Logarithmus keine
Falltürinformation wie für die $m$-te~Wurzel benötigt, beruht die Sicherheit
von Elgamal im Wesentlichen auf dem Dogma, dass der diskrete Logarithmus
praktisch nicht berechenbar ist.

\begin{table}
  \centering
  \begin{tabularx}{.9\linewidth}{*{2}{|c|>{\raggedright\arraybackslash}X}|}
    \hline
    Schritt& Alice& Kanal& Bob\\
    \hline
    1.& && Wählt große Primzahl~$n$ und dazu eine primitive Wurzel~$g$\\
    2.& && Wählt zufällig $b\in\Z_{n-1}^{*}$ und berechnet
       $\beta\equiv g^{b}\pod{n}$\\
    3.& & $\xleftarrow{(n,g,\beta)}$& \\
    4.& Wählt zufällig $a\in\Z_{n-1}^{*}$ und berechnet
       $\alpha\equiv g^{a}\pod{n}$&&\\
    5.& $c\equiv m\cdot \beta^{a}\pmod{n}$&& \\
    5.& & $\xrightarrow{c,\alpha}$& \\
    6.& & & $m\equiv c\cdot\alpha^{n-1-b}\pmod{n}$\\
    \hline
  \end{tabularx}
  \caption{Ablauf des Elgamal-Verfahrens}
  \label{tab:elgamal}
\end{table}

Damit Alice an Bob eine verschlüsselte Nachricht senden kann, muss dieser sich
eine große Primzahl~$n$, dazu eine primitive Wurzel~$g$ (d.\,h. $n$ und $g$
sind teilerfremd und für alle $d<n-1$ gilt $g^{d}\not\equiv1\pmod{n}$;
\autoref{def:1}) und eine Zahl~$b\in\Z_{n-1}^{*}$. Aus dieser berechnet er
dann $\beta\equiv g^{b}\pmod{n}$. Das Tupel~$(n,g,\beta)$ bildet den öffentlichen
Schlüssel von Bob, die Zahl $b$ ist sein geheimer Schlüssel.

Wenn Alice nun Bob eine verschlüsselte Nachricht~$m\leq n-1$ schicken will,
muss sie sich ebenfalls eine Zahl~$a\in\Z_{n-1}^{*}$ wählen und damit
$\alpha\equiv g^{a}\pmod{n}$ berechnen. Ihre Nachricht~$m$ verschlüsselt sie
durch $c\equiv m\cdot\beta^{a}\pmod{n}$ und sendet Bob das Tupel~$(\alpha,c)$.
Die Zahl~$a$ muss geheim bleiben. Beim Empfang kann Bob die Nachricht durch
$m\equiv c\cdot \alpha^{n-1-b}\pmod{n}$ entschlüsseln. \autoref{tab:elgamal}

\help{Wenn man eine "`richtige"' Nachricht hat, die man erst in Blöcke~$m_{i}$
  zerlegen muss, kann dann Alice einfach die Blöcke mit dem gleichen $a$
  verschlüsseln? $c_{i}=m_{i}\cdot\beta^{a}$ Das würde das ganze Verfahren
  wesentlich beschleunigen, da man $\beta^{a}$ nur einmal berechnen muss.
  Ebenso wäre die Entschlüsselung dann auch einfach.}

\begin{satz}
  Der Elgamal-Algorithmus ist korrekt.

  % 24.1.

  \begin{proof}
    Es sind sowohl Alice bei der Verschlüsselung als auch Bob bei der
    Entschlüsselung alle Größen bekannt, die benötigt werden. Außerdem gilt
    die folgenden Kongruenz:
    \begin{gather*}
      m\equiv c\cdot\alpha^{n-1-b}
         \equiv m\cdot \beta^{a}\cdot (g^{a})^{n-1-b}
         \equiv m\cdot g^{ab} \cdot (g^{p-1})^{a} \cdot g^{-ab}
         \equiv m\cdot g^{ab-ab} \cdot 1^{a} \pmod{n}
    \end{gather*}
  \end{proof}
\end{satz}

\begin{bemerk}
  Es gibt zwei Möglichkeiten, an die Botschaft~$m$ zu gelangen.
  \begin{itemize}
   \item Entweder man kennt $\beta^{a}$ und bestimmt dazu das Inverse~$\gamma$ im
    $\Z_{n}$, womit man $m\equiv c\cdot\gamma\pmod{n}$ bestimmen kann. Dafür muss man
    aber $a$ kennen, wofür man den diskreten Logarithmus
    $a=\log_{g}\alpha\pmod{n}$ bestimmen müsste. Dieser ist aber nicht
    $\FP$-berechenbar. \autoref{sec:diskrlog}

   \item Oder man kennt~$b$ und kann damit die normale Entschlüsselung
    vornehmen. An die Kenntnis von $b$ gelangt man aber nur, wenn man den
    diskreten Logarithmus $b=\log_{g}\beta\pmod{p}$ bestimmen kann, was wiederum
    nicht in Polynomialzeit machbar ist.
  \end{itemize}

  \help{Daraus folgt aber nur, dass $Elgamal \leq_{m}^{p} diskr.\,Log$, aber gilt
    auch die umgekehrte Relation?}
\end{bemerk}

\section{Weitere Public-Key-Verfahren}
Es soll hier nur kurz die Idee des \highl[Rabin-Verfahren]{Rabin-Verfahrens} beschrieben
werden: Wähle zwei große Primzahlen~$p$ und $q$ mit $p\equiv 3\pmod{4}$ und
$q\equiv3\pmod{4}$, also $\frac{p+1}{4},\frac{q+1}{4}\in\N$; $p,q$ sind
geheim, $n=p\cdot q$ ist öffentlich.

Eine Nachricht~$m<n$ wird mit $c=m^{2}\pmod{n}$ verschlüsselt. Für die
Entschlüsselung werden mit dem erweiterten euklidischen Algorithmus die
Zahlen~$u$ und $v$ so bestimmt, dass $u\cdot p+v\cdot q=1$. Dann werden mit
den Hilfsgrößen~$m_{p}$ und $m_{q}$ die vier Quadratwurzeln~$r_{i}$
bestimmt.
\begin{gather*}
  m_{p} = c^{\frac{p+1}{4}}\pmod{n} \mspace{54mu}
     m_{q} = c^{\frac{q+1}{4}}\pmod{n}\\
  \begin{aligned}
    r_{1} &=u\cdot p\cdot m_{q} + v\cdot q\cdot m_{p}\pmod{n}\\
    r_{2} &=n-r_{1}\\
    r_{3} &=u\cdot p\cdot m_{q} - v\cdot q\cdot m_{p}\pmod{n}\\
    r_{4} &=n-r_{3}
  \end{aligned}
\end{gather*}

Das Problem dabei ist, dass die Quadratwurzel nicht eindeutig ist. Man muss
sich also noch darüber verständigen, welche der vier möglichen Wurzeln der
gemeinte Klartext ist.

Die Sicherheit des Verfahrens beruht darauf, dass Wurzelziehen nur möglich
ist, wenn $p$ und $q$ bekannt sind, da die $m$-te~Wurzel nicht
$\FP$-berechenbar.

\section{Digitale Signaturen}

Das Anliegen besteht in der \highl{Authentifizierung} des Absenders.
Grundidee: Wir nutzen die Sicherheit der Protokolle der Public-Key-Verfahren
in modifizierter Form für die Authentifizierung.
\todo{Von http://www.superrafi.com/src/digSig/node2.html noch ein bisschen Text
  klauen.}

\subsection{Elgamal}

\begin{table}
  \centering
  \begin{tabularx}{.9\linewidth}{|c|>{\raggedright}p{.2\linewidth}|c|>{\raggedright\arraybackslash}X|}
    \hline
    Schritt& \multicolumn{1}{c|}{Alice}& Kanal& \multicolumn{1}{c|}{Bob}\\
    \hline
    1.& && Wählt große Primzahl~$n$ und dazu eine primitive Wurzel~$g$\\
    2.& && Wählt zufällig $b\in\Z_{n-1}^{*}$ und berechnet
       $\beta\equiv g^{b}\pmod{n}$\\
    3.& && Wählt zufällig $r\in\Z_{n-1}^{*}$ und berechnet $\rho=g^{r}\pmod{n}$\\
    4.& && Bestimmt $s'\cdot r\equiv1\pod{n-1}$ und berechnet $s\equiv
       s'(m-b\cdot\rho)\pod{n-1}$; $sig_{Bob}(m) = (\rho,s)$\\
    5.& & $\xleftarrow{(n,g,\beta),m,(\rho,s)}$& \\
    6.& Prüft $g^{m} = \beta^{\rho}\cdot\rho^{s}\pod{n}$& & \\
    \hline
  \end{tabularx}
  \caption{Das Verfahren von Elgamal zur digitalen Signatur}
  \label{tab:sigelgamal}
\end{table}

Damit Bob an Alice eine Nachricht~$m$ mit Echtheitsnachweis senden kann, muss
er zusätzlich zum Elgamal-Verschlüsselungsverfahren (\autoref{tab:elgamal})
mit dem öffentlichen Schlüssel~$(n,g,\beta)$ sich eine Zahl~$r\in\Z_{p-1}^{*}$
wählen und dafür $\rho=g^{r}\pmod{n}$ bestimmen. Da $r\in\Z_{p-1}^{*}$, d.\,h.
insbesondere ist $r$ teilerfremd zu $p-1$, existiert ein $s'$ mit $r\cdot
s'\equiv1\pmod{n-1}$. Damit bestimmt er dann $s\equiv s'(m-b\cdot\rho)
\pmod{n-1}$. Das Paar~$(\rho,s)$ bildet die Signatur der Nachricht~$m$. Alice
kann diese durch die Kongruenz $g^{m} \equiv\beta^{s}\cdot\rho\pmod{n}$
überprüfen. \autoref{tab:sigelgamal}

Wegen $r\cdot s\equiv r\cdot s'(m-b\cdot\rho) \equiv m-b\cdot\rho\pmod{n-1}$
gilt $b\cdot\rho + r\cdot s\pmod{n-1}$ und damit $m= b\cdot\rho + r\cdot s +
k\cdot(n-1)$ für geeignetes $k$ und mit Hilfe des kleinen Satz von Fermat
(\autoref{satz:3}) ergibt sich
\begin{gather*}
  g^{m} = g^{b\cdot\rho+r\cdot s + k\cdot (n-1)}
     = g^{b\cdot\rho+r\cdot s} \cdot (g^{n-1})^{k}
     \equiv g^{b\cdot\rho+r\cdot s} \cdot 1^{k}
     = \beta^{\rho}\cdot \rho^{s} \pmod{p}
\end{gather*}
Dies entspricht der Kongruenz, die Alice zur Verifikation prüft:
\begin{gather*}
  g^{m} \equiv g^{b\cdot\rho+r\cdot s} = \beta^{\rho}\cdot \rho^{s} \pmod{p}
\end{gather*}

\subsection{RSA}

\begin{table}
  \centering
  \begin{tabularx}{.85\linewidth}{*{2}{|c|>{\raggedright\arraybackslash}X}|}
    \hline
    Schritt& \multicolumn{1}{c|}{Alice}& Kanal& \multicolumn{1}{c|}{Bob}\\
    \hline
    1.& & & Wählt große Primzahlen $p,q$, bestimmt $n=p\cdot q$\\
    2.& & & Wählt große Zahl $d$ mit $\ggT(d,\phi(n)) = 1$\\
    3.& & & Berechnet das Inverse~$e$ in $\Z_{\phi(n)}^{*}$\\
    4.& & & Erstellt $sig_{Bob}(m) \equiv m^{d}\pod{n}$\\
    5.& & $\xleftarrow{(n,e),m,sig_{Bob}(m)}$& \\
    6.& Prüft $m\equiv(sig_{Bob}(m))^{e}\pmod{n}$ &&\\
    \hline
  \end{tabularx}
  \caption{RSA-Verfahren für digitale Signaturen}
\end{table}

Die Erstellung einer Signatur mit Hilfe des RSA-Verfahrens \autoref{tab:rsa}
ist recht simpel. Wenn Bob eine Nachricht signieren will, tut er dies,
indem er die Nachricht mit seinem geheimen Schlüssel~$d$ verschlüsselt:
$sig_{Bob}(m) = m^{d}\pmod{n}$. Alice kann die Signatur dann prüfen, indem sie
mit dem öffentlichen Schlüssel~$e$ von Bob die Kongruenz
$m\equiv(sig_{Bob}(m))^{e}\pmod{n}$ berechnet.

Der Beweis für die Korrektheit erfolgt analog zum Beweis für die Korrektheit
von RSA mit
\begin{gather*}
  sig_{Bob}(m)^{e} \equiv m^{d\cdot e} \equiv m\pmod{n}
\end{gather*}

\section{Das Shamir-ohne-Schlüssel-Protokoll}

\begin{table}
  \centering
  \begin{tabularx}{.85\linewidth}{*{2}{|c|>{\raggedright\arraybackslash}X}|}
    \hline
    Schritt& \multicolumn{1}{c|}{Alice}& Kanal& \multicolumn{1}{c|}{Bob}\\
    \hline
    1.& Wählt große Primzahl~$p$ &&\\
    2.& & $\xrightarrow{p}$ &\\
    3.& Wählt Einheit~$a$ in $\Z_{p}^{*}$ && Wählt Einheit~$b$ in $\Z_{p}^{*}$\\
    4.& Berechnet $x = m^{a}\pod{p}$ für eine Nachricht~$m$ &&\\
    5.& & $\xrightarrow{p}$& \\
    6.& & & $y= x^{b}\pmod{p}$\\
    7.& & $\xleftarrow{y}$& \\
    8.& $z=y^{a^{-1}}\pmod{p}$& & \\
    9.& & $\xrightarrow{z}$& \\
    10.& & & $m=z^{b^{-1}}\pmod{p}$\\
    \hline
  \end{tabularx}
  \caption{Das Protokoll Shamir-ohne-Schlüssel}
\end{table}

Analog zum Diffie"=Hellman"=Schlüsseltausch (\autoref{tab:difhel-schl-tau})
funktioniert das Shamir-""ohne"=Schlüssel"=Protokoll ohne ein gemeinsames
Geheimnis von Alice und Bob. Jeder hat ein Geheimnis für sich, aber es gibt
kein gemeinsames Geheimnis.

Einer von beiden bestimmt eine große Primzahl~$p$, die er dem anderen
mitteilt. Daraufhin wählt jeder sein Geheimnis, als eine Einheit im Ring
$\Z_{p-1}^{*}$. Alice berechnet ein Paar $(a,a^{-1})$ mit der Eigenschaft
$a\cdot a^{-1}\equiv1\pmod{p-1}$ und entsprechend berechnet Bob ein
Paar~$(b,b^{-1})$ mit der Eigenschaft, dass $b\cdot b^{-1}\equiv1\pmod{p-1}$
ist.

Alice verschlüsselt die Nachricht~$m$ mit ihrem Geheimnis~$a$ durch $x\equiv
m^{a}\pmod{p}$. Dieses $x$ sendet sie an Bob der die Nachricht ein zweites Mal
durch $y\equiv x^{b}\pmod{p}$ verschlüsselt. Dieses $y$ übergibt er wieder an
Alice, die dann ihr "`Schloss"'~$a$ durch $z\equiv y^{a^{-1}}\pmod{p}$ wieder
entfernt. Daraufhin kann Bob sein "`Schloss"'~$b$ entfernen und erhält die
Nachricht $m\equiv z^{b^{-1}}\pmod{p}$. Es gilt also
\begin{align*}
  m &\equiv z^{b^{-1}} \equiv y^{a^{-1}\cdot b^{-1}}
     \equiv x^{b\cdot a^{-1}\cdot b^{-1}}
     \equiv m^{a\cdot b\cdot a^{-1}\cdot b^{-1}}\pmod{p}\\
  &\equiv (m^{b\cdot b^{-1}})^{l_{a}(p-1)+1}
     \equiv 1^{l_{a}}\cdot m^{l_{b}(p-1)+1}
     \equiv 1^{l_{b}}\cdot m \pmod{p}
\end{align*}

% 29.1.

\chapter{Kryptographische Hashfunktionen}

\begin{defini}
  Eine \highl{Hashfunktion} ist eine Abbildung der Form $H\colon\Sigma^{*}
  \mapsto \Sigma^{n}$ für ein festes $n\in\N$.
\end{defini}

\begin{bsp}
  Die \highl{Parität} ist eine Hashfunktion. Für $\Sigma=\{0,1\}$ ist die
  Parität für einen Wert $w=w_{1}w_{2}\dotso w_{k}\in\Sigma^{k}$ genau dann 1,
  wenn die Anzahl der Einsen in $w$ ungerade ist.
  \begin{gather*}
    H\colon\Sigma^{*} \mapsto\Sigma^{1},\quad
       H(w) = w_{1}\oplus w_{2}\oplus \dotsb \oplus w_{k}
  \end{gather*}

  Genauso ist die \highl{Quersumme} eine Hashfunktion. Für
  $\Sigma=\{0,1,\dotsc,9\}$ ist die Quersumme von $w\in\Sigma^{k}$
  \begin{gather*}
    H(w) = \sum_{i=1}^{k} w_{i}
  \end{gather*}
\end{bsp}

Wie leicht ersichtlich ist, kann eine Hashfunktion nicht injektiv sein, da sie
immer von einer mächtigeren Menge in eine schmächtigere Menge abbildet.

In der   Praxis werden Hashfunktionen häufig durch
Kompressionsfunktionen erzeugt. Ein \highl{Kompressionsfunktion} ist eine
Abbildung der Form $K\colon\Sigma^{m}\mapsto\Sigma^{n}$ für $m>n$.
Es werden zwei Forderungen an die Funktion gestellt:
\begin{itemize}
 \item $H$ (und $K$) müssen schnell berechenbar sein
 \item $H(w) = H(w')$ für $w\ne w'$ sollte nicht zu häufig auftreten! Eine
  solche Situation nennt man \highl{Kollision}.
\end{itemize}

Die beiden Beispiele erfüllen die erste Forderung auf alle Fälle. Jedoch gibt
es bei der Parität sehr viele Kollisionen, bei der Quersumme sind es weniger,
aber sie treten immer noch häufig auf.

Für kryptographische Hashfunktionen sind diese Forderungen jedoch nicht
ausreichend, denn es besteht folgende Angriffsmöglichkeit: Wenn Alice neben
der Nachricht~$m$ ihren Identitätsnachweis $sig_{Alice}(m)$, also insgesamt
$(m,sig_{Alice}(m))$, schickt, ist die Signatur genauso lang wie die
Nachricht, die zu übertragenden Daten verdoppeln sich also. Daher verwendet
man den Hashwert einer Nachricht für eine \highl[Signatur!digitale]{digitale Signatur}.

Aber nach der obigen Forderung ist der Hashwert~$H(m)$ leicht zu berechnen.
Mallory, der Angreifer, kann also leicht eine Nachricht~$m'$ mit $H(m')=H(m)$
finden und sich dann als Alice ausgeben, denn er besitzt für seine
Nachricht~$m'$ eine gütige Signatur von Alice
\begin{gather*}
  (m', sig_{Alice}(H(m))) = (m', sig_{Alice}(H(m')))
\end{gather*}

Um genau das zu vermeiden, formulieren wir folgende Eigenschaften für eine
\highl[Hashfunktion!kryptographische]{kryptographische Hashfunktion}~$H$:
\begin{itemize}
 \item $H$ ist in Polynomialzeit berechenbar, d.\,h. $H\in\FP$.
 \item $H$ ist eine Einwegfunktion.
 \item $H$ ist (schwach) \highl{kollisionsresistent}; d.\,h. für gegebenes $m$
  gibt es keinen Polynomialzeitalgorithmus, der ein $m'\neq m$ mit der
  Eigenschaft $H(m')=H(m)$ berechnet.
 \item $H$ ist (stark) kollisionsresistent; d.\,h. es gibt keinen
  Polynomialzeitalgorithmus, der überhaupt eine Kollision berechnet.
\end{itemize}
\help{Sollten kryptographische Hashfunktionen nicht auch so gestaltet sein,
  dass sich die Hashwerte von Texten, die sich nur leicht unterscheiden, stark
  unterscheiden? Und soll eine Hashfunktion nicht auch Vertauschungen
  anzeigen, also das die Permutation einer Nachricht einen anderen Hash hat?}

\begin{bemerk}
  Ein Invertierungsalgorithmus~$A$ für $H$ liefert für ein gegebenes $m$ ein
  Element~$m'=A(H(m))$. Da die Anzahl der Urbilder von $H(m)$ im Mittel größer
  als eins ist, ist die Wahrscheinlichkeit eine Kollision $m'$ zu berechnen im
  Mittel größer als $\frac{1}{2}$.
\end{bemerk}

Konsequenz: $H$ ist eine Einwegfunktion, deswegen probabilistische Algorithmen
zur Erzeugung von Kollisionen.

\begin{satz}
  Aus einer stark kollisionsresistenten Kompressionsfunktion~$K$
  der Form $K\colon\Z_{2}^{m} \mapsto \Z_{2}^{n}$ ($m>n$) lässt sich eine
  stark kollisionsresistente Hashfunktion~$H\colon\Z_{2}^{m} \mapsto
  \Sigma_{2}^{n}$ konstruieren. (von Merkle)
\end{satz}

Da nicht bewiesen ist, dass es kryptographische Einwegfunktionen gibt,
verwendet man nur solche Hashfunktionen, deren Kollisionsresistenz (bisher)
nicht widerlegt ist. Gute Kandidaten dafür sind Verschlüsselungsverfahren, die
als sicher gelten.

Konkret wird ein Verschlüsselungsverfahren gebraucht, für das die Klartext-
und Geheimtextmenge~$\Z_{2}^{n}$ ist und die Verschlüsselungsfunktion~$E_{k}$
immer wieder auf diese Menge abbildet, wobei der zugehörige Schlüssel~$k\in
\Z_{2}^{n}$ ebenfalls aus der Menge stammt. Damit lässt sich eine
\highl{Hashfunktion}~$H\colon\Z_{2}^{*}\mapsto\Z_{2}^{n}$ wie folgt
konstruieren:

Es sei $x=x_{1}x_{2}\dotso x_{l} \in\Z_{2}^{*}$ eine Nachricht, die in Blöcke
der Länge~$n$ zerlegt wird, d.\,h. $x_{i}\in\Z_{2}^{n}$, --~der letzte Block
wird einfach bis zur Länge $n$ aufgefüllt.

Der Hashwert einer Nachricht~$H(x)$ ist der Wert~$k_{l}$ nach der
$l$-ten~Iteration der Vorschrift $k_{i}=f(x_{i},k_{i-1})$ für $i=1,\dotsc,l$.
Die Funktion $f\colon\Z_{2}^{n}\times\Z_{2}^{n}\mapsto\Z_{2}^{n}$ wird durch
die Verschlüsselungsfunktion auf folgende Weise definiert, wobei man vier
verschieden Typen unterscheidet:
\begin{gather*}
  f(x,k) =
     \begin{cases}
       E_{k}(x)\oplus x\\
       E_{k}(x)\oplus x\oplus k\\
       E_{k}(x\oplus k)\oplus x\\
       E_{k}(x\oplus k)\oplus x\oplus k
     \end{cases}
\end{gather*}

Es bleibt die Frage: "`Wie groß soll $n$ sein?"' Es gibt zwei sich
widersprechende Bestrebungen: $n$ sollte nicht zu groß (eine Hashfunktion soll
komprimieren), aber auch nicht zu klein sein, da es sonst zu viele Kollisionen
gibt.

Aus der Stochastik ist das Geburtstagsparadoxon mit dem verblüffenden Resultat
bekannt, dass sich unter 23~Personen mit der Wahrscheinlichkeit von
$\frac{1}{2}$ mindestens zwei Personen befinden, die am gleichen Tag
Geburtstag haben. Dessen Grundlage soll jetzt zur Klärung der Frage genutzt
werden.

\begin{satz}
  Sei $H\colon\Sigma^{k}\mapsto\Sigma^{n}$ eine Hashfunktion, die für jede
  Nachricht genau einen Hashwert erzeugt, wobei es $k$ verschiedene
  Nachrichten und $n$ verschiedene Hashwerte gibt.

  Die Wahrscheinlichkeit dafür, dass zwei Nachrichten~$m$ und $m'$ den gleichen
  Hash\-wert~$H(m) = H(m')$ haben, ist $\geq\frac{1}{2}$, falls
  \begin{gather*}
    k\geq \frac{\sqrt{1+8\cdot n\cdot\ln2}+1}{2}
       \approx 1,18\sqrt{n}
  \end{gather*}

  % 31.1.

  \begin{proof}
    Ein Elementarereignis $(g_{1},g_{2},\dotsc,g_{k})\in (\Sigma^{n})^{k}$ ist
    die Zuordnung von $k$~Hashwerten auf $k$~Nachrichten, d.\,h. Nachricht~$i$
    bekommt den Hashwert~$g_{i}$ zugeordnet. Da die Zuordnung der Hashwerte
    gleichverteilt ist, ergibt sich die Wahrscheinlichkeit für ein
    Elementarereignis als $\bigl(\frac{1}{n}\bigr)^{k} = \frac{1}{n^{k}}$.

    Die Wahrscheinlichkeit~$p$, dass es zwei (oder mehr) Nachrichten~$i,j$
    gibt, die den gleichen Hashwert~$g_{i} = g_{j}$ haben, entspricht der
    Wahrscheinlichkeit~$q=1-p$ der dualen Aufgabe, dass alle $g_{i}$ paarweise
    verschieden sind.
    \begin{gather*}
      q = \frac{\card \{(g_{1},\dotsc, g_{k})\colon \text{alle $g_{i}$ sind
         verschieden}\}}{n^{k}}
         = \frac{1}{n^{k}} \prod_{i=0}^{k-1} n-i
         = \prod_{i=0}^{k-1} 1-\frac{i}{n}
    \end{gather*}
    Die Faktoren $1-\frac{i}{n}$ lassen sich nach oben abschätzen durch
    $e^{-\frac{i}{n}}$, denn $1+x\leq e^{x}$ für alle $x\in\R$.
    \begin{gather*}
      q\leq \prod_{i=0}^{k-1} e^{-\frac{i}{n}}
         = e^{-\frac{1}{n}\sum\limits_{i=0}^{k-1}i}
         = e^{-\frac{k(k-1)}{2n}}
    \end{gather*}
    Für $p\geq\frac{1}{2}$ bzw. $q\leq\frac{1}{2}$ ergibt sich also
    \begin{align*}
      e^{-\frac{k(k-1)}{2n}} \leq \frac{1}{2} \quad
         &\gdw\quad -\frac{k(k-1)}{2n} \leq -\ln2\\
         &\gdw\quad k^{2} - k - 2n\ln2 \geq 0\\
         &\gdw\quad k\geq \frac{1}{2} + \sqrt{\frac{1}{4}+2n\ln2}
    \end{align*}
  \end{proof}
\end{satz}

Für eine Hashfunktion $H\colon\Z_{2}^{*} \mapsto \Z_{2}^{n}$ hat die
"`Geburtstagsangriff"' folgende Konsequenz: Es genügen $\sqrt{2^{n}}$
Hashwerten, um mit einer Wahrscheinlichkeit $\geq\frac{1}{2}$ eine Kollision
zu erzeugen. In der Praxis bedeutet dies, dass $n=64$ zu kurz und damit zu
unsicher ist, da nur $2^{32}\approx4\cdot10^{9}$ Hashwerte für eine Kollision
berechnet werden müssen. Daher werden in der Regel Hashfunktionen mit
$n\geq128$ in der Praxis verwendet, bei digitalen Signaturen gilt sogar
$n>168$.

Illustration an einem Beispiel "`Ein unehrenhafter Vertrag"': Alice
erarbeitet zwei Verträge: Der eine begünstigt Bob, der andere benachteiligt ihn
und erzeugt für jeden Vertrag durch marginale Änderungen (z.\,B.
hinzufügen/weglassen von Leerzeichen) $2^{32}$~Varianten, berechnet für jede
Variante den Hashwert und wählt die zwei Fassungen, deren Hashwerte gleich
sind. Bob signiert den Hashwert und akzeptiert damit auch den für ihn
nachteiligen Vertrag.

In der Praxis haben sich zur Berechnung von Hashfunktionen (neben der
Erzeugung mit Hilfe von Verschlüsselungsfunktionen) spezielle Algorithmen etabliert:
\begin{description}
 \item[MD4] Erfunden von Ron Rivest
 \item[MD5] Weiterentwicklung von MD4
 \item[SHA-1] von NSA
\end{description}

Für die \highl[Signatur!digitale]{digitale Signatur} ergibt sich also folgendes Fazit: Alice
sendet Bob eine Nachricht und fügt ihre Signatur an: $(m,sig_{Alice}(m))$. Bob
verifiziert mit dem öffentlichen Schlüssel von Alice die Signatur:
$ver_{Alice}(sig_{Alice}(H(M))) = H(m)$. Mallory wäre dabei nur erfolgreich,
wenn er
\begin{enumerate}
 \item \label{enu:1} für seine Nachricht~$m'$ die Signatur von Alice
  $sig_{Alice}$ berechnen könnte oder
 \item \label{enu:2} zur Nachricht~$m$ eine weitere Nachricht~$m'$ mit
  $H(m)=H(m')$ erzeugen könnte.
\end{enumerate}
Aber \autoref{enu:1} ist ihm nicht möglich, weil er aus der Kenntnis von
$ver_{Alice}$ nicht auf $sig_{Alice}$ schließen kann, da $ver_{Alice}$ eine
Einwegfunktion ist, und \autoref{enu:2} ist für ihn nicht möglich, da $H$
kollisionsresistent ist.

\chapter{Zero-knowledge-Protokolle}

\highl{Zero-knowledge-Protokolle} haben das Anliegen, seinem Gegenüber zu
zeigen, dass man im Besitz eines Geheimnisses ist, ohne dieses Geheimnis
preiszugeben. Damit ist es Alice möglich, Bob einen
\highl{Identifizierungsnachweis} zu liefern, ohne diesen zu verraten und ihn
so vor Eve und Mallory zu schützen.

In der Komplexitätstheorie ist das sogenannte
\href{http://theory.cs.uchicago.edu/merlin/}{Arthur-Merlin-Protokoll}\footnote{siehe
\href{http://en.wikipedia.org/wiki/Arthur-Merlin_protocol}{Eintrag bei
der englischen Wikipedia zum Arthur-Merlin-Protokoll}} bekannt.
Dabei versucht der übermächtige Zauberer Merlin den König Arthur von der
Richtigkeit seines Beweises zu überzeugen. Da aber König Arthur nicht so gut
rechnen kann, wie Merlin\footnote{Arthur ist ein Computer mit einer
  Zufallszahleinheit und Merlin ein Orakel mit unbegrenzter
  Rechenkraft, welches nicht immer die Wahrheit spricht.}, prüft er nur Teile
des Beweises und akzeptiert, wenn er darin keinen Fehler findet.

An diese Idee angelehnt, versucht Alice, durch die Kenntnis der Lösung für ein
schwer zu lösendes Problem (ein Problem in $\NP$), Bob davon zu überzeugen,
dass sie die Lösung kennt. Ein mögliches Problem ist das
\highl{Graphisomorphieproblem}: Gegeben seien zwei einfache
Graphen~$G_{1}=(V_{1},E_{2})$ und $G_{2}=(V_{2},E_{2})$. Die Frage ist, ob die
Graphen zueinander \highl{isomorph} ($G_{1}\cong G_{2}$) sind, d.\,h.
existiert eine Umbenennung/Permutation~$\pi$ der Kanten in $G_{1}$, so dass
$G_{2}=\pi(G_{1})$. Für das Graphisomorphieproblem ist bekannt, dass es in
$\NP$ liegt. Es ist noch offen, ob es in $\mathrm{P}$ liegt oder ob es
$\NP$-vollständig ist.

\begin{table}
  \centering
  \begin{tabularx}{.85\linewidth}{*{2}{|c|>{\raggedright\arraybackslash}X}|}
    \hline
    Schritt& \multicolumn{1}{c|}{Merlin}& Kanal& \multicolumn{1}{c|}{Arthur}\\
    \hline
    1.& Wählt Permutation~$\rho$, $a\in\Z_{2}$ und
       berechnet $H=\rho(G_{a})$& & \\
    2.& & $\xrightarrow{H}$ &\\
    3.& & & Wählt $b\in\Z_{2}$ und verlangt $\sigma$, so dass $\sigma(H)=G_{b}$\\
    4.& & $\xleftarrow{b}$& \\
    5.& Berechnet $\sigma=\rho$, falls $a=b$; $\sigma=\pi\circ\rho$, falls
       $a=1,b=0$; $\sigma=\pi^{-1}\circ\rho$, falls $a=0, b=1$ &&\\
    6.& & $\xrightarrow{\sigma}$& \\
    7.& && Verifiziert $\sigma(G_{b}) = H$\\
    \hline
  \end{tabularx}
  \caption{Zero-Knowledge-Protokoll auf Basis des Graphisomorphieproblems}
  \label{tab:zero-know}
\end{table}

Damit Merlin sich später einmal identifizieren kann, wählt er einen
Graphen~$G_{0}$ und eine Permutation~$\pi$ und berechnet dazu einen isomorphen
Graphen~$G_{1}$. Die Permutation stellt das persönliche Geheimnis von Merlin
dar, $G_{0}$ und $G_{1}$ sind öffentlich.

Wenn Arthur von Merlin eine Identifikation verlangt, wählt sich Merlin einer
weiter Permutation~$\rho$ und ein Bit~$a\in\Z_{2}$ und berechnet den
Graphen~$H=\rho(G_{a})$. Diesen sendet er an Arthur, der seinerseits ein
Bit~$b$ wählt und von Merlin einen Isomorphismus~$\sigma$ verlangt, so dass
$H=\sigma(G_{b})$ ist. Es können nun drei Fälle auftreten:
\begin{itemize}
 \item $a=b$: Dann gilt $H=\rho(G_{a})=\rho(G_{b})$, also ist $\sigma=\rho$.
 \item $a=1$ und $b=0$: Dann gilt $H=\rho(G_{1})=\rho\bigl(\pi(G_{0})\bigr)$,
  also ist $\sigma=\pi\circ\rho$.
 \item $a=0$ und $b=1$: Dann gilt $H=\rho(G_{0})
  =\rho\bigl(\pi^{-1}(G_{1})\bigr)$, also ist $\sigma=\pi^{-1}\circ\rho$.
\end{itemize}
Dieses $\sigma$ sendet Merlin an Arthur, der daraufhin $\sigma(G_{b}) = H$
prüfen kann. \autoref{tab:zero-know}

\clearpage
\appendix

\stepcounter{chapter}
\begin{thebibliography}{99}
\addcontentsline{toc}{chapter}{\thechapter.~\bibname}
 \bibitem{schneier} Bruce Schneier: "`Angewandte Kryptographie"', Pearson
  Studium, 1996
 \bibitem{rothe} Jörg Rothe: "`Complexity theory and cryptology---an
  introduction to cryptocomplexity"', Springer, 2005
 \bibitem{buchmann} J.\,Buchmann: "`Einführung in die Kryptographie"',
  Springer, 1999
 \bibitem{menezes} Alfred J.\,Menezes, Paul C.\,van Oorschot, Scott
  A.\,Vanstone: "`Handbook of Applied Cryptography"', CRC Press, 1997,
  \url{http://www.cacr.math.uwaterloo.ca/hac/}
 \bibitem{trappe} Trappe, Washington: "`Introduction to cryptography by coding
  theory"', Prantice Hall, 2002
 \bibitem{watjen} D.\,Wätjen: "`Kryptographie -- Grundlagen, Algorithmen,
  Protokolle"', Spektrum, 2004
 \bibitem{douglas} Douglas Stinson: "`Cryptography---Theory and praxis"', CRC
  Press, 1995
 \bibitem{bauer} F.\,Bauer: "`Entzifferte Geheimnisse"', Springer, 2000
 \bibitem{beutelspacher} A.\,Beutelspacher, J.\,Schwenk, K.-D.\,Wolfenstetter:
  "`Moderne Verfahren der Kryptographie"', 6.\,Auflage, Vieweg, 2006
 \bibitem{delfs} H.\,Delfs, H.\,Knebl: "`Introduction to cryptography"',
  Springer, 2002
 \bibitem{goldreich} O.\,Goldreich: "`Fundamentals of cryptography"',
  Cambridge, 2001
 \bibitem{diffihellman} W.\,Diffie, M.\,Hellman: "`New directions in
  cryptography"', IEEE Transaction on information theory 22, Seiten
  644--654, 1976
 \bibitem{adleman} L.\,Adleman, R.\,Rivest, A.\,Shamir: "`On digital
  signatures and public key cryptosystems"', MIT Press, 1977
 \bibitem{rsafaq} RSA Laboratories: "`RSA Laboratories' Frequently Asked
  Questions About Today's Cryptography, Version 4.1"', RSA Security Inc.,
  2000,\\ \url{ftp://ftp.rsasecurity.com/pub/labsfaq/rsalabs_faq41.pdf}
 \bibitem{rc5save} Y.\,L.\,Yin: "`The RC5 encryption algorithm: two years on"',
  CryptoBytes (3) 2, 1997
 \bibitem{idea-save} J.\,Daemen, R.\,Govaerts, J.\,Vandewalle: "`Weak keys for
  IDEA"', Advances in Cryp\-to\-lo\-gy---CRYPTO '93, Springer-Verlag, 1994
 \bibitem{luby} M.\,Luby,  C.\,Rackoff: "`How to Construct
  Pseudorandom Permutations and Pseudorandom Functions."', SIAM Journal on
  Computing, vol. 17, 1988, S.\,373--386,\\
  \url{http://citeseer.ist.psu.edu/naor96construction.html} (Überarbeitete
  Fassung)
 \bibitem{matsui1} Mitsuru Matsui: "`Linear cryptanalysis method for DES
  cipher"', Advances in Cryp\-to\-lo\-gy""---EUROCRYPT '93 Proceedings,
  Springer-Verlag, 1994, S.\,386--397
 \bibitem{des-diff-ana} Eli Biham, Adi Shamir: "`Differential
  Cryptanalysis of DES-like Cryptosystems"', CRYPTO'90 \& Journal of
  Cryptology, vol. 4, No. 1, 1991,\\
  \url{http://www.cs.technion.ac.il/~biham/Reports/Weizmann/cs90-16.ps.gz}
 \bibitem{des-diff-16-ana} Eli Biham, Adi Shamir: "`Differential Cryptanalysis
  of the Full 16-Round DES"', Proceedings of CRYPTO '92, vol. 740, December
  1991,\\
  {\small \url{http://www.cs.technion.ac.il/users/wwwb/cgi-bin/tr-info.cgi?1991/CS/CS0708}}
 \bibitem{des} "`Data Encryption Standard, FIPS PUB 46-3"', National Institute
  of Standards and Technology, 1999,\\
  \url{http://csrc.nist.gov/publications/fips/fips46-3/fips46-3.pdf}
 \bibitem{des-copper} David Coppersmith: "`The Data Encryption Standard (DES)
  and its strength against attacks"', IBM Journal of Research and Development,
  Band~38, 1994,\\
  \url{http://www.research.ibm.com/journal/rd/383/coppersmith.pdf}
\bibitem{wiener} Keith W.\,Campbell, Michael J.\,Wiener: "`DES is not
  a group"', Advances in cryptology "= Crypto '92, pages 512"=520,
  Springer-Verlag, 1993,\\
  {\small
    \url{http://dsns.csie.nctu.edu.tw/research/crypto/HTML/PDF/C92/512.PDF}}
\bibitem{rivest1978} Ron Rivest: "`A method for obtaining digital
  signatures and public-key cryptosystems"', Communications of the
  ACM, 21(2):120-126, February 1978.\\
  {\small \url{http://people.csail.mit.edu/rivest/""RivestShamirAdleman-AMethodForObtainingDigitalSignaturesAndPublicKeyCryptosystems.pdf}}
\bibitem{fips197} "`Advanced Encryption Standard, FIPS PUB 197"',
  National Institute of Standards and Technology, 2001,\\
  \url{http://www.csrc.nist.gov/publications/fips/fips197/fips-197.pdf}
\end{thebibliography}

\chapter{Übungsaufgaben}
\section{Blatt 1}

Der folgende mit Vigenère-Chiffrierung deutschsprachige Text ist zu
entschlüsseln. (Die Blockstruktur dient lediglich der besseren Lesbarkeit.)

\subsection*{Aufgabe 1}
Bestimmen Sie eine mögliche Periodenlänge~$d$
\begin{enumerate}[a)]
 \item mit Hilfe des Kasiski-Tests.
 \item mit Hilfe des Friedman-Tests.
 \item Formulieren Sie eine Hypothese für $d$.
\end{enumerate}

\subsection*{Aufgabe 2}
Bestimmen Sie gemäß $d$ eine Häufigkeitsverteilung und leiten Sie daraus ein
Schlüsselwort ab.

\subsection*{Aufgabe 3}
Bestimmen Sie den Klartext.

\begin{verbatim}
  FSGEXV  EVIISA  MGYFNX  EJTMUR  MPNYME  FMPSIH  EFIXUE  HQFOOU
  PGIAVI  KJSWLT  IIZJIJ  ELXVOT  YBKMEC  GYUELW  RHEHOR  ONIFVS
  EHKCJS  WLFEEL  JIBNTS  VTIMGY  JSNECT  IBRQVE  HXJDHF  YVTSYP
  EEIYWX  JLNRRU  UYVCJC  BELDHZ  YVSKFE  IUERXV  TGCFKF  IHIZOF
  UGYFSP  IIGABV  VOGYRL  FGYRUM  AHKVOK  FEIUER  XRVFTY  XFHIII
  JGEIZU  ZOIZOE  LFVLAH  RKFNMT  IBCBIQ  VUHXVS  SOGYFN  ILEFSY
  MEFSSR  KBXORU  TEGEEU  IEDLCE  NVRDHN  IE
\end{verbatim}

\section{Blatt 2}

\subsection*{Aufgabe 1}
\begin{enumerate}
 \item Verschlüsseln Sie die Nachricht $m=\mathrm{WASSER}$ mit Hilfe der
  Hill-Chiffre und verwenden Sie die Matrix
  \begin{gather*}
    K =
    \begin{pmatrix}
      7 & 3\\
      5 & 8
    \end{pmatrix}
  \end{gather*}

 \item Bestimmen Sie die entsprechende Matrix zur Entschlüsselung und wenden
  Sie diese auf den in a) erhaltenen Geheimtext an.
\end{enumerate}

\subsection*{Aufgabe 2}
Bestimmen Sie eine $2\times 2$-Matrix~$M$, durch die die Nachricht "`hund"'
mit der Hill-Chiffre in den Geheimtext "`AFFE"' umgewandelt wird.

\subsection*{Aufgabe 3}
Wir definieren die Abbildung $\Phi_{a,b}\colon \Z_{26}\rightarrow\Z_{26}$ durch
\begin{gather*}
  \Phi_{a,b}(x) \coloneq (ax+b) \pmod{26}
\end{gather*}
Bestimmen Sie diejenigen ganzen Zahlen $a,b$, für die die Abbildung
$\Phi_{a,b}$ bijektiv ist.

\textbf{Bemerkung:} Diese Abbildung kann zum Verschlüsseln verwendet werden
(affine Chiffre)

\section{Blatt 3}

Der folgende Text wurde mit der Vigenère-Chiffrierung verschlüsselt. Die
Blockstruktur dient lediglich der besseren Lesbarkeit.

\subsection*{Aufgabe 1}

Bestimmen Sie eine mögliche Periodenlänge~$d$
\begin{enumerate}
 \item mit Hilfe des Kasiski-Tests.
 \item mit Hilfe des Friedman-Tests.
 \item Formulieren Sie eine Hypothese für $d$.
\end{enumerate}

\subsection*{Aufgabe 2}

Bestimmen Sie gemäß $d$ eine Häufigkeitsverteilung und leiten Sie darauf ein
Schlüsselwort ab.

\subsection*{Aufgabe 3}

Bestimmen Sie den Klartext.

\begin{verbatim}
  UEQPC  VCKAH  VNRZU  RNLAO  KIRVG  JTDVR  VRICV  IDLMY
  IYSBC  COJQS  ZNYMB  VDLOK  FSLMW  EFRZA  VIQMF  JTDIH
  CIFPS  EBXMF  FTDMH  ZGNMW  KAXAU  VUHJH  NUULS  VSJIP
  JCKTI  VSVMZ  JENZS  KAHZS  UIHQV  IBXMF  FIPLC  XEQXO
  CAVBV  RTWMB  LNGNI  VRLPF  VTDMH  ZGNMW  KRXVR  QEKVR
  LKDBS  EIPUC  EAWJS  BAPMB  VSZCF  UEGIT  LEUOS  JOUOH
  UAVAG  ZEZIS  YRHVR  ZHUMF  RREMW  KNLKV  KGHAH  FEUBK
  LRGMB  JIHLI  IFWMB  ZHUMP  LEUWG  RBHZO  LCKVW  THWDS
  ILDAG  VNEMJ  FRVQS  VIQMU  VSWMZ  CTHII  WGDJS  XEOWS
  JTKIH  KEQ
\end{verbatim}

\chapter{Lösungen}
\section{Blatt 1}
\subsection*{Aufgabe 1}
\begin{enumerate}[a)]
 \item Für den Kasiski-Test muss man Wiederholungen von Zeichenketten finden,
  die länger sind als 2 Zeichen, Beispiele:
  \begin{center}
    \begin{tabular}{l|cl}
      Zeichenkette & Auftreten & Abstand\\
      \hline
      \texttt{KFEIUERX} & 172, 222 & $50 = 2\cdot 5^{2}$\\
      \texttt{YMEF} & 28, 288& $260 = 2^{2}\cdot 5\cdot13$\\
      \texttt{GYFN} & 14, 279& $265 = 5\cdot53$\\
      \texttt{JSWL} & 56, 101& $45 = 3^{2}\cdot5$\\
      \texttt{GRY} & 207, 212& 5\\
      \texttt{TIB} & 126, 264& $138 = 2\cdot3\cdot23$
    \end{tabular}
  \end{center}

 \item Für den Friedman"=Test muss die Anzahl~$l_{i}$ des Auftretens der
  einzelnen Buchstaben gezählt werden, was wesentlich einfacher mit einem
  Programm geht. Daraus kann man mit \autoref{eq:koinzi} den Koinzidenzindex
  für den Text bestimmen --~$I(c)\approx0,0483$~-- woraus sich mit
  \autoref{eq:fried-d} eine Periodenlänge von $d\approx3,93$ ergibt.

 \item Da vor allem 5 als Faktor in den längeren Wiederholungen beim
  Kasiski"=Test auftritt und $d\approx3,93$ aus dem Friedman"=Test
  näher an 5 als an 2 liegt, ist eine erste Schätzung für die
  Periodenlänge~$d=5$.

  \texttt{TIB} scheint eine zufällige Wiederholung zu sein, die nicht auf eine
  gleiche Verschlüsselung von gleichen Zeichenketten zurückzuführen ist.
\end{enumerate}

\subsection*{Aufgabe 2}
Für die Bestimmung des Schlüsselworts muss für jeden Textteil (jede Spalte)
die Häufigkeitsverteilung der Buchstaben ermittelt werden. Dies geht am
Leichtesten mit einem Programm. Im 1., 2., 4. und 5. Textteil ist die
Zuordnung des Buchstabens~\texttt{e} eindeutig. Hier treten die Buchstaben
\texttt{F}, \texttt{E}, \texttt{I} resp. \texttt{V} am Häufigsten auf. In der
dritten Spalte gibt es zwei Möglichkeiten: \texttt{H} oder \texttt{Y}, beide
treten acht Mal auf. Jedoch liefert nur die Zuordnung von \texttt{H} auf
\texttt{e} einen sinnvollen Text. Das Schlüsselwort ist also \texttt{BAUER}.
\begin{center}
  \begin{tabular}{cccc}
    Spalte& häuf.\,Buchst.& Verschiebung& Verschl.\,v.\,\texttt{a}\\
    \hline
    1.& \texttt{F}& 1& \texttt{B}\\
    2.& \texttt{E}& 0& \texttt{A}\\
    3a& \texttt{H}& 3& \texttt{D}\\
    3b& \texttt{Y}& 20& \texttt{U}\\
    4.& \texttt{I}& 4& \texttt{E}\\
    5.& \texttt{V}& 17& \texttt{R}
  \end{tabular}
\end{center}

\subsection*{Aufgabe 3}
Es mag ueberraschen, dass man von einem vorgelegten monoalphabetisch
chiffrierten Text leichter sagen kann, ob er englisch oder franzoesisch ist
als ihn zu entschluesseln. Dies gilt natuerlich auch fuer Klartext. Es gibt
ein einfaches Verfahren genuegend langen Klartext auf Zugehoerigkeit zu einer
bekannten Sprache zu untersuchen ohne seine Syntax und Semantik zu betrachten.

\section{Blatt 2}
\subsection*{Aufgabe 1}

\begin{enumerate}
 \item Die Verschlüsselungsmatrix~$K$ arbeitet mit Blöcken der Länge~2. Also
  muss der Klartext \texttt{wasser} erst einmal kodiert werden
  ($\mathtt{a}\rightarrow0$) und dann in Blöcke geteilt werden. Es ergeben
  sich also die drei Blöcke
  \begin{gather*}
    v_{1} = \begin{pmatrix}22& 0\end{pmatrix}\qquad
    v_{2} = \begin{pmatrix}18& 18\end{pmatrix}\qquad
    v_{3} = \begin{pmatrix}4& 17\end{pmatrix}
  \end{gather*}
  Diese werden durch $w = v\cdot K$ verschlüsselt und wieder als Text kodiert
  ($0\rightarrow\mathtt{A}$): \texttt{YOIJS}. Man beachte, dass die Einträge
  in den Matrizen/Vektoren Elemente aus $\Z_{26}$ sind.
  \begin{gather*}
    w = \begin{pmatrix}v_{1}\\v_{2}\\v_{3}\end{pmatrix}\cdot K
       = \begin{pmatrix}22& 0\\18& 18\\4& 17\end{pmatrix}\cdot
       \begin{pmatrix} 7 & 3\\ 5 & 8 \end{pmatrix}
       = \begin{pmatrix}24& 14\\8& 16\\9& 18\end{pmatrix}
  \end{gather*}

 \item Die inverse Matrix zu $K$ kann man entweder mit der Formel aus
  \autoref{sec:restklassen} oder durch simultane Umformung einer
  Einheitsmatrix bei der Umformung von $K$ in eine Einheitsmatrix bestimmen.
  Mit dieser Matrix~$K^{-1}$ kann man dann den Geheimtext auf die gleiche
  Weise entschlüsseln, wie man den Klartext verschlüsselt hat: $v_{i} =
  w_{i}\cdot K^{-1}$. Nach der Kodierung durch Buchstaben
  ($0\rightarrow\mathtt{a}$) ergibt sich dann auch wieder der Klartext
  \texttt{wasser}.
  \begin{gather*}
    v = \begin{pmatrix}24& 14\\8& 16\\9& 18\end{pmatrix}\cdot
       \begin{pmatrix}4& 5\\ 17& 23\end{pmatrix}
       = \begin{pmatrix}22& 0\\18& 18\\4& 17\end{pmatrix}
  \end{gather*}

  \begin{minipage}{.45\linewidth}
    \begin{align*}
      \begin{gmatrix}[p]
        7& 3\\ 5& 8
      \end{gmatrix} &
         \begin{gmatrix}[p]
           1& 0\\ 0&1
           \rowops
           \mult{0}{\cdot 15}
         \end{gmatrix}\\
      \begin{gmatrix}[p]
        1& 19\\ 5& 8
      \end{gmatrix} &
         \begin{gmatrix}[p]
           15& 0\\ 0&1
           \rowops
           \add[21]{0}{1}
         \end{gmatrix}\\
      \begin{gmatrix}[p]
        1& 19\\ 0& 17
      \end{gmatrix} &
         \begin{gmatrix}[p]
           15& 0\\ 3&1
           \rowops
           \mult{1}{\cdot 23}
         \end{gmatrix}\\
      \begin{gmatrix}[p]
        1& 19\\ 0& 1
      \end{gmatrix} &
         \begin{gmatrix}[p]
           15& 0\\ 17& 23
           \rowops
           \add[7]{1}{0}
         \end{gmatrix}\\
      \begin{gmatrix}[p]
        1& 0\\ 0& 1
      \end{gmatrix} &
         \begin{gmatrix}[p]
           4& 5\\ 17& 23
         \end{gmatrix}
    \end{align*}
  \end{minipage}%
  \begin{minipage}{.55\linewidth}
    Mit etwas Glück fällt auf, dass 7 eine Einheit von $\Z_{26}$ ist und man so
    leicht in der oberen linken Ecke eine 1 erzeugen kann. Das Inverse zu 7 ist
    15, daher wird die erste Zeile mit 15 durchmultipliziert.

    Dann ist es leicht in der unteren Zeile aus dem linken Element eine 0 zu
    machen: $0 = 21\cdot 1+5\pmod{26}$.

    17 ist wieder eine Einheit, so dass eine 1 durch Multiplikation mit 23
    erzeugt werden kann: $23\cdot17\pmod{26} = 1$.

    Aus der 19 lässt sich jetzt wiederum sehr leicht eine 0 erzeugen:
    $0=1\cdot7+19\pmod{26}$.
  \end{minipage}
\end{enumerate}

\subsection*{Aufgabe 2}
Die Kodierung der Nachricht \texttt{hund} ist $v\in\Z_{26}^{2\times2}$ und die
des Geheimtexts \texttt{AFFE} ist $w\in\Z_{26}^{2\times2}$, wobei \texttt{a}
im Klartext bzw. \texttt{A} im Geheimtext durch 0 kodiert wird.
\begin{gather*}
  v = \begin{pmatrix}7& 20\\13& 3\end{pmatrix}\qquad
     w = \begin{pmatrix}0& 5\\5& 4\end{pmatrix}
\end{gather*}
Es ist jetzt nach einer Matrix~$M$ gesucht, die $w=v\cdot M$ erfüllt, d.\,h.
$M=v^{-1}\cdot w$. Mit dem Verfahren aus Aufgabe~1 ergibt sich $v^{-1}$ in
4~Schritten (1: $v_{1}=15\cdot v_{1}$, 2: $v_{2} =13\cdot v_{1}+v_{2}$, 3:
$v_{2}=9\cdot v_{2}$, 4: $v_{1}=12\cdot v_{2}+v_{1}$).
\begin{gather*}
  M = v^{-1}\cdot w =
     \begin{pmatrix}
       15& 4\\13& 9
     \end{pmatrix} \cdot
     \begin{pmatrix}
       0& 5\\5& 4
     \end{pmatrix} =
     \begin{pmatrix}
       20& 13\\19& 23
     \end{pmatrix}
\end{gather*}

\subsection*{Aufgabe 3}
Diese Aufgabe war eigentlich nur ein Test, ob man in der Vorlesung aufgepasst
hat, weil die Antwort bereits in \autoref{sec:tausch} gegeben wurde.

Ob die Abbildung bijektiv ist oder nicht, hängt nicht von $b$ ab.
Es hängt allein von $a$ ab, ob zwei Zeichen~$x_{1},x_{2}$ durch das gleiche
Zeichen ($E(x_{1}) = E(x_{2})$) verschlüsselt werden.
\begin{gather*}
  ax_{1} + b \equiv_{k} ax_{2}+ b \qquad\gdw\qquad
     ax_{1} \equiv_{k} ax_{2}
\end{gather*}

Haben $k$ und $a$ einen gemeinsamen Teiler~$\ggT(k,a)\ne1$, so ist die
Entschlüsselung der Null beispielsweise nicht mehr eindeutig, denn $E(0) =
0\cdot a = 0$ und
\begin{gather*}
  E\Bigl(\frac{k}{\ggT(k,a)}\Bigr) \equiv \frac{k}{\ggT(k,a)} \cdot a
     \equiv k\cdot \underbrace{\frac{a}{\ggT(k,a)}}_{\in\Z_{k}, > 1}
     \equiv 0 \pmod{k}
\end{gather*}

Also muss $a$ teilerfremd zu $k$ sein, damit alle $\Phi_{a,b}$ bijektiv sind.

\help{Warum ist das hinreichend?}: Der Versuch einer Erklärung:
Es gilt $ax_{1}\equiv_{k} ax_{2}$ \gdw $a(x_{1}-x_{2}) = l\cdot k$. Da $a$
teilerfremd zu $k$, muss $l$ ein Vielfaches von $a$ sein, also $l=\lambda a$.
\help{Stimmt das? Ich will darauf hinaus, dass $a$ die linke Seite teilt, also
  auch die rechte teilen muss, aber es teilt nicht $k$.}
Es gilt demnach $a(x_{1}-x_{2}) = \lambda ak$ \gdw $x_{1}-x_{2} = \lambda k$.
Da $x_{1},x_{2}\in\Z_{k}$, ist $-k < x_{1}-x_{2} < k$. Das einzige $\lambda$,
das die Gleichung erfüllt, ist $\lambda=0$. Also ist $x_{1}-x_{2}=0$ und damit
gilt die Kongruenz, wenn $a$ und $k$ teilerfremd sind, nur für gleiche $x$.
Für unterschiedliche $x$ ergeben sich unterschiedliche Verschlüsselungen, die
$\Phi_{a,b}$ ist also bijektiv.

\section{Blatt 3}

\subsection*{Aufgabe 1}
\begin{enumerate}[a)]
 \item Für den Kasiski-Test muss man Wiederholungen von Zeichenketten finden,
  die länger sind als 2 Zeichen, Beispiele:
  \begin{center}
    \begin{tabular}{l|cl}
      Zeichenkette & Auftreten & Abstand\\
      \hline
      \texttt{TDMHZGNMWK} & 92, 182 & $90 = 2\cdot 3^{2}\cdot5$\\
      \texttt{BXMFF} & 87, 147& $60 = 2^{2}\cdot 3\cdot5$\\
      \texttt{ZHUM} & 256, 296& $40 = 2^{3}\cdot5$\\
      \texttt{VIQM} & 71, 336& $265 = 5\cdot53$\\
      \texttt{KAH} & 8, 136& $128 = 2^{7}$\\
      \texttt{JTD} & 26, 76& $50=2\cdot5^{2}$
    \end{tabular}
  \end{center}

 \item Für den Friedman"=Test muss die Anzahl~$l_{i}$ des Auftretens der
  einzelnen Buchstaben gezählt werden, was wesentlich einfacher mit einem
  Programm geht. Daraus kann man mit \autoref{eq:koinzi} den Koinzidenzindex
  für den Text bestimmen --~$I(c)\approx0,0412$~-- woraus sich mit
  \autoref{eq:fried-d} eine Periodenlänge von $d\approx13,38$ ergibt.

 \item Da vor allem 2 und 5 als Faktoren in den längeren Wiederholungen beim
  Kasiski"=Test auftritt und $d\approx13,38$ aus dem Friedman"=Test
  auf 10 deuten, ist eine erste Schätzung für die Periodenlänge~$d=10$.
\help{Stimmt das $d=13,38$?}

  \texttt{KAH} scheint eine zufällige Wiederholung zu sein, die nicht auf eine
  gleiche Verschlüsselung von gleichen Zeichenketten zurückzuführen ist.
\end{enumerate}

\subsection*{Aufgabe 2}
Mit der Periodenlänge $d=10$ ergeben sich vier mögliche Schlüsselwörter
\texttt{HNZIORADIO}, \texttt{RNZIORADIO}, \texttt{HNZIORAHIO} und
\texttt{RNZIORAHIO}, die alle keinen sinnvollen Klartext liefern.

Also korrigieren wir die Schätzung auf $d=5$. Damit ergibt sich das
Schlüsselwort \texttt{RADIO}, womit sich auch ein sinnvoller deutscher
Klartext ergibt.
\begin{center}
  \begin{tabular}{cccc}
    Spalte& häuf.\,Buchst.& Verschiebung& Verschl.\,v.\,\texttt{a}\\
    \hline
    1.& \texttt{V}& 17& \texttt{R}\\
    2.& \texttt{E}& 0& \texttt{A}\\
    3.& \texttt{H}& 4& \texttt{D}\\
    4.& \texttt{M}& 8& \texttt{I}\\
    5.& \texttt{S}& 14& \texttt{O}
  \end{tabular}
\end{center}

\subsection*{Aufgabe 3}
Den hoechsten Organisationsstand erfuhr die Kryptologie in Venedig, wo sie in
Form einer staatlichen Buerotaetigkeit ausgeuebt wurde. Es gab
Schluesselsekretaere die ihr Buero im Dogenpalast hatten und fuer ihre
Taetigkeit rund zehn Dukaten im Monat bekamen. Es wurde dafuer gesorgt, dass
sie waehrend ihrer Arbeit nicht gestoert wurden. Sie durften ihre Bueros aber
auch nicht verlassen, bevor sie eine gestellte Aufgabe geloest hatten.

\clearpage
\pdfbookmark[0]{Index}{index}
\printindex

\end{document}
