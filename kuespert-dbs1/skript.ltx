% Einige zusätzliche Informationen für rubber
%  rubber erkennt nicht, dass die Datei weg kann, daher sagen wir es ihm
% rubber: clean $base.thm
%  rubber soll nach Änderungen an der Datei nochmal bauen
% rubber: watch $base.thm
% rubber: index.tool      xindy
% rubber: index.language  german-din
%
% scrreprt trifft am Besten die Bedürfnisse eines Skripts, das ganze wird
% zweiseitig (twoside), d.h. es wird zwischen linker und rechter Seite
% unterschieden, und wir verwenden zwischen den Absätzen einen Abstand
% von einer halben Zeile (halfparskip) und dafür keinen Absatzeinzug,
% wobei die letzte Zeile eines Absatzes zu min. 1/4 leer ist.

\RequirePackage[l2tabu,orthodox]{nag}  % nag überprüft den Text auf veraltete
                   % Befehle oder solche, die man nicht in LaTeX verwenden
                   % soll -- l2tabu-Checker in LaTeX

\RequirePackage[ngerman=ngerman-x-latest]{hyphsubst} % einbinden der neuen
                   % Trennmuster, diese korrigieren einige Fehler der alten
                   % und bieten mehr Trennstellen

\documentclass[ngerman,parskip=half*,twoside]{scrreprt}
\usepackage{scrhack}
\usepackage{ifthen}
\usepackage{index}
% \usepackage[final]{graphicx}  % Für Grafiken
\usepackage{xcolor}
\usepackage[draft=false,colorlinks,bookmarksnumbered,linkcolor=blue,breaklinks]{hyperref}

\usepackage[utf8]{inputenc}
\usepackage{babel}
\usepackage[T1]{fontenc}        % T1-Schriften notwendig für PDFs
\usepackage{textcomp}           % wird benötigt, damit der \textbullet
                                % für itemize in lmodern gefunden wird.

\usepackage[intlimits,leqno]{amsmath}
\usepackage[all,warning]{onlyamsmath}  % warnt bei Verwendung von nicht
                                       % amsmath-Umgebungen z.\,B. $$...$$
\usepackage{amssymb}     % wird für \R, \C,... gebraucht
\usepackage{fixmath}     % ISO-konforme griech. Buchstaben
\usepackage[euro]{isonums} % definiert Komma als Dezimaltrennzeichen

\usepackage[amsmath,thmmarks,hyperref]{ntheorem} % für die Theorem-Umgebungen
                                                 % (satz, defini, bemerk)
\usepackage{xspace}      % wird weiter unten gebraucht

\usepackage{paralist}    % besseres enumerate und itemize und neue
                         % compactenum/compactitem; s. texdoc paralist

\usepackage{svn}         % Zum Auswerten und ordentlichen Darstellen der
                         % SVN-Schlüsselwörter (s. vor \begin{document})
                         % dafür muss in SVN noch das Flag svn:keywords
                         % auf "LastChangedRevision LastChangedDate"
                         % gesetzt werden
\usepackage{ellipsis}    % Korrektur für \dots
\usepackage{fixltx2e}
\usepackage[final,babel]{microtype} % Verbesserung der Typographie
\usepackage{mathtools}   % Zur Definition von \abs und \norm
\usepackage{todonotes}   % definiert den Befehl \todo{} um sich leicht
                         % Markierungen für offene Aufgaben zu setzen; wird
                         % auch für \help (s.u.) verwendet
\usepackage{tikz-er2}
\usepackage{braket}

%\usetikzlibrary{positioning}

% Damit auch die Zeichen im Mathemode in Überschriften fett sind
% <news:lzfyyvx3pt.fsf@tfkp12.physik.uni-erlangen.de>
\addtokomafont{sectioning}{\boldmath}

% nach dem Theoremkopf wird ein Zeilenumbruch eingefügt, die Schrift des
% Körpers ist normal und der Kopf wird fett gesetzt
\theoremstyle{break}
\theoremnumbering{arabic}
\theorembodyfont{\normalfont}
\theoremheaderfont{\normalfont\bfseries}

% Das Ende von Umgebungen, für die kein Beweis erbracht wurde, soll mit einer
% leeren Box gekennzeichnet werden. Wenn jedoch ein Beweis erbracht wurde,
% soll kein Zeichen ausgegeben werden (die ausgefüllte Box vom proof wird
% verwendet); man beachte die spezielle Definition von \theoremheaderfont für
% die Umgebung proof
% \newboolean{hasproof}
% \theoremheaderfont{\global\hasprooffalse\normalfont\bfseries}
% \theoremsymbol{\ifthenelse{\boolean{hasproof}}{}{\ensuremath{_\Box}}}

% Die folgenden Umgebungen werden einzeln nummeriert und am Ende jedes
% Kapitels zurückgesetzt
\newtheorem{satz}{Satz}[chapter]
\newtheorem{bemerk}{Bemerkung}[chapter]
\newtheorem{defini}{Definition}[chapter]
\newtheorem{bsp}{Beispiel}[chapter]
\newtheorem{festl}{Festlegung}[chapter]

% Die folgenden Theoremumgebungen bekommen keine Nummer
\theoremstyle{nonumberbreak}
\newtheorem{fakt}{Fakt}

% \theoremheaderfont{\global\hasprooftrue\scshape}
\theoremheaderfont{\scshape}
\theorembodyfont{\normalfont}
% Das Zeichen am Ende eines Beweises
\theoremsymbol{\ensuremath{_\blacksquare}}
% \theoremsymbol{q.\,e.\,d.}
\newtheorem{proof}{Beweis:}

% Hier die Definition, wie \autoref die Umgebungen nennen soll, die mit
% \newtheorem definiert wurden
\newcommand*{\satzautorefname}{Satz}
\newcommand*{\bemerkautorefname}{Bemerkung}
\newcommand*{\definiautorefname}{Definition}
\newcommand*{\bspautorefname}{Beispiel}
\newcommand*{\festlautorefname}{Festlegung}
% Zwischen Unter- und Unterunterabschnitten sollte nicht unterschieden
% werden.
\renewcommand*{\subsectionautorefname}{Abschnitt}
\renewcommand*{\subsubsectionautorefname}{Abschnitt}

\pagestyle{headings}

\newcommand*{\R}{\mathbb{R}}      % reelle Zahlen
\newcommand*{\C}{\mathbb{C}}      % komplexe Zahlen
\newcommand*{\N}{\mathbb{N}}      % natürliche Zahlen
\newcommand*{\Q}{\mathbb{Q}}      % gebrochene Zahlen
\newcommand*{\Z}{\mathbb{Z}}      % ganze Zahlen

% Wenn irgendwo Unklarheiten zum Inhalt im Skript auftreten, können sie
% einfach mit \help{Ich verstehe das nicht} hervorgehoben werden. Dies
% macht es leichter sie alle zu finden und auch ganz einfach
% auszublenden, indem man den Befehl einfach leer definiert
\newcommand*{\help}[1]{\todo[color=green!40]{#1}}

% Um wichtige Begriffe im Text überall gleich vorzuheben (gleiches
% Markup), sollte dieser Befehl verwendet werden. Das Argument wird
% automatisch als Indexeintrag verwendet. Dieser kann aber auch als
% optionales Argument selbst bestimmt werden.
\newcommand*{\highl}[2][]{\textbf{\boldmath{#2}}%
  \ifthenelse{\equal{#1}{}}{\index{#2}}{\index{#1}}%
}

% Befehl für die Darstellung der Gliederungsüberschriften im Index
\newcommand*{\lettergroup}[1]{\minisec{#1}}

% Für Leute, die nicht gern o.\,B.\,d.\,A. jedesmal eintippen wollen
\newcommand*{\obda}{o.\,B.\,d.\,A.\xspace}

% Um sicherzustellen, dass jeder Betrag/jede Norm links und rechts die
% Striche bekommt, sind diese Befehle da. Damit kann man nicht die
% rechten Striche vergessen und es wird etwas übersichtlicher. Aus
% mathtools.pdf, z. B. \abs[\big]{\abs{a}-\abs{b}} \leq \abs{a+b}
\DeclarePairedDelimiter{\abs}{\lvert}{\rvert}
\DeclarePairedDelimiter{\norm}{\lVert}{\rVert}

% Das original Epsilon sieht nicht so toll aus
\renewcommand*{\epsilon}{\varepsilon}
% ... und mancheinem gefällt auch das Phi nicht
\renewcommand*{\phi}{\varphi}

% Der Befehl \coloneq definiert ein := und ist aus dem Paket txfonts
% kopiert.
\newcommand*{\coloneq}{\mathrel{\mathop:}=}

\DeclareMathOperator{\dom}{dom}  % Domain

\makeindex

\SVN $LastChangedRevision$
\SVN $LastChangedDate$

\begin{document}

\title{Datenbanksysteme 1}
\author{Prof.\,Dr.\,Klaus Küspert}
\date{Semester: WS 2009/10}
\maketitle

\clearpage
\chapter*{Vorwort}

{\itshape
  Dieses Dokument wurde als Skript für die auf der
  Titelseite genannte Vorlesung erstellt und wird jetzt im Rahmen des
  Projekts
  "`\href{http://uni-skripte.lug-jena.de/}
  {Vorlesungsskripte der Fakultät für Mathematik}
  \href{http://uni-skripte.lug-jena.de/}{und Informatik}"'
  weiter betreut. Das
  Dokument wurde nach bestem Wissen und Gewissen angefertigt. Dennoch
  garantiert weder der auf der Titelseite genannte Dozent, die Personen,
  die an dem Dokument mitgewirkt haben, noch die
  Mitglieder des Projekts für dessen Fehlerfreiheit. Für etwaige Fehler
  und dessen Folgen wird von keiner der genannten Personen eine Haftung
  übernommen. Es steht jeder Person frei, dieses Dokument zu lesen, zu
  verändern oder auf anderen Medien verfügbar zu machen, solange ein
  Verweis auf die Internetadresse des Projekts
  \url{http://uni-skripte.lug-jena.de/}
  enthalten ist.

  Diese Ausgabe trägt die Versionsnummer~\SVNLastChangedRevision{} und ist vom
  \SVNDate{}. Eine neue Ausgabe könnte auf der Webseite des Projekts verfügbar
  sein.

  Jeder ist dazu aufgerufen, Verbesserungen, Erweiterungen und
  Fehlerkorrekturen für das Skript einzureichen bzw. zu melden oder diese
  selbst einzupflegen -- einfach eine E-Mail an die
  \href{mailto:uni-skripte@lug-jena.de}{Mailingliste
  \nolinkurl{<uni-skripte@lug-jena.de>}} senden. Weitere Informationen
  sind unter der oben genannten Internetadresse verfügbar.

  Hiermit möchten wir allen Personen, die an diesem Skript mitgewirkt
  haben, vielmals danken:
  \begin{itemize}
   \item \href{mailto:jens@kubieziel.de}{Jens Kubieziel \nolinkurl{<jens@kubieziel.de>}} (2010)
  \end{itemize}
}

\clearpage
\pdfbookmark[0]{Inhaltsverzeichnis}{inhaltsverzeichnis}
\tableofcontents

\clearpage
\pdfbookmark[0]{Auflistung der Sätze}{theoremlist}
\chapter*{Auflistung der Theoreme}

\pdfbookmark[1]{Sätze}{satzlist}
\section*{Sätze}
\theoremlisttype{optname}
\listtheorems{satz}

\pdfbookmark[1]{Definitionen und Festlegungen}{definilist}
\section*{Definitionen und Festlegungen}
% \theoremlisttype{all}
\listtheorems{defini,festl}

\chapter*{Vorwort}

Das Dokument spiegelt die Vorlesung zu Datenbanksystemen~1 wider. Es
entspricht \emph{nicht} der von Herrn Küspert gehaltenen Vorlesung,
sondern stellt vielmehr eine Zusammenstellung diverser Fakten aus der
Vorlesung dar. Daher können hier Dinge fehlen oder auch andere Fakten
erwähnt sein. Wenn ihr also das Skript zufällig im Web gefunden habt
und für die Vorlesung lernen wollt, haltet euch an die Homepage des
\href{http://www.minet.uni-jena.de/dbis/}{Lehrstuhls für Datenbanken
  und Informationssysteme}.


\chapter{Einleitung}
\label{cha:einleitung}

\section{Anforderung an Datenbanksysteme}
\label{sec:anford-an-datenb}


Zu Anfang wollen wir uns die Frage stellen, ob wir Datenbanksysteme
überhaupt brauchen. Haben diese einen Nutzen, sind das nur Konstrukte
der Theorie oder gibt es Probleme, die sich damit lösen lassen?
Schließlich könnte man auf die Idee kommen, alle seine Daten auf einem
Datenträger abzulegen. Das heißt, diese auf der Festplatte, USB"=Stick
oder ähnlichem zu speichern. Von dort werden die Daten dann wieder
abgerufen und alles ist gut.

Bei großen Datenmengen und Zugriff von verschiedenen Seiten ist
schnell klar, dass dieser Weg nicht korrekt sein kann. Man stelle sich
eine große Firma vor, die deren Mitarbeiterstammdaten verwaltet. Für
jeden Mitarbeiter wird eine Datei angelegt. Schon bei einer geringen
Zahl an Mitarbeitern wird die Suche nach dem korrekten Datensatz
problematisch. Insbesondere wenn mehrere den gleichen Namen
besitzen. Weiterhin entstehen Probleme, wenn mehrere Kollegen auf
denselben Datensatz schreibend zugreifen. Diese Probleme erweitern
sich schnell, wenn die Datensätze ausgewertet werden sollen,
d.\,h. wie ist das Durchschnittsgehalt in der Abteilung oder der
Firma, wer wurde nach September 1996 eingestellt etc.


Daher kann eine solche Datenhaltung nicht (in allen Fällen) der
richtige Weg sein. Welche Anforderungen sollte man an ein
Datenbanksystem stellen?
\begin{description}
\item[Persistente Datenhaltung] Nach dem Abschluss einer Transaktion
  (Speichern) bleibt das Ergebnis dauerhaft erhalten.
\item[Große Datenmenge] Das Datenbanksystem soll mit beliebig großen
  Datenmengen (Tera-, Petabyte etc.) umgehen können.
\item[Hohe Verfügbarkeit] Datenbestände sollen 24/7 abruf- und
  bearbeitbar sein. Gerade bei großen Webseiten gibt es keine
  Wartungsfenster mehr. Vielmehr muss diese rund um die Uhr online sein.
\item[Flexibilität] Das Datenbanksystem muss in verschiedener Weise
  Flexibilität garantieren können. Dazu gehört, dass Daten flexibel
  ausgewertet werden können.
  \begin{itemize}
  \item Welche Daten haben Eigenschaft x?
  \item Welche Daten sind größer als y?
  \item Welche Daten haben Eigenschaft x und sind größer als y?
  \item etc.
  \end{itemize}
  Weiterhin sollen die Daten nicht notwendigerweise nur an einem
  Standort gespeichert werden. Vielmehr ist es sinnvoll, Datensätze zu
  verteilen und trotzdem eine Auswertbarkeit \emph{aller} Daten zu
  haben. Große Anbieter benötigen die Möglichkeit der
  Lastverteilung. Das heißt, es wird von vielen Rechnern auf einem
  Datenbestand zugegriffen. Ein Beispiel sind die Server der Wikipedia.
\item[Benutzerfreundlichkeit] Die Datenabfrage soll so
  benutzerfreundlich wie möglich sein.
\item[Sicherheit] Der Punkt Sicherheit hat wieder mehrere Aspekte. Zum
  einen soll es Sicherheit vor Datenverlsut geben. Also auch bei einem
  plötzlichen Ausfall des Servers sollen die Daten nicht komplett
  verloren sein. Weiterhin sollte kein Unbefugter auf Daten zugreifen
  oder diese gar ändern können. Insbesondere ist die Rechteverwaltung
  granular, d.\,h. man kann angeben, wer Daten nur lesen, schreiben
  etc. darf.
\end{description}
Weitere Anforderungen sind denkbar.

Eine Datenhaltung auf Dateisystemebene erfüllt die oben genannten
Anforderungen nur in sehr beschränkter Art und Weise. Die
Datenbanktechnik soll daher eine Antwort geben.


\section{Begriffe}
\label{sec:begriffe}

Im folgenden sollen einige wichtige Begriffe für die Vorlesung
definiert werden.

\begin{defini}[Datenbank]
  Ein strukturierte Sammlung von Daten bzw. Datensätzen wird als
  \highl{Datenbank bezeichnet}.
\end{defini}

\begin{defini}[DBMS, DBVS]
  Ein \highl{Datenbankmanagementsystem} (\highl{DBMS}) oder
  \highl{Datenbankverwaltungssystem} (\highl{DBVS}) verwaltet die
  Datenbestände, d.\,h. alle Zugriffe gehen \emph{ausschließlich} über
  das DBMS. Es übt die Kontrolle über die Datenbestände aus.
\end{defini}

\begin{defini}[Integritätsbedingungen]
  Integritätsbedingungen sind Bedingungen, die an die Daten gestellt
  werden. Die Aufgabe des DBMS ist es u.\,a. die Einhaltung dieser
  Bedingungen zu überwachen. 
\end{defini}

\section{Architekturen}
\label{sec:architekturen}

Üblicherweise arbeiten verschiedene Personengruppen an einem
Datenbanksystem mit. Es gibt Adminstratoren der Datenbank sowie des
Betriebssystems, Benutzer und ggf. andere Rollen. Alle haben eine
andere Sicht auf das Datenbanksystem. Daher bietet sich an, eine
Systemstruktur aus Komponenten, Ebenen, Schnittstellen etc. zu
erschaffen. Diese abstrahiert die Sichtweise und führt dadurch für die
Benutzerrollen zu einer Verringerung der Komplexität. Diese
Abstraktion wird als \highl{Architektur} bezeichnet. Im folgenden
wollen wir verschiedene Architekturen  kennenlernen.

\subsection{ANSI-SPARC-Architektur}
\label{sec:ansi-sparc-arch}

Die \highl{ANSI-SPARC-Architektur} wird manchmal als
\highl{Drei-Schema-Architektur} bezeichnet und ist ein abstraktes
Design für ein DBMS. Der Namensgeber war ANSI"=SPARC und steht für
American National Standards Institute, Standards Planning And
Requirements Committe. Der Vorschlag\footnote{ANSI/X3/SPARC Study
  Group on Data Base Management Systems: (1975), Interim Report. FDT,
  ACM SIGMOD bulletin. Volume~7, No.\,2} stammt aus dem Jahr~1975 und
enthält eine Aufteilung in drei Ebenen.
\begin{description}
\item[Externe Ebene] stellt Benutzern individuelle Benutzersichten,
  wie Formulare, Listen etc. bereit
\item[Konzeptionelle Ebene] beschreibt, welche Daten gespeichert sind
  und wie deren Beziehung untereinander ist. Designziel ist hier eine
  vollständige und redundanzfreie Darstellung aller zu speichernden
  Informationen.
\item[Interne Ebene] beschreibt, wie und wo die Daten gespeichert
  werden. Dies ist die physische Sicht der Datenbank auf den
  Computer. Das Designziel ist ein effizienter Zugriff auf die
  Informationen. 
\end{description}

Der Vorteil dieser Architektur liegt in der physischen wie logischen
Datenunabhängigkeit. Durch die Trennung der Ebenen kann beispielsweise
das Speichermedium gewechselt werden ohne das dies Einfluss auf die
konzeptionelle oder externe Ebene hätte. Weiterhin wirken sich
Änderungen im Layout der Datenbank nicht auf Formulare oder andere
Schnittstellen aus. Details sind in dem Buch~\cite{ja76} erläutert.

\subsection{DIAM}
\label{sec:diam}

\todo{DIAM beschreiben}

\chapter{Datenmodellierung mit dem Entity-Relationship-Modell}
\label{cha:datenm-mit-ermodell}

\section{Einleitung}
\label{sec:einleitung-er}


Das Kapitel wird Begriffe wie Entity, Entitytyp, Wertebereich
einführen. Weiterhin lernen wir die grafische Darstellungsform von
Entity"=Relationship"=Modellen, die sogenannten
Entity"=Relationship"=Diagramme, kennen. Diese Modelle kürzen wir
durch ER"=Modell ab. Eingedeutscht könnte man auch von einem
Gegenstand"=Beziehungs"=Modell sprechen. ER"=Modelle beschreiben einen
Ausschnitt aus der realen Welt.

\begin{bsp}
Das Beispiel zeigt ein unvollständiges ER"=Diagramm.

  \begin{tikzpicture}[node distance=9em]
    \node[entity] (person) {Professor};
    \node[relationship] (reads) [right of=person] {liest} edge (person);
    \node[entity] (vorlesung) [right of=reads] {Vorlesung} edge
    (reads);
    \node[attribute] (name) [below left of=person] {Name} edge (person);
    \node[attribute] (fach) [below right of=person] {Fach} edge (person);
    \node[attribute] (telefon) [below of=person] {Telefon} edge
    (person);
    \node[attribute] (semester) [below of=reads] {Semester} edge
    (reads);
    \node[attribute] (titel) [above right of=vorlesung] {Titel} edge
    (vorlesung);
    \node[attribute] (zeitplan) [above left of=vorlesung] {Zeitplan}
    edge (vorlesung);
    \node[relationship] (empfiehlt) [below of=vorlesung] {emfpiehlt}
    edge (vorlesung);
    \node[entity] (buch) [below of=empfiehlt] {Buch} edge (empfiehlt);
    \node[attribute] (autor) [above left of=buch]  {Autor} edge
    (buch);
    \node[attribute] (butitel) [left of=buch] {Titel} edge (buch);
    \node[attribute] (isbn) [below left of=buch] {ISBN} edge (buch);
  \end{tikzpicture}
\end{bsp}
Datenbanksysteme unterstützen in aller Regel das ER"=Modell nicht
direkt. Stattdessen muss eine Umsetzung vom ER"=Modell zum
Datenbankmodell erfolgen.

\section{Entitäten, Attribute und Schlüssel}
\label{sec:entitaten}


\begin{defini}[Entität]
  Eine \highl{Entität} (vom engl.\,\textit{entity}) ist ein bestimmtes,
  wohlunterscheidbares Objekt.
\end{defini}

\begin{defini}[Entitätstyp]
  Ein \highl{Entitätstyp} ist eine Zusammenfassung von Entitäten mit
  gleichen charakteristischen Merkmalen.
\end{defini}

\begin{bsp}
  Die Angestellten Müller, Meier und Schulze sind Entitäten. Der
  Entitätstyp \texttt{ANGEST} steht für die Menge aller möglichen
  Angestellten. Weiterhin könnte es den Entitätstyp \texttt{GEBÄUDE},
  \texttt{ABTEILUNG} etc. geben.
\end{bsp}

\begin{bemerk}
  Verschiedene Entitätstypen müssen nicht disjunkt sein. Vergleiche
  die Entitytypen \texttt{PERSON} und \texttt{STUDENT}.
\end{bemerk}

\begin{defini}[Attribut]
  Ein \highl{Attribut} ist eine Eigenschaft des Entitätstyps. Jedem
  Entitätstyp $E$ wird eine nichtleere endliche Attributmenge $A$
  zugeordnet.
\end{defini}

\begin{bsp}
  \texttt{E=ANGEST} und \texttt{A=\{Personalnummer, Name, Vorname, Gehalt\}}
\end{bsp}

Allgemeiner lässt sich feststellen: $A=\{a_{1}, a_{2},
\ldots\}$. Dabei sind die $a_{i}$ die Attribute und $i<\infty$.

\begin{defini}[Wertebereich, Domäne, Domain]
  Jedem Attribut $a$ ist ein \highl{Wertbereich} $\dom(a)$
  zugeordnet. Dieser wird auch als \highl{Domain} oder \highl{Domäne}
  bezeichnet.
\end{defini}

\begin{bsp}
  \begin{itemize}
  \item $\dom(\text{Personalnummer})= \Z$
  \item $\dom(\text{Gehalt}) = \Set{g | 1000\leq g \leq 10000}$
  \end{itemize}
\end{bsp}

Die Festlegungen zum Wertebereich stellen einfache semantische
Integritätsbedingungen dar.

\begin{defini}[Schlüssel]
  Ein \highl{Schlüssel} dient zur eindeutigen Identifizierung einer
  Entität $e$ innerhalb des Entitätstyps $E$.
\end{defini}

\begin{bsp}\label{bsp:schluessel}
  Sei \texttt{E=ANGEST} und \texttt{A=\{Personalnummer, Name, Vorname,
    Gehalt\}}. Dann suchen wir eine Teilmenge $K\subseteq A$ so, dass
  die Attributwerte des Schlüssel eindeutig die Entität
  identifizieren. Beispielsweise könnte \texttt{K=\{Personalnummer\}}
  sein. Dabei müssen wir voraussetzen, dass die Personalnummer
  innerhalb des Unternehmens eindeutig ist.
\end{bsp}

\begin{bemerk}
  Sollte im \autoref{bsp:schluessel} die Personalnummer nicht
  eindeutig sein, so könnte man ein weiteres Attribut
  hinzufügen. Allgemein wird die Minimalität eines Schlüssels
  gefordert, d.\,h. $\nexists K'\subset K$ mit der Eigenschaft, dass
  $K'$ Schlüssel ist.

  Sollte es mehrere Schlüssel zur Auswahl geben, so werden diese als
  Schlüsselkandidaten bezeichnet. Einer davon wird dann als
  \highl{Primärschlüssel} gewählt. Üblicherweise wird dieser möglichst
  klein gewählt, d.\,h. er enthält wenig Attribute.

  Primäschlüssel werden manchmal "`künstlich"' gewählt. Meist
  existiert kein Schlüssel in natürlicher Weise oder er verliert diese
  Eigenschaft eventuell in der Zukunft.
\end{bemerk}

\section{Beziehungen}
\label{sec:beziehungen}


\begin{defini}[Beziehung, Relation]
  Eine \highl{Beziehung} oder \highl{Relation} ist eine Verknüpfung
  zwischen mindestens zwei Entitäten.
\end{defini}

\begin{bsp}
  Wir nehmen an, dass es zwei Entitätstypen \texttt{ANGEST} und
  \texttt{PROJEKT} gibt. Dann besteht zwischen einem Angestellten $a$
  und einem Projekt $p$ eine Beziehung, wenn $a$ an $p$
  arbeitet. Zwischen  Angestellten $a_{1}$ und $a_{2}$ besteht eine
  Beziehung, wenn $a_{1}$ Chef von $a_{2}$ ist.
\end{bsp}

\begin{defini}[Beziehungstyp]
  Ein \highl{Beziehungstyp} $E$ ist die Menge aller möglichen Beziehungen
  zwischen je einer Entität der beteiligten Entitätstypen $E_{i}$ (mit
  $i\in\N$). Man kann $R$ auch als kartesisches Produkt $R=E_{1}\times
  E_{2}\times\dotsc\times E_{n}$ auffassen.
\end{defini}

\begin{bsp}[Beziehungstypen]
  Man betrachtet in der Regel verschiedene Beziehungstypen. So hat
  jeder Angestellte eine Personalakte. Das heißt, die Entität
  Angestellter besitzt die Eigenschaft haben bezüglich der Entität
  Personalakte. Jeder hat genau eine. Also spricht man vom
  \highl{1:1"=Beziehungstyp}.

  Die Angestellten arbeiten in verschiedenen Abteilungen. Herr Müller
  arbeitet in der Finanz- und der Steuerabteilung, Freu Petermann im
  Verkauf und Frau Lehmann in der Geschäftsführung sowie in der
  Organisation. Somit kann jeder Angestellte in mehreren Abteilungen
  arbeiten. Man spricht vom \highl{1:n"=Beziehungstyp}.

  Schließlich arbeiten die Angestellten Müller, Meier und Schulze am
  Projekt Straßenbau, die Angestellten Müller und Petermann am Projekt
  Jahresabschluss sowie die Angestellten Fischer, Meier und Petermann
  am Projekt Einkaufsplanung. In dem Falle sind verschiedene
  Angestellte mit verschiedenen Projekten betraut und man spricht vom
  \highl{n:m"=Beziehungstyp}.
\end{bsp}

\begin{bemerk}[Integritätsbedingungen]
  \begin{itemize}
  \item Von jeder Beziehung $r_{i}$ geht \emph{genau eine} Kante aus.
  \item Nicht von jeder Entität $e$ muss eine Kante ausgehen.
  \end{itemize}
\end{bemerk}

\begin{defini}[Grad]
  Die Zahl der an einer Beziehung beteiligten Entitätstypen wird als
  \highl{Grad} bezeichnet.
\end{defini}

\section{Entity-Relationship-Diagramme}
\label{sec:entity-relat-diagr}

Die Entity"=Relationship"=Diagramme werden auch als ER"=Diagramme
bezeichnet und sind die grafische Darstellung von Entitäts- und
Beziehungstypen. Sie bestehen aus folgenden Elementen:
\begin{description}
\item[Entitätstyp] 
  \begin{tikzpicture}
    \node[entity] (e) {E};
  \end{tikzpicture}
\item[Beziehungstyp] 
  \begin{tikzpicture}
    \node[relationship] (r) {R};
  \end{tikzpicture}
\item[Attribut] 
  \begin{tikzpicture}
    \node[attribute] (a) {A};
  \end{tikzpicture}
\item[Schlüsselattribut] 
  \begin{tikzpicture}
    \node[attribute] (k) {\key{A}};
  \end{tikzpicture}
\end{description}

\begin{description}
\item[Zwingende Beziehung] Sei $R=E\times E'$. Betrachte $e_{1}\in
  E$. Dann gibt es stets mindestens ein $e_{2}\in E'$ mit dem $e_{1}$
  innerhalb von $R$ in Beziehung steht, $r=(e_{1}, e_{2})$.
\item[Optionale Beziehung] Entity $e_{1}$ darf in $E$ existieren, ohne
  dass es über $R$ zu einer Entität $e_{2}\in E'$ in Beziehung steht.
\end{description}

\begin{defini}[Kardinalität, Komplexität]
  Die \highl{Kardinalität} oder \highl{Komplexität} eines
  Beziehungstyps drückt aus, zu wie vielen Entitys $e_{j}\in E'$ ein
  Eintity $e_{i}\infty E$ in Beziehung stehen darf.
\end{defini}

\clearpage
\appendix
\begin{thebibliography}{99}
\bibitem{sasahe07} \textsc{Gunter Saake}, \textsc{Kai-Uwe Sattler},
  \textsc{Andreas Heuer}: Datenbanken: Konzepte und
  Sprachen. mitp-Verlag, Bonn, 3.\,Auflage, 2007
\bibitem{hesa03} \textsc{Andreas Heuer}, \textsc{Gunter Saake},
  \textsc{Kai-Uwe Sattler}: Datenbanken kompakt: Einstieg, Datenbanken
  im Web, CGI, ASP, Content Management, Tuning. mitp-Verlag, Bonn,
  2.\,Auflage, 2003
\bibitem{lalo95} \textsc{Stefan Lang}, \textsc{Peter C.\,Lockemann}:
  Datenbankeinsatz. Springer-Verlag, Berlin, 1.\,Auflage, 1995
\bibitem{kikoe} \textsc{Werner Kießling}, \textsc{Gerhard Köstler}:
  Multimedia-Kurs Datenbanksysteme, m. CD-ROM. Springer-Verlag,
  Berlin, 1.\,Auflage, 1998
\bibitem{ne96} \textsc{Karl Neumann}: Datenbanktechnik für
  Anwender. Hanser Fachbuch, 1996
\bibitem{moda97} \textsc{Alfred Moos}, \textsc{Gerhard Daues}:
  Datenbank-Engineering: Analyse, Entwurf und Implementierung
  relationaler Datenbanken mit SQL. Vieweg Verlagsgesellschaft,
  2.\,Auflage, 1997
\bibitem{maun07} \textsc{Günter Matthiessen}, \textsc{Michael
    Unterstein}: Relationale Datenbanken und SQL. Addison"=Wesley,
  München, 4.\,Auflage, 2007
\bibitem{ja76}\textsc{Donald Andrew Jardine}: The ANSI/SPARC DBMS
  Model. North-Holland Pub.\,Co., Amsterdam, 1977
\end{thebibliography}

\clearpage
\pdfbookmark[0]{Index}{index}
% Behebt das Problem der vielen "`overfull \hbox"' im Index
% <news:3419172.ueajl5DJLB@mjk.komascript.de>
\setlength{\parfillskip}{0pt plus 1fil}
\printindex

\end{document}
