% Einige zusätzliche Informationen für rubber
%  rubber erkennt nicht, dass die Datei weg kann, daher sagen wir es ihm
% rubber: clean $base.thm
%  rubber soll nach Änderungen an der Datei nochmal bauen
% rubber: watch $base.thm
% rubber: index.tool      xindy
% rubber: index.language  german-din
%
% scrreprt trifft am Besten die Bedürfnisse eines Skripts, das ganze wird
% zweiseitig (twoside), d.h. es wird zwischen linker und rechter Seite
% unterschieden, und wir verwenden zwischen den Absätzen einen Abstand
% von einer halben Zeile (halfparskip) und dafür keinen Absatzeinzug,
% wobei die letzte Zeile eines Absatzes zu min. 1/4 leer ist.

\RequirePackage[l2tabu,orthodox]{nag}  % nag überprüft den Text auf veraltete
                   % Befehle oder solche, die man nicht in LaTeX verwenden
                   % soll -- l2tabu-Checker in LaTeX

\RequirePackage[ngerman=ngerman-x-latest]{hyphsubst} % einbinden der neuen
                   % Trennmuster, diese korrigieren einige Fehler der alten
                   % und bieten mehr Trennstellen

\documentclass[draft,ngerman,parskip=half*,twoside]{scrreprt}
\usepackage{scrhack}
\usepackage{ifthen}
\usepackage{index}
% \usepackage[final]{graphicx}  % Für Grafiken
\usepackage{xcolor}
\usepackage[draft=false,colorlinks,bookmarksnumbered,linkcolor=blue,breaklinks]{hyperref}

\usepackage[utf8]{inputenc}
\usepackage{babel}
\usepackage[T1]{fontenc}        % T1-Schriften notwendig für PDFs
\usepackage{textcomp}           % wird benötigt, damit der \textbullet
                                % für itemize in lmodern gefunden wird.

\usepackage[intlimits,leqno]{amsmath}
\usepackage[all,warning]{onlyamsmath}  % warnt bei Verwendung von nicht
                                       % amsmath-Umgebungen z.\,B. $$...$$
\usepackage{amssymb}     % wird für \R, \C,... gebraucht
\usepackage{fixmath}     % ISO-konforme griech. Buchstaben
\usepackage[euro]{isonums} % definiert Komma als Dezimaltrennzeichen

\usepackage[amsmath,thmmarks,hyperref]{ntheorem} % für die Theorem-Umgebungen
                                                 % (satz, defini, bemerk)
\usepackage{xspace}      % wird weiter unten gebraucht

\usepackage{paralist}    % besseres enumerate und itemize und neue
                         % compactenum/compactitem; s. texdoc paralist

\usepackage{svn}         % Zum Auswerten und ordentlichen Darstellen der
                         % SVN-Schlüsselwörter (s. vor \begin{document})
                         % dafür muss in SVN noch das Flag svn:keywords
                         % auf "LastChangedRevision LastChangedDate"
                         % gesetzt werden
\usepackage{ellipsis}    % Korrektur für \dots
\usepackage{fixltx2e}
\usepackage[final,babel]{microtype} % Verbesserung der Typographie
\usepackage{mathtools}   % Zur Definition von \abs und \norm
\usepackage{todonotes}   % definiert den Befehl \todo{} um sich leicht
                         % Markierungen für offene Aufgaben zu setzen; wird
                         % auch für \help (s.u.) verwendet
\usepackage{tikz-er2}
\usepackage{braket}
\usepackage{listings}
\usepackage{booktabs}

%\usetikzlibrary{positioning}

% Damit auch die Zeichen im Mathemode in Überschriften fett sind
% <news:lzfyyvx3pt.fsf@tfkp12.physik.uni-erlangen.de>
\addtokomafont{sectioning}{\boldmath}

% nach dem Theoremkopf wird ein Zeilenumbruch eingefügt, die Schrift des
% Körpers ist normal und der Kopf wird fett gesetzt
\theoremstyle{break}
\theoremnumbering{arabic}
\theorembodyfont{\normalfont}
\theoremheaderfont{\normalfont\bfseries}

% Das Ende von Umgebungen, für die kein Beweis erbracht wurde, soll mit einer
% leeren Box gekennzeichnet werden. Wenn jedoch ein Beweis erbracht wurde,
% soll kein Zeichen ausgegeben werden (die ausgefüllte Box vom proof wird
% verwendet); man beachte die spezielle Definition von \theoremheaderfont für
% die Umgebung proof
% \newboolean{hasproof}
% \theoremheaderfont{\global\hasprooffalse\normalfont\bfseries}
% \theoremsymbol{\ifthenelse{\boolean{hasproof}}{}{\ensuremath{_\Box}}}

% Die folgenden Umgebungen werden einzeln nummeriert und am Ende jedes
% Kapitels zurückgesetzt
%\newtheorem{satz}{Satz}[chapter]
\newtheorem{bemerk}{Bemerkung}[chapter]
\newtheorem{defini}{Definition}[chapter]
\newtheorem{bsp}{Beispiel}[chapter]

% Die folgenden Theoremumgebungen bekommen keine Nummer
\theoremstyle{nonumberbreak}
%\newtheorem{fakt}{Fakt}

% \theoremheaderfont{\global\hasprooftrue\scshape}
\theoremheaderfont{\scshape}
\theorembodyfont{\normalfont}
% Das Zeichen am Ende eines Beweises
\theoremsymbol{\ensuremath{_\blacksquare}}
% \theoremsymbol{q.\,e.\,d.}
\newtheorem{proof}{Beweis:}

% Hier die Definition, wie \autoref die Umgebungen nennen soll, die mit
% \newtheorem definiert wurden
\newcommand*{\satzautorefname}{Satz}
\newcommand*{\bemerkautorefname}{Bemerkung}
\newcommand*{\definiautorefname}{Definition}
\newcommand*{\bspautorefname}{Beispiel}
\newcommand*{\festlautorefname}{Festlegung}
% Zwischen Unter- und Unterunterabschnitten sollte nicht unterschieden
% werden.
\renewcommand*{\subsectionautorefname}{Abschnitt}
\renewcommand*{\subsubsectionautorefname}{Abschnitt}

\pagestyle{headings}

%\newcommand*{\R}{\mathbb{R}}      % reelle Zahlen
%\newcommand*{\C}{\mathbb{C}}      % komplexe Zahlen
\newcommand*{\N}{\mathbb{N}}      % natürliche Zahlen
%\newcommand*{\Q}{\mathbb{Q}}      % gebrochene Zahlen
%\newcommand*{\Z}{\mathbb{Z}}      % ganze Zahlen

% Wenn irgendwo Unklarheiten zum Inhalt im Skript auftreten, können sie
% einfach mit \help{Ich verstehe das nicht} hervorgehoben werden. Dies
% macht es leichter sie alle zu finden und auch ganz einfach
% auszublenden, indem man den Befehl einfach leer definiert
\newcommand*{\help}[1]{\todo[color=green!40]{#1}}

% Um wichtige Begriffe im Text überall gleich vorzuheben (gleiches
% Markup), sollte dieser Befehl verwendet werden. Das Argument wird
% automatisch als Indexeintrag verwendet. Dieser kann aber auch als
% optionales Argument selbst bestimmt werden.
\newcommand*{\highl}[2][]{\textbf{\boldmath{#2}}%
  \ifthenelse{\equal{#1}{}}{\index{#2}}{\index{#1}}%
}

% Befehl für die Darstellung der Gliederungsüberschriften im Index
\newcommand*{\lettergroup}[1]{\minisec{#1}}

% Um sicherzustellen, dass jeder Betrag/jede Norm links und rechts die
% Striche bekommt, sind diese Befehle da. Damit kann man nicht die
% rechten Striche vergessen und es wird etwas übersichtlicher. Aus
% mathtools.pdf, z. B. \abs[\big]{\abs{a}-\abs{b}} \leq \abs{a+b}
%\DeclarePairedDelimiter{\abs}{\lvert}{\rvert}
%\DeclarePairedDelimiter{\norm}{\lVert}{\rVert}

% Das original Epsilon sieht nicht so toll aus
\renewcommand*{\epsilon}{\varepsilon}
% ... und mancheinem gefällt auch das Phi nicht
\renewcommand*{\phi}{\varphi}

% Der Befehl \coloneq definiert ein := und ist aus dem Paket txfonts
% kopiert.
%\newcommand*{\coloneq}{\mathrel{\mathop:}=}

\DeclareMathOperator{\dom}{dom}  % Domain

\makeindex

\SVN $LastChangedRevision$
\SVN $LastChangedDate$

\begin{document}

\title{Datenbanksysteme 1}
\author{Prof.\,Dr.\,Klaus Küspert}
\date{Semester: WS 2009/10}
\maketitle

\clearpage
\chapter*{Vorwort}

{\itshape
  Dieses Dokument wurde als Skript für die auf der
  Titelseite genannte Vorlesung erstellt und wird jetzt im Rahmen des
  Projekts
  "`\href{http://uni-skripte.lug-jena.de/}
  {Vorlesungsskripte der Fakultät für Mathematik}
  \href{http://uni-skripte.lug-jena.de/}{und Informatik}"'
  weiter betreut. Das
  Dokument wurde nach bestem Wissen und Gewissen angefertigt. Dennoch
  garantiert weder der auf der Titelseite genannte Dozent, die Personen,
  die an dem Dokument mitgewirkt haben, noch die
  Mitglieder des Projekts für dessen Fehlerfreiheit. Für etwaige Fehler
  und dessen Folgen wird von keiner der genannten Personen eine Haftung
  übernommen. Es steht jeder Person frei, dieses Dokument zu lesen, zu
  verändern oder auf anderen Medien verfügbar zu machen, solange ein
  Verweis auf die Internetadresse des Projekts
  \url{http://uni-skripte.lug-jena.de/}
  enthalten ist.

  Diese Ausgabe trägt die Versionsnummer~\SVNLastChangedRevision{} und ist vom
  \SVNDate{}. Eine neue Ausgabe könnte auf der Webseite des Projekts verfügbar
  sein.

  Jeder ist dazu aufgerufen, Verbesserungen, Erweiterungen und
  Fehlerkorrekturen für das Skript einzureichen bzw. zu melden oder diese
  selbst einzupflegen -- einfach eine E-Mail an die
  \href{mailto:uni-skripte@lug-jena.de}{Mailingliste
  \nolinkurl{<uni-skripte@lug-jena.de>}} senden. Weitere Informationen
  sind unter der oben genannten Internetadresse verfügbar.

  Hiermit möchten wir allen Personen, die an diesem Skript mitgewirkt
  haben, vielmals danken:
  \begin{itemize}
   \item \href{mailto:jens@kubieziel.de}{Jens Kubieziel \nolinkurl{<jens@kubieziel.de>}} (2010)
  \end{itemize}
}

\clearpage
\pdfbookmark[0]{Inhaltsverzeichnis}{inhaltsverzeichnis}
\tableofcontents

\clearpage
\pdfbookmark[0]{Auflistung der Sätze}{theoremlist}
\chapter*{Auflistung der Theoreme}

% \pdfbookmark[1]{Sätze}{satzlist}
% \section*{Sätze}
% \theoremlisttype{optname}
% \listtheorems{satz}

\pdfbookmark[1]{Definitionen und Festlegungen}{definilist}
\section*{Definitionen und Festlegungen}
% \theoremlisttype{all}
\listtheorems{defini,festl}

\chapter*{Vorwort}

Das Dokument spiegelt die Vorlesung zu Datenbanksystemen~1 wider. Es
entspricht \emph{nicht} der von Herrn Küspert gehaltenen Vorlesung,
sondern stellt vielmehr eine Zusammenstellung diverser Fakten aus der
Vorlesung dar. Daher können hier Dinge fehlen oder auch andere Fakten
erwähnt sein. Wenn ihr also das Skript zufällig im Web gefunden habt
und für die Vorlesung lernen wollt, haltet euch an die Homepage des
\href{http://www.minet.uni-jena.de/dbis/}{Lehrstuhls für Datenbanken
  und Informationssysteme}.


\chapter{Einleitung}
\label{cha:einleitung}

\section{Anforderung an Datenbanksysteme}
\label{sec:anford-an-datenb}


Zu Anfang wollen wir uns die Frage stellen, ob wir Datenbanksysteme
überhaupt brauchen. Haben diese einen Nutzen, sind das nur Konstrukte
der Theorie oder gibt es Probleme, die sich damit lösen lassen?
Schließlich könnte man auf die Idee kommen, alle seine Daten auf einem
Datenträger abzulegen. Das heißt, diese auf der Festplatte, USB"=Stick
oder ähnlichem zu speichern. Von dort werden die Daten dann wieder
abgerufen und alles ist gut.

Bei großen Datenmengen und Zugriff von verschiedenen Seiten ist
schnell klar, dass dieser Weg nicht korrekt sein kann. Man stelle sich
eine große Firma vor, die deren Mitarbeiterstammdaten verwaltet. Für
jeden Mitarbeiter wird eine Datei angelegt. Schon bei einer geringen
Zahl an Mitarbeitern wird die Suche nach dem korrekten Datensatz
problematisch. Insbesondere wenn mehrere den gleichen Namen
besitzen. Weiterhin entstehen Probleme, wenn mehrere Kollegen auf
denselben Datensatz schreibend zugreifen. Diese Probleme erweitern
sich schnell, wenn die Datensätze ausgewertet werden sollen,
d.\,h. wie ist das Durchschnittsgehalt in der Abteilung oder der
Firma, wer wurde nach September 1996 eingestellt etc.


Daher kann eine solche Datenhaltung nicht (in allen Fällen) der
richtige Weg sein. Welche Anforderungen sollte man an ein
Datenbanksystem stellen?
\begin{description}
\item[Persistente Datenhaltung] Nach dem Abschluss einer Transaktion
  (Speichern) bleibt das Ergebnis dauerhaft erhalten.
\item[Große Datenmenge] Das Datenbanksystem soll mit beliebig großen
  Datenmengen (Giga-, Tera-, Petabyte etc.) umgehen können.
\item[Hohe Verfügbarkeit] Datenbestände sollen 24/7 abruf- und
  bearbeitbar sein. Gerade bei großen Webseiten gibt es keine
  Wartungsfenster mehr. Vielmehr muss diese rund um die Uhr online sein.
\item[Flexibilität] Das Datenbanksystem muss in verschiedener Weise
  Flexibilität garantieren können. Dazu gehört, dass Daten flexibel
  ausgewertet werden können.
  \begin{itemize}
  \item Welche Daten haben Eigenschaft x?
  \item Welche Daten sind größer als y?
  \item Welche Daten haben Eigenschaft x und sind größer als y?
  \item etc.
  \end{itemize}
  Weiterhin sollen die Daten nicht notwendigerweise nur an einem
  Standort gespeichert werden. Vielmehr ist es sinnvoll, Datensätze zu
  verteilen und trotzdem eine Auswertbarkeit \emph{aller} Daten zu
  haben. Große Anbieter benötigen die Möglichkeit der
  Lastverteilung. Das heißt, es wird von vielen Rechnern auf einem
  Datenbestand zugegriffen. Ein Beispiel sind die Server der Wikipedia.
\item[Benutzerfreundlichkeit] Die Datenabfrage soll so
  benutzerfreundlich wie möglich sein.
\item[Sicherheit] Der Punkt Sicherheit hat wieder mehrere Aspekte. Zum
  einen soll es Sicherheit vor Datenverlust geben. Also auch bei einem
  plötzlichen Ausfall des Servers sollen die Daten nicht komplett
  verloren sein. Weiterhin sollte kein Unbefugter auf Daten zugreifen
  oder diese gar ändern können. Insbesondere ist die Rechteverwaltung
  granular, d.\,h. man kann angeben, wer Daten nur lesen, schreiben
  etc. darf.
\end{description}
Weitere Anforderungen sind denkbar.

Eine Datenhaltung auf Dateisystemebene erfüllt die oben genannten
Anforderungen nur in sehr beschränkter Art und Weise. Die
Datenbanktechnik soll daher eine Antwort geben.


\section{Begriffe}
\label{sec:begriffe}

Im folgenden sollen einige wichtige Begriffe für die Vorlesung
definiert werden. Diese sind zentral für die Vorlesung und ziehen sich
wie ein roter Faden durch die Unterlagen.

\begin{defini}[Datenbank]
  Ein strukturierte Sammlung von Daten bzw. Datensätzen wird als
  \highl{Datenbank} bezeichnet.
\end{defini}

\begin{defini}[DBMS, DBVS]
  Ein \highl{Datenbankmanagementsystem} (\highl{DBMS}) oder
  \highl[Datenbankverwaltungssystem]{-verwaltungssystem} (\highl{DBVS}) verwaltet die
  Datenbestände, d.\,h. alle Zugriffe gehen \emph{ausschließlich} über
  das DBMS. Es übt die Kontrolle über die Datenbestände aus.
\end{defini}

\begin{defini}[Integritätsbedingungen]
  Integritätsbedingungen sind Bedingungen, die an die Daten gestellt
  werden. Die Aufgabe des DBMS ist es u.\,a. die Einhaltung dieser
  Bedingungen zu überwachen. 
\end{defini}

\section{Architekturen}
\label{sec:architekturen}

Üblicherweise arbeiten verschiedene Personengruppen an einem
Datenbanksystem mit. Es gibt Adminstratoren der Datenbank sowie des
Betriebssystems, Benutzer und ggf. andere Rollen. Alle haben eine
andere Sicht auf das Datenbanksystem. Daher bietet sich an, eine
Systemstruktur aus Komponenten, Ebenen, Schnittstellen etc. zu
erschaffen. Diese abstrahiert die Sichtweise und führt dadurch für die
Benutzerrollen zu einer Verringerung der Komplexität. Diese
Abstraktion wird als \highl{Architektur} bezeichnet. Im folgenden
wollen wir verschiedene Architekturen  kennenlernen.

\subsection{ANSI-SPARC-Architektur}
\label{sec:ansi-sparc-arch}

Die \highl{ANSI-SPARC-Architektur} wird manchmal als
\highl{Drei-Schema-Architektur} bezeichnet und ist ein abstraktes
Design für ein DBMS. Der Namensgeber war ANSI"=SPARC und steht für
American National Standards Institute, Standards Planning And
Requirements Committe. Der Vorschlag\footnote{ANSI/X3/SPARC Study
  Group on Data Base Management Systems: (1975), Interim Report. FDT,
  ACM SIGMOD bulletin. Volume~7, No.\,2} stammt aus dem Jahr~1975 und
enthält eine Aufteilung in drei Ebenen.
\begin{description}
\item[Externe Ebene] stellt Benutzern individuelle Benutzersichten,
  wie Formulare, Listen etc. bereit
\item[Konzeptionelle Ebene] beschreibt, welche Daten gespeichert sind
  und wie deren Beziehung untereinander ist. Designziel ist hier eine
  vollständige und redundanzfreie Darstellung aller zu speichernden
  Informationen.
\item[Interne Ebene] beschreibt, wie und wo die Daten gespeichert
  werden. Dies ist die physische Sicht der Datenbank auf den
  Computer. Das Designziel ist ein effizienter Zugriff auf die
  Informationen. 
\end{description}

Der Vorteil dieser Architektur liegt in der physischen wie logischen
Datenunabhängigkeit. Durch die Trennung der Ebenen kann beispielsweise
das Speichermedium gewechselt werden ohne das dies Einfluss auf die
konzeptionelle oder externe Ebene hätte. Weiterhin wirken sich
Änderungen im Layout der Datenbank nicht auf Formulare oder andere
Schnittstellen aus. Details sind in dem Buch~\cite{ja76} erläutert.

\subsection{DIAM}
\label{sec:diam}

\todo{DIAM beschreiben}

\chapter{Datenmodellierung mit dem Entity-Relationship-Modell}
\label{cha:datenm-mit-ermodell}

\section{Einleitung}
\label{sec:einleitung-er}


Das Kapitel wird Begriffe wie Entity, Entitytyp, Wertebereich
einführen. Weiterhin lernen wir die grafische Darstellungsform von
Entity"=Relationship"=Modellen, die sogenannten
Entity"=Relationship"=Diagramme, kennen. Diese Modelle kürzen wir
durch ER"=Modell ab. Eingedeutscht könnte man auch von einem
Gegenstand"=Beziehungs"=Modell sprechen. ER"=Modelle beschreiben einen
Ausschnitt aus der realen Welt.

\begin{bsp}
Die \autoref{fig:er-diagramm} zeigt ein unvollständiges
ER"=Diagramm. Es beschreibt eine Vorlesung, die von einem Professor
gelesen wird. Der Professor empfiehlt den Studenten Bücher zur
Lektüre. Dabei ist dem Professor ein Name, eine Telefonnummer und ein
Fachgebiet zugeordnet. Andere Bestandteile des ER"=Diagramms haben
bestimmte Eigenschaften.

\begin{figure}[htb]
  \centering
  \begin{tikzpicture}[node distance=9em]
    \node[entity] (person) {Professor};
    \node[relationship] (reads) [right of=person] {liest} edge (person);
    \node[entity] (vorlesung) [right of=reads] {Vorlesung} edge
    (reads);
    \node[attribute] (name) [below left of=person] {Name} edge (person);
    \node[attribute] (fach) [below right of=person] {Fach} edge (person);
    \node[attribute] (telefon) [below of=person] {Telefon} edge
    (person);
    \node[attribute] (semester) [below of=reads] {Semester} edge
    (reads);
    \node[attribute] (titel) [above right of=vorlesung] {Titel} edge
    (vorlesung);
    \node[attribute] (zeitplan) [above left of=vorlesung] {Zeitplan}
    edge (vorlesung);
    \node[relationship] (empfiehlt) [below of=vorlesung] {emfpiehlt}
    edge (vorlesung);
    \node[entity] (buch) [below of=empfiehlt] {Buch} edge (empfiehlt);
    \node[attribute] (autor) [above left of=buch]  {Autor} edge
    (buch);
    \node[attribute] (butitel) [left of=buch] {Titel} edge (buch);
    \node[attribute] (isbn) [below left of=buch] {ISBN} edge (buch);
  \end{tikzpicture}  
  \caption{Beispiel eines ER-Diagramms}
  \label{fig:er-diagramm}
\end{figure}
\end{bsp}
Datenbanksysteme unterstützen in aller Regel das ER"=Modell nicht
direkt. Stattdessen muss eine Umsetzung vom ER"=Modell zum
Datenbankmodell erfolgen.

\section{Entitäten, Attribute und Schlüssel}
\label{sec:entitaten}


\begin{defini}[Entität]
  Eine \highl{Entität} (vom engl.\,\textit{entity}) ist ein bestimmtes,
  wohlunterscheidbares Objekt.
\end{defini}

\begin{defini}[Entitätstyp]
  Ein \highl{Entitätstyp} ist eine Zusammenfassung von Entitäten mit
  gleichen charakteristischen Merkmalen.
\end{defini}

\begin{bsp}
  Die Angestellten Müller, Meier und Schulze sind Entitäten. Der
  Entitätstyp \texttt{ANGEST} steht für die Menge aller möglichen
  Angestellten. Weiterhin könnte es den Entitätstyp \texttt{GEBÄUDE},
  \texttt{ABTEILUNG} etc. geben.
\end{bsp}

\begin{bemerk}
  Verschiedene Entitätstypen müssen nicht disjunkt sein. Vergleiche
  die Entitytypen \texttt{PERSON} und \texttt{STUDENT}.
\end{bemerk}

\begin{defini}[Attribut]
  Ein \highl{Attribut} ist eine Eigenschaft des Entitätstyps. Jedem
  Entitätstyp $E$ wird eine nichtleere endliche Attributmenge $A$
  zugeordnet.
\end{defini}

\begin{bsp}
  \texttt{E=ANGEST} und \texttt{A=\{Personalnummer, Name, Vorname, Gehalt\}}
\end{bsp}

Allgemeiner lässt sich feststellen: $A=\{a_{1}, a_{2},
\ldots\}$. Dabei sind die $a_{i}$ die Attribute und $i<\infty$.

\begin{defini}[Wertebereich, Domäne, Domain]
  Jedem Attribut $a$ ist ein \highl{Wertbereich} $\dom(a)$
  zugeordnet. Dieser wird auch als \highl{Domain} oder \highl{Domäne}
  bezeichnet.
\end{defini}

\begin{bsp}
  \begin{itemize}
  \item $\dom(\text{Personalnummer})= \N$
  \item $\dom(\text{Gehalt}) = \Set{g | 1000\leq g \leq 10000}$
  \end{itemize}
\end{bsp}

Die Festlegungen zum Wertebereich stellen einfache semantische
Integritätsbedingungen dar.

\begin{defini}[Schlüssel]\label{def:schluessel}
  Ein \highl{Schlüssel} dient zur eindeutigen Identifizierung einer
  Entität $e$ innerhalb des Entitätstyps $E$.
\end{defini}

\begin{bsp}\label{bsp:schluessel}
  Sei \texttt{E=ANGEST} und \texttt{A=\{Personalnummer, Name, Vorname,
    Gehalt\}}. Dann suchen wir eine Teilmenge $K\subseteq A$ so, dass
  die Attributwerte des Schlüssel eindeutig die Entität
  identifizieren. Beispielsweise könnte \texttt{K=\{Personalnummer\}}
  sein. Dabei müssen wir voraussetzen, dass die Personalnummer
  innerhalb des Unternehmens eindeutig ist.
\end{bsp}

\begin{bemerk}
  Sollte im \autoref{bsp:schluessel} die Personalnummer nicht
  eindeutig sein, so könnte man ein weiteres Attribut
  hinzufügen. Allgemein wird die Minimalität eines Schlüssels
  gefordert, d.\,h. $\nexists K'\subset K$ mit der Eigenschaft, dass
  $K'$ Schlüssel ist.

  Sollte es mehrere Schlüssel zur Auswahl geben, so werden diese als
  Schlüsselkandidaten bezeichnet. Einer davon wird dann als
  \highl{Primärschlüssel} gewählt. Üblicherweise wird dieser möglichst
  klein gewählt, d.\,h. er enthält wenig Attribute.

  Primäschlüssel werden manchmal "`künstlich"' gewählt. Meist
  existiert kein Schlüssel in natürlicher Weise oder er verliert diese
  Eigenschaft eventuell in der Zukunft.
\end{bemerk}

\section{Beziehungen}
\label{sec:beziehungen}


\begin{defini}[Beziehung, Relation]
  Eine \highl{Beziehung} oder \highl{Relation} ist eine Verknüpfung
  zwischen mindestens zwei Entitäten.
\end{defini}

\begin{bsp}
  Wir nehmen an, dass es zwei Entitätstypen \texttt{ANGEST} und
  \texttt{PROJEKT} gibt. Dann besteht zwischen einem Angestellten $a$
  und einem Projekt $p$ eine Beziehung, wenn $a$ an $p$
  arbeitet. Zwischen  Angestellten $a_{1}$ und $a_{2}$ besteht eine
  Beziehung, wenn $a_{1}$ Chef von $a_{2}$ ist.
\end{bsp}

\begin{defini}[Beziehungstyp]
  Ein \highl{Beziehungstyp} $E$ ist die Menge aller möglichen Beziehungen
  zwischen je einer Entität der beteiligten Entitätstypen $E_{i}$ (mit
  $i\in\N$). Man kann $R$ auch als kartesisches Produkt $R=E_{1}\times
  E_{2}\times\dotsc\times E_{n}$ auffassen.
\end{defini}

\begin{bsp}[Beziehungstypen]
  Man betrachtet in der Regel verschiedene Beziehungstypen. So hat
  jeder Angestellte eine Personalakte. Das heißt, die Entität
  Angestellter besitzt die Eigenschaft haben bezüglich der Entität
  Personalakte. Jeder hat genau eine. Also spricht man vom
  \highl{1:1"=Beziehungstyp}.

  Die Angestellten arbeiten in verschiedenen Abteilungen. Herr Müller
  arbeitet in der Finanz- und der Steuerabteilung, Freu Petermann im
  Verkauf und Frau Lehmann in der Geschäftsführung sowie in der
  Organisation. Somit kann jeder Angestellte in mehreren Abteilungen
  arbeiten. Man spricht vom \highl{1:n"=Beziehungstyp}.

  Schließlich arbeiten die Angestellten Müller, Meier und Schulze am
  Projekt Straßenbau, die Angestellten Müller und Petermann am Projekt
  Jahresabschluss sowie die Angestellten Fischer, Meier und Petermann
  am Projekt Einkaufsplanung. In dem Falle sind verschiedene
  Angestellte mit verschiedenen Projekten betraut und man spricht vom
  \highl{n:m"=Beziehungstyp}.
\end{bsp}

\begin{bemerk}[Integritätsbedingungen]
  \begin{itemize}
  \item Von jeder Beziehung $r_{i}$ geht \emph{genau eine} Kante aus.
  \item Nicht von jeder Entität $e$ muss eine Kante ausgehen.
  \end{itemize}
\end{bemerk}

\begin{defini}[Grad]
  Die Zahl der an einer Beziehung beteiligten Entitätstypen wird als
  \highl{Grad} bezeichnet.
\end{defini}

\section{Entity-Relationship-Diagramme}
\label{sec:entity-relat-diagr}

Die Entity"=Relationship"=Diagramme werden auch als ER"=Diagramme
bezeichnet und sind die grafische Darstellung von Entitäts- und
Beziehungstypen. Sie bestehen aus folgenden Elementen:
\begin{description}
\item[Entitätstyp] 
  \begin{tikzpicture}
    \node[entity] (e) {E};
  \end{tikzpicture}
\item[Beziehungstyp] 
  \begin{tikzpicture}
    \node[relationship] (r) {R};
  \end{tikzpicture}
\item[Attribut] 
  \begin{tikzpicture}
    \node[attribute] (a) {A};
  \end{tikzpicture}
\item[Schlüsselattribut] 
  \begin{tikzpicture}
    \node[attribute] (k) {\key{A}};
  \end{tikzpicture}
\end{description}

\begin{description}
\item[Zwingende Beziehung] Sei $R=E\times E'$. Betrachte $e_{1}\in
  E$. Dann gibt es stets mindestens ein $e_{2}\in E'$ mit dem $e_{1}$
  innerhalb von $R$ in Beziehung steht, $r=(e_{1}, e_{2})$.
\item[Optionale Beziehung] Entity $e_{1}$ darf in $E$ existieren, ohne
  dass es über $R$ zu einer Entität $e_{2}\in E'$ in Beziehung steht.
\end{description}

\begin{defini}[Kardinalität, Komplexität]
  Die \highl{Kardinalität} oder \highl{Komplexität} eines
  Beziehungstyps drückt aus, zu wie vielen Entitys $e_{j}\in E'$ ein
  Entity $e_{i}\in E$ in Beziehung stehen darf.
\end{defini}

\section{Schwache Entitytypen}
\label{sec:schwach-enttyp}

Manche Entitäten existieren nur in Verbindung mit anderen
Entitäten. Diese werden als \highl[Entität!schwache]{schwache Entität}
bezeichnet. Anders gesagt muss zur eindeutigen Identifizierung einer
Instanz eines schwachen Entitätstyps die Beziehung mit herangezogen
werden. Also identifizieren bestimmte Attributwerte der Entity
\emph{plus} die Beziehung  es eindeutig.

\begin{bsp}
  Manche Angestellte haben Kinder. Diese sollen ebenfalls mit in der
  Datenbank geführt werden. Diese Kinder "`existieren"' nur zusammen
  mit den Eltern. Im ER"=Diagramm wird das wie folgt dargestellt:

  \begin{tikzpicture}[node distance=9em]
    \node[entity] (angest) {ANGEST};
    \node[attribute] (pnr) [below left of=angest] {\key{PNR}} edge
    (angest);
    \node[attribute] (name) [below right of=angest] {Name} edge
    (angest);
    \node[ident relationship] (hat) [right of=angest] {hat} edge (angest);
    \node[weak entity] (kind) [right of=hat] {Kind} edge (hat);
    \node[attribute] (vorname) [above right of=kind] {\key{Vorname}} edge
    (kind);
    \node[attribute] (gebdat) [below right of=kind] {Geb.-Datum} edge (kind);
  \end{tikzpicture}

  Das heißt doppelte Linien beim Entity- und beim Beziehungstyp
  kennzeichnen schwache Entitätstypen. 
\end{bsp}

\section{Erweiterungen des ER-Modells}

\subsection{Erweiterungen bei Attributen}

\begin{description}
\item[Optionale Attribute] Das Attribut existiert für den Entitätstyp
  bzw. den Beziehungstyp. Aber es muss nicht für jede Entität oder
  Beziehung einen definierten Wert annehmen. Grafisch wird das durch
  einen Kringel in der Verbindungslinie dargestellt. Optionale
  Attribute sind primär für den Fall gedacht, wo strukturelle
  Unterschiede zwischen den Entitys eines Typs erlaubt sind

\item[Strukturierte Attribute] setzt sich aus anderen Attributen
  zusammen. Die Komponenten eines strukturierten Attributs sind
  benannt und bezüglich des Wertebereichs meist inhomogen.

\item[Mengenwertiges Attribut] Der Attributwert ist eine Wertemenge,
  wie beispielsweise die Telefonnummern einer Person oder die Kinder
  des Angestellten. Im letzten Fall ist die Entscheidung, ob es sich
  um ein schwaches oder ein mengenwertiges Attribut handelt regelmäßig
  nicht einfach.

\item[Virtuelle Attribute] sind nicht real gespeichert. Die Werte
  werden durch eine Berechnungsvorschrift ermittelt. Die virtuellen
  Attribute kennzeichnet man durch gestrichelte Linien.
\end{description}

\subsection{Erweiterung um Spezialisierung und Generalisierung}

Spezialisierung und Generalisierung sind Bestandteil von erweiterten
ER"=Modellen. Bei der \highl{Generalisierung} werden Eigenschaften
ähnlichen Entitytypen ermittelt und einem gemeinsamen Obertyp
zugeordnet. Die ähnlichen Entitytypen heißen \highl{Untertypen} des
Obertyps. In der umgekehrten Richtung sind die Untertypen eine
\highl{Spezialisierung} des Obertyps.

\begin{bsp}
  Jeder Angestellte und jeder Arbeiter ist ein Mitarbeiter. Beim
  Mitarbeiter handelt es sich damit um eine Generalisierung und
  Angestellte sowie Arbeiter sind die Spezialisierung. Die dabei
  entstehende Beziehung wird als \highl{IS-A-Beziehung}
  bezeichnet. Das bedeutet, ein Angestellter \emph{ist ein}
  Mitarbeiter etc.

  Weiterhin kann man sagen, dass Mitarbeiter ein \highl{Supertyp} von
  Angestellten und Arbeitern ist und die beiden letztgenannten sind
  ein \highl{Subtyp} von Mitarbeiter.

  Diese Beziehung stellt man im ER"=Diagramm wie folgt dar:

  \begin{tikzpicture}[node distance=6em]
    \node[entity] (mitarbeiter) {Mitarbeiter};
    \node[isa] (isa) [below of=mitarbeiter] {IS-A} edge (mitarbeiter);
    \node[entity] (angest) [below left of=isa] {Angestellter} edge
    (isa);
    \node[entity] (arbeiter) [below right of=isa] {Arbeiter} edge (isa);
  \end{tikzpicture}
\end{bsp}

\chapter{Das hierarchische Datenbankmodell}

In diesem Kapitel wollen wir die Möglichkeiten der Modellierung mit
dem hierarchischen Datenbankmodell (HDM) kennenlernen und einen Zusammenhang
zwischen dem Modell und dem ER"=Modell herstellen. Im weiteren Verlauf
werden die reinen Hierarchien in Richtung vernetzter Strukturen
erweitert. Dabei bedienen wir uns sogenannter virtueller
Satztypen. Als Beispiel für ein hierarchisches Datenbanksystem wird
uns IMS dienen.

Im Allgemeinen sollte am Ende des Kapitels verstanden werden, was die
Möglichkeiten eines HDM sind, ohne dass jemand mit einem spezifischen
DBMS umgehen kann. Dazu wären weitergehende Details nötig. Weiterhin
existiert eine Vielzahl von DMBS, die auf das hierarchische Modell
setzen. Alle lassen sich in unterschiedlicher Weise bedienen.

\begin{defini}[Hierarchisches Datenbankmodell]
  Das \highl[Datenbankmodell!hierarchisches]{hierarchische
    Datenbankmodell} bildet die reale Welt durch eine hierarchisch
  aufgebaute Baumstruktur ab.
\end{defini}

\begin{bemerk}
  Es muss sich nicht notwendigerweise um eine Hierarchie
  handeln. Vielmehr kann es mehrere geben. Dabei darf jeder Entitytyp
  nur einmal vorkommen. Innerhalb des Datenbankschemas muss der Name
  des Entitytyps eindeutig sein.
\end{bemerk}

\begin{bsp}
  Eine Miniwelt mit Kunden und Aufträgen liesse sich mit folgender
  Baumstruktur modellieren.

  \begin{tikzpicture}         %[edge from parent fork down]
    \node {Kunde}
    child {node {Auftrag}
      child {node {Auftragsposition}}
    }
    child {node {Rechnung}
      child {node {Rechnungsposition}}
    };
  \end{tikzpicture}
  Diese Darstellung entspricht der \highl{Typebene}. Wenn die Einträge
  mit konkreten Werten gefüllt werden, spricht man von der
  \highl{Ausprägungsebene} bzw. \highl{Instanzenebene} oder \highl{Satzebene}.
\end{bsp}

\section{Bestandteile einer hierarchischen Datenbank}


\begin{defini}[Hierarchieordnung]
  Eine \highl{Hierarchieordnung} drückt aus, dass die Reihenfolge des
  Auftretens von Kindern eines Vaterknotens von Bedeutung ist.
\end{defini}

Das Datenbankschema besteht aus:
\begin{itemize}
\item einer Menge von (benannten) Entitytypen
\item einer Menge von (benannten) Hierarchien über den Entitytypen
  (versehen mit einer Hierarchieordnung)
\end{itemize}

Die Daten bestehen aus:
\begin{itemize}
\item einer Menge von Entitäten. Diese können auf der Ausprägungsebene
  in Beziehung stehen.
\item einer Ordnungsreihenfolge innerhalb der Entitymenge.
\end{itemize}

\begin{bemerk}[Eigenschaften/Bezeichnungen]
  \begin{itemize}
  \item Jeder Entitytyp einer HDM gehört zu genau einer Hierarchie.
  \item Der oberste Entitytyp wird als \highl{Wurzeltyp} bezeichnet.
  \item Für den Wurzeltyp existiert ein
    \highl{Primärschlüssel}. Dieser erlaubt die eindeutige
    Identifizierung einer Entität aus der zugehörigen Entitymenge. Das
    bedeutet, es gibt einen Einstiegspunkt zum zugehörigen Baum.
  \item Ein direkter Zugriff auf eine beliebige Entität auf der
    Ausprägungsebene ist im HDM \emph{nicht} möglich.
  \end{itemize}
\end{bemerk}

\section{Erweiterung des hierarchischen Datenbankmodells}

Der Entitytyp müsste eigentlich mehrfach, also in verschiedenen
Hierarchien auftreten. Dies ist in dem Modell jedoch
verboten. Erweiterungen versuchen, den Konflikt zu lösen.

\subsection{Einführung von Redundanz}

Man könnte verschiedene Hierarchien erlauben, in denen Entitytypen
mehrfach vorkommen.

\begin{tikzpicture}
  \node {Abteilung}
  child {node {Angestellter}};
  \node {Position}
  child {node {Angestellter1}};
\end{tikzpicture}
\todo{Beide Knoten nebeneinander}

Aus Sicht des Datenbanksystems sind Angestellter und Angestellter1
unterschiedliche Entitytypen. Das heißt, dass die Entitäten aus der
realen Welt in der Modellierung zweimal vorhanden sind. Dies ist eine
Diskrepanz, die das Datenbanksystem nicht überwachen kann. Die
Kontrolle muss durch den Benutzer geschehen. Letztlich ist dies nicht
akzeptabel und daher abzulehnen.

\subsection{Einführung von virtuellen Entitytypen}

Hierbei existieren die "`doppelten"' Entitäten in nur einer Hierarchie
physisch. Aus anderen Hierarchien wird auf diese Entität per Zeiger
verwiesen. Benutzer sehen diese Realisierung nicht. Das
Datenbanksystem kann in diesem Modell wieder seine Stärken
ausspielen.

\section{IMS als Beispiel eines hierarchischen Datenbanksystems}

\highl{IMS} ist eine Abkürzung und steht für \highl{Information
  Management System}. Es wurde zwischen 1966 und 1968 von IBM,
Rockwell und Caterpiller für das Apollo"=Mondprogramm
entwickelt. Seit 1969 wird es von IBM bis heute weiterentwickelt.

IMS speichert die Daten durch ein hierarchisches Modell. Dies wird
durch Datenblöcke, die \highl{Segment} genannt sind, realisiert. Jedes
Segment kann verschiedene Daten enthalten. Die Teile bezeichnet man
als \highl{Feld}. Das Datenbankmodell wie auch die Sprache sind nicht
sehr flexibel und schwer zu beherrschen. Nichtsdestotrotz wird das
Datenbanksystem weltweit oft eingesetzt und gehört zu den
umsatzstärksten Produkten des Konzerns.

\subsection{Begriffe und Eigenschaften}

\begin{defini}[Segment]
  Ein Knoten in der  Typhierarchie wurde bisher als Entitytyp
  bezeichnet. Innerhalb von IMS heißt der \highl{Segment}.
\end{defini}

\begin{defini}[Feld]
  Jedes Segment besteht aus einem oder mehreren \highl[Feld]{Feldern}.
\end{defini}

\begin{bemerk}
  Die Segmente der Typhierarchie werden im Sinne der
  Präorder"=Reihenfolge als geordnet betrachtet.
\end{bemerk}

\begin{defini}[Wurzelsegment]
  Es gibt ein unabhängiges, ausgezeichnetes
  \highl{Wurzelsegment}. Alle anderen Segmente sind
  \highl[Segment!abhängiges]{abhängige Segmente}.
\end{defini}

\begin{bemerk}
  Man spricht auch vom \highl{Vatersegment}, \highl{Kindsegment} sowie
  vom \highl{Geschwistersegment}.
\end{bemerk}

\begin{defini}[Satz]
  Die Knoten der Ausprägungsebene trugen bislang den Namen Entität. In
  IMS werden sie als \highl{Satz} oder \highl{Record} bezeichnet. Die
  Sätze enthalten eine \highl{Feldausprägung}.
\end{defini}

\begin{bemerk}
  Übertragen auf die Typebene gibt es also einen \highl{Wurzelsatz},
  \highl[Satz!abhängiger]{abhängige Sätze}, \highl{Elternsatz},
  \highl{Kindsatz} und \highl{Geschwistersatz}.

  Es sind keine "`Waisenkinder"' erlaubt, d.\,h. ein Kindsatz kann nur
  solange existieren, wie es einen zugehörigen Elternsatz
  gibt. Weiterhin erfolgt die Zuordnung von Kindrecord zum
  Elternrecord durch den Anwendungsprogrammierer. Das ist auch die
  schlechte Nachricht: Die Konsistenzwahrung erfolgt durch ein
  Anwendungsprogramm!
\end{bemerk}

\subsection{Schemadefinition im IMS}

\subsubsection{Konzeptionelles Schema}

Die Struktur einer IMS"=Datenbank, also die Typhierarchie, wird als
\highl{Physical Database Record Type} bezeichnet und wird durch eine
\highl{Database Definition} (\highl{DBD}) festgelegt. Die DBD
beschreibt einen wesentlichen Teil des konzeptionellen Schemas der
IMS"=Datenbank. Daneben kommen noch Aspekte des internen Schemas
hinzu. Das heißt, IMS bietet keine klare Trennung zwischen der
Beschreibung der konzeptionellen und der internen Ebene. In der DBD
können nur 1:n"=Beziehungstypen modelliert werden.

\begin{bsp}
  Eine Definition des Physical Database Record Type könnte so
  aussehen.\todo{Definition des listings entsprechend DBD anpassen.}
\begin{lstlisting}
DBD   NAME=KursDB
SEGM  NAME=Kurs, BYTES=36
FIELD NAME=(KursNr,SEQ), BYTES=3, START=1
FIELD NAME=Titel, BYTES=33, START=4
SEGM  NAME=Vorauss, PARENT=Kurs, BYTES=3
FIELD NAME=(VorNr,SEQ), BYTES=3, START=1
SEGM  NAME=Angebot, PARENT=Kurs, BYTES=21
FIELD NAME=(AngNr,SEQ), BYTES=3, START=1
FIELD NAME=DATUM, BYTES=6, START=4
FIELD NAME=Ort, BYTES=12, START=10
SEGM  NAME=Kursleiter, PARENT=Angebot, BYTES=23
FIELD NAME=(PersNr,SEQ), BYTES=5, START=1
FIELD NAME=Name, BYTES=18, START=6
SEGM  NAME=Teilnehmer, PARENT=Angebot, BYTES=41
FIELD NAME=(TnNr,SEQ), BYTES=3 , START=1
FIELD NAME=Name, BYTES=18, START=4
FIELD NAME =Ort, BYTES=20, START=22
END
\end{lstlisting}
Die Reihenfolge der Segment"=Definitionen (\lstinline{SEGM}) bestimmt
die Präorder"=Reihenfolge der Segmente in der Typhierarchie. Alle
Felder sind untypisiert und besitzen eine feste Länge. Die Angabe
\lstinline{SEQ} legt fest, dass die Segmentausprägungen nach diesen
Feldwerten \emph{aufsteigend} sortiert sind. Damit die Felder mit
\lstinline{SEQ} gleichzeitig Schlüsselfelder.
\end{bsp}

\subsubsection{Externe Schemas}

Auf IMS kann nicht ad hoc zugegriffen werden. Stattdessen erfolgt der
Zugriff immer über ein Anwendungsprogramm. Diese Programme sehen nicht
die physische Datenbank, sondern einen \highl{Programm Communication
  Block} (\highl{PCB}). Ein Programm kann auch mehrere PCBs
verwenden. Diese bilden dann \highl{Program Specification Block}
(\highl{PSB}), also das externe Schema.

\begin{bsp}
Das folgende Listing zeigt den Program Specification Block zum vorigen Beispiel.
\begin{lstlisting}
PCB    DBDNAME=KursDB, KEYLEN=9
SENSEG NAME=Kurs, PROCOPT=G
SENSEG NAME=Angebot, PARENT=Kurs, PROCOPT=G
SENFLD NAME=(AngNr,SEQ), START=1
SENFLD NAME=DATUM, START=4
SENSEG NAME=Teilnehmer, PARENT=Angebot, PROCOPT=GID
PSBGEN LANG=COBOL, PSBNAME=KursMaint
END
\end{lstlisting}
Die in der \lstinline{SENSEG}"=Anweisung aufgeführten Segmente werden
sichtbar gemacht. Man spricht auch von sensibilisierten oder
sensitiven Segmenten. Diese sind Teil des externen Schemas und damit
durch das Programm ansprechbar. Weiterhin sensibilisiert
\lstinline{SENFLD} die entsprechenden Felder in den Segmenten. Sollte
auf ein \lstinline{SENSEG} kein \lstinline{SENFLD} folgen, gelten alle
Felder als sensibilisiert. \lstinline{PROCOPT} steht für "`processing
options"' und definiert Zugriffsrechte. Dabei steht \texttt{G} für
"`get"', \texttt{I} für "`insert"' und \texttt{D}  für "`delete"'.
\end{bsp}

\subsubsection{Zugriff mittels DL/I}

Das \highl{Data Language Interface}, manchmal als Data Language/One
bezeichnet, wird als Sprache für den IMS"=Datenbankzugriff
benutzt. Zum besseren Verständnis betrachten wir die Abfolge bei einem
lesenden Zugriff.
\begin{enumerate}
\item Die Anwendung ruft das Anschlussmodul mittels eines
  Unterprogrammaufrufs auf und übergibt die Anfrage in der Parameterliste.
\item Die Anfrage wird an das DBMS weitergegeben.
\item Das DBMS bearbeitet die Anfrage und stellt das Ergebnis bereit.
\item Ergebnis wird zurückgegeben.
\item Das Anwendungsprogramm analysiert den Rückgabewert  und greift
  ggf. auf die Treffer zu.
\end{enumerate}

Im folgenden lernen wir eine Auswahl des Operationsvorrats von DL/I
kennen.
\begin{description}

\item[\texttt{GET UNIQUE} (\texttt{GU})]  direktes Positionieren auf
  einen Record und Lesen einer Segmentausprägung. Einstieg erfolgt von außen
\item[\texttt{GET NEXT} (\texttt{GN})] Zugriff auf nächste
  Segmentausprägung ausgehend von aktueller Position
\item[\texttt{GET NEXT WITH PARENT} (\texttt{GNP})] wie oben nur mit Vater"=Segment"=Ausprägung
\item[\texttt{GET HOLD} (\texttt{GHU}, \texttt{GHN}, \texttt{GHNP})]
  wie bei obigen Varianten, nur die Segmentausprägung, auf die
  positioniert wurde, kann geändert werden.
\item[\texttt{INSERT} (\texttt{INSRT})] Einfügen einer neuen Segmentausprägung
\item[\texttt{DELETE} (\texttt{DLET})] Löschen einer Segmentausprägung
\item[\texttt{REPLACE} (\texttt{REPL})] Ändern einer Segmentausprägung
\end{description}

\chapter{Das Netzwerk-Datenbankmodell}

In dem Kapitel wollen wir das Netzwerk"=Datenbankmodell (NDBM) einordnen
bzw. abgrenzen und die Mächtigkeit des Ansatzes studieren.

Das obige hierarchische Modell und speziell IMS sind proprietär. Das
Netzwerk"=Datenbankmodell wurde von Anfang an mit dem
nichtproprietären Ansatz entwickelt. Es entstammt der Conference on
Data Systems Language (CODASYL), weshalb es manchmal als
CODASYL"=Datenbankmodell bezeichnet wird. Aufgrund der Herkunft ist
das Modell stark von COBOL beeinflusst. Für das Modell wurden drei
Sprachen vorgeschlagen:
\begin{itemize}
\item Schema Data Description Language oder
  Schema-Datenbeschreibungssprache
\item Subschema Data Description Language oder
  Subschema-Datenbeschreibungssprache
\item Data Manipulation Language oder Datenmanipulationssprache
\end{itemize}
Die Sprachen sind vergleichsweise komplex und schwer zu erlernen. Im
Vordergrund steht der navigierende Zugriff. Dieser erfolgt primär aus
der Programmiersprache heraus. 

Zur Datenmodellierung werden zwei Konstrukte verwendet. Das sind
Satztypen. Diese entsprechen den Entitytypen. Außerdem gibt es
spezielle 1:n"=Beziehungstypen. Die Beziehungstypen sind
ausschließlich zweistellig und benannt. Man kann sich das als
zyklischen gerichteten Graphen vorstellen.

\section{Settyp}

\todo{Weiteres schreiben}


\chapter{Das relationale Datenbankmodell}

Die Datenbankmodelle, die wir bisher kennengelernt haben, sind weit
vom Endbenutzer entfernt. Die Datenbank ist nur von einem
Anwendungsprogramm heraus ansprechbar. Also benötigt der Benutzer
Programmierkenntnisse. Die Datenbanksprachen selbst sind schwer zu
erlernen und fehlerfrei anzuwenden. Somit ist die Benutzung nur einem
kleinen Kreis von Spezialisten vorbehalten. Diese Eigenschaften
führten dazu, dass Fehler gemacht wurden. Der modellierte Zustand
entsprach nicht dem Zustand in der realen Welt und das DBMS wiederum
konnte Inkonsistenzen nicht feststellen.

Daher sollte ein neues Datenbankmodell geschaffen werden. Dies soll
eine mathematisch fundierte Grundlage besitzen. Weiterhin soll es eine
einfache Datenbanksprache geben. Bei der beschreibt der Benutzer, was
er machen möchte. Die Umsetzung wird der Datenbank überlassen. Die
Überwachung der Integrität und der Konsistenz wird dem DBMS
überlassen. Dieses besitzt auch Informationen zur Semantik der Daten
und kann die Korrektheit automatisch prüfen. Das Ergebnis dieser
Überlegungen sind die relationalen Datenbanken.

Ab Mitte der 1970er Jahre gab es von IBM das System~R als Prototyp
sowie von der Universität of Berkeley Ingres.  Aus System~R wurde
später DB2 und Ingres wurde unter dem Namen weiterentwickelt. Davon
abgeleitet ist unter anderem die Freie Software Postgres. Weitere
bekannte relationale Datenbanken sind Oracle, Informix, Sybase,
Adabas~D, MySQL und viele mehr.

\section{Begriffe und Eigenschaften des relationalen Modells}

Bei der Schaffung des Modells achtete man auf eine saubere Trennung
der Schemas, d.\,h. konzeptionelles und internes Schema sollten
getrennt sein. Die Darstellung der Daten erfolgt mittels Relationen.

\begin{defini}[Relation]\label{def:relation}
  Seien $D_{1}, D_{2},\dotsc,D_{n}$ Wertebereiche (Domains). Dann
  heißt $R\subseteq D_{1}\times D_{2}\times\dotsc\times D_{n}$ mit
  $n\geq 1$ eine \highl{Relation}.
\end{defini}

\begin{defini}[Relation]
  Die Zahl $n$ aus \autoref{def:relation} wird als \highl{Grad} oder
  \highl{Stelligkeit} der Relation bezeichnet.
\end{defini}

\begin{defini}[Element, Komponente]
  Ein Element $r\in R$ mit $r= (d_{1},\dotsc, d_{n})$ für $d_{i}\in
  D_{i}$ heißt \highl{Tupel} und $d_{i}$ ist die
  \highl[Komponente]{$i$-te Komponente} des Tupels.
\end{defini}

\begin{bsp}
  Seien $D_{1}= \{r,g,b\}$ und $D_{2}=\{0,1\}$. Dann erhalten wir das
  kartesische Produkt $D_{1}\times
  D_{2}= \{(r,0), (r,1), (g,0), (g,1), (b,0), (b,1)\}$. Etwaige
  Relationen können sein: $R_{1}= \{\}, R_{2}= \{(r,0)\}, R_{3}=
  \{(g,1), (b,0), (r,1)\}$.

  Die Relationen können ebenfalls als Tabellen aufgefasst werden.
  \begin{table}[htb]
    \centering
    \begin{tabular}{|c|c|}
      \toprule
      a & a\\ 
      \bottomrule
    \end{tabular}
    \caption{Relation $R_1$}
  \end{table}

  \begin{table}[htb]
    \centering
    \begin{tabular}{|c|c|}
      \toprule
      r & 0\\
      \bottomrule
    \end{tabular}
    \caption{Relation $R_2$}
  \end{table}

  \begin{table}[htb]
    \centering
    \begin{tabular}{|c|c|}
      \toprule
      g & 1\\
      b & 0\\
      r & 1\\
      \bottomrule
    \end{tabular}
    \caption{Relation $R_3$}
  \end{table}
\end{bsp}

Bisher wurden Relationen als Mengen von Tupeln betrachtet. Aus der
Sicht der Datenbank ist ebenso das zugehörige Schema von Interesse,
welchen den Relationstyp beschreibt.

\begin{defini}[Relationsschema]
  Ein \highl{Relationsschema} besteht aus:
  \begin{itemize}
  \item Name des Schemas
  \item Menge von Attributnamen
  \item eventuellen zusätzlichen Integritätsbedingungen
  \end{itemize}
\end{defini}

\begin{bsp}
  Seien $D_{1}$ und $D_{2}$ die Domänen wie oben. Dann sind die Farbe
  und der Wert jeweils der \highl{Attributname}. Die Farbtabelle ist
  der \highl{Schemaname} und eine Integritätsbedingung könnte sein,
  dass die Farbe $r$ nicht mit dem Wert $0$ auftreten darf.
\end{bsp}

\begin{bsp}\label{bsp:relschema}
  Wir betrachten das Relationsschema \texttt{Angest} mit der
  Attributmenge (Name, Beruf, Wohnort, Geburtsjahr). Dann ergibt sich
  folgende Tabelle:
  \begin{table}[htb]
    \centering
    \begin{tabular}{|l|l|l|l|l|}
      \toprule
      Schemaname & \multicolumn{4}{c}{Attributname}\\
      \midrule
      Angest & Name & Beruf & Wohnort & Geburtsjahr\\
      \midrule
      & Meier & Schlosser & Stuttgart &  1967\\
      & Müller & Schmied & Berlin &1977\\
      & Petermann & Verkäuferin & Salzwedel & 1987\\
      \bottomrule
    \end{tabular}
    \caption{Relationsschema Angest}
  \end{table}
\end{bsp}

Die Menge von Relationsschemata und von zusätzlichen
Integritätsbedingungen ergibt das \highl{Datenbankschema}. Begrifflich
wird zwischen Relationsschema und Relation nicht immer strikt
unterschieden.

Wie bereits gesehen, sind Relationen Mengen. Das heißt, in einer
Relation dürfen keine identischen Tupel auftauchen. Im
\autoref{bsp:relschema} wären zwei gleiche Zeilen der Form (Meier,
Schlosser, Stuttgart, 1967) unzulässig. Weiterhin verlangt das
Relationenmodell das Vorhandenseins eines Schlüssels nach
\autoref{def:schluessel}. Bei mehreren Kandidaten wird ebenso ein
\highl{Primärschlüssel} gewählt. Eine neue Form eines Schlüssels ist
der Fremdschlüssel.

\begin{defini}[Fremdschlüssel]
  Falls eine Attributkombination einer Relation $R_{1}$ in einer
  Relation $R_{2}$ die Eigenschaft eines Primärschlüssels besitzt, so
  kann die in $R_{1}$ als Schlüssel gewählt werden. Dieser Schlüssel
  wird dann \highl{Fremdschlüssel} bezeichnet.
\end{defini}

Eine Konsquenz aus der Definition des Fremdschlüssels ist die
\highl[Integrität!referentielle]{referentielle Integrität}. Dies ist
neben der Integrität auf Datensatz- und Datenfeldeben eine Form der
Datenintegrität.

\begin{bemerk}
  Eine Relation \emph{muss} einen Primärschlüssel besitzen und
  \emph{kann} beliebige Fremdschlüssel haben.
\end{bemerk}

\section{Abbildungen von ER-Modell auf relationales Modell}

\subsection{Nichtrekursive 1:n-Beziehungstypen}

Wir wollen den Entitytypen in ein Relationsschema überführen und
betrachten das am Beispiel, dass eine Abteilung Mitarbeiter hat. Die
Abteilungsnummer bei Mitarbeiter ist der Fremdschlüssel in Bezug auf
den Primärschlüssel von Abteilung. Es repräsentiert den Beziehungstyp
"`hat"' aus dem ER"=Diagramm.  Die (atomaren) Attribute eines
Entitytyps werden unmittelbar in Attribute der entsprechenden Relation
übernommen. Es ist zu beachten, dass beliebige Kardinalitäten, wie
(3,7) nach der (min,max)"=Notation, nicht darstellbar sind.

\subsection{Rekursive 1:n-Beziehungstypen}

Man stelle sich das folgende ER"=Diagramm vor:\todo{noch verbessern,
  zwei Linien}

\begin{tikzpicture}[node distance=9em]
  \node[entity] (ma) {Mitarbeiter} ;
  \node[relationship] (vg) [below of=ma] {Vorgesetzter} edge (ma);
\end{tikzpicture}

Der Mitarbeiter hat (0,1) Vorgesetzte und der Vorgesetzte hat (0,*)
Mitarbeiter. Das lässt sich wie folgt modellieren:
Mitarbeiter(Personanummer, Name, \ldots, Chefnummer). Die Chefnummer
ist Fremdschlüssel mit Bezug auf den Primärschlüssel der gleichen
Relation. Dann verbleibt nur noch die Frage, wie man in dem Beispiel
den obersten Chef modelliert.
\begin{itemize}
\item Chefnummer und Personanummer haben den gleichen Wert. Dies ist
  nicht empfehlenswert.
\item Chefnummer ist undefiniert, d.\,h. es besitzt einen speziellen NULL"=Wert.
\end{itemize}

\subsection{Nichtrekursive n:m-Beziehungstypen}

Dazu stellen wir uns vor, dass ein Lieferant Teile liefert. Die
gelieferten Mengen können beliebig groß sein. Dies lässt sich in die
Relation überführen:
\begin{itemize}
\item Lieferant(\underline{Liefernummer}, Name, Ort)
\item Teil(\underline{Teilenummer}, Bezeichnung)
\item Liefert(\underline{Liefernummer}, \underline{Teilenummer}, Menge)
\end{itemize}
Das heißt, der Beziehungstyp bekommt eine eigene Relation mit dem
Primärschlüssel als der Attributkombination der Relationen Lieferant
und Teil. Die Teilenummer in Liefert ist Fremdschlüssel mit Bezug auf
Primärschlüssel von Teil und Liefernummer in Liefert ist
Fremdschlüssel mit Bezug auf Primärschlüssel von Lieferant.

\subsection{Rekursive n:m-Beziehungstypen}

Dazu stelle man sich eine Stückliste mit den Beziehungen Teil enthält
beliebige Unterteile und Unterteil hat beliebige Oberteile. Dies lässt
sich mit zwei Relationen modellieren:
\begin{itemize}
\item Teil(\underline{Teilenummer}, Bezeichnung)
\item Struktur(\underline{Oberteilnummer},
  \underline{Unterteilnummer}, Anzahl)
\end{itemize}
Es wird also wieder jeder Beziehungstyp in eine Relation
überführt. Der Primärschlüssel setzt sich aus den Attributen
Oberteilnummer und Unterteilnummer zusammen. Beide sind einzeln
Fremdschlüssel mit Bezug auf den Primärschlüssel von Teil.

\subsection{Umgang mit nichtatomaren Attributen}

Zu Anfang stellen wir zwei Beispiele.

\begin{tikzpicture}[node distance=11em]
  \node[entity] (angest) {Anstellter};
  \node[attribute] (pnr) [above left of=angest] {\key{PNR}} edge
  (angest);
  \node[attribute] (name) [below left of=angest] {Name} edge (angest);
  \node[attribute] (adr) [below right of=angest]  {Adresse} edge
  (angest);
  \node[attribute] (plz) [below left of=adr] {PLZ} edge (adr);
  \node[attribute] (ort) [below of=adr] {Ort} edge (adr);
  \node[attribute] (str) [below right of=adr] {Straße} edge (adr);
\end{tikzpicture}

\begin{tikzpicture}[node distance=11em]
  \node[entity] (ang) {Angestellter};
  \node[attribute] (pnr) [below left of=ang] {\key{PNR}} edge (ang);
  \node[attribute] (name) [below of=ang] {Name} edge (ang);
  \node[multi attribute] (tel) [below right of=ang] {Telefonnummer}
  edge  (ang);
\end{tikzpicture}

Das letzte Beispiel lässt sich mit zwei Tabellen lösen. Dabei ist die
PNR Fremdschlüssel mit Bezug auf den Primärschlüssel von
Angestellter. Das Problem der Nullwerte ist damit per Definition
ausgeschlossen. Außerdem sind zusätzliche Integritätsbedingungen
denkbar.

\begin{table}[htb]
  \centering
  \begin{tabular}{|c|c|l|}
    \toprule
    Angestellter & \underline{PNR} & Name\\
    \midrule
    & 3841 & Schmid\\
    & 6513 & Meier\\
    & 8612 & Lehman\\
    \bottomrule
  \end{tabular}
  \caption{Tabelle mit PNR und Name}
\end{table}

\begin{table}[htb]
  \centering
  \begin{tabular}{|c|c|l|}
    \toprule
    Telefon & \underline{PNR} & \underline{Telefonnummer}\\
    \midrule
    & 3841 & 23813\\
    & 3841 & 54128\\
    & 6513 & 12908\\
    & 8612 & 87124\\
    & 8612 & 98236\\
    & 8612 & 76123\\
    \bottomrule
  \end{tabular}
  \caption{Tabelle mit PNR und Telefonnummer}
\end{table}

Will man die Daten in eine Tabelle modellieren, entstehen schnell
Konflikte. Denn als Primärschlüssel empfiehlt sich eine Kombination
aus PNR und Telefonnummer. Wenn ein Mitarbeiter keine Telefonnummer
hat, so ist der Primärschlüssel nicht definiert.

Das erste obige Beispiel mit Adressen könnte man in einer Tabelle
modellieren. Dabei geht die Zusammengehörigkeit der Adressdaten (PLZ,
Ort, Straße) verloren. Daher ist es auch hier zu empfehlen, zwei
Tabellen zu verwenden.

\section{Relationenalgebra und -kalkül}

Die Sprachen für das relationale Modell sind nicht navigierend und
satzorientiert, sondern mengenorientiert und deskriptiv. Mit einer
Anweisung werden Mengen von Tupeln gelesen bzw. modfiziert. Zu den
Basisoperationen des relationalen Modells zählen:
\begin{description}
\item[Selektion] Auswahl von Tupeln mit einer Relation
\item[Projektion] Streichen von Spalten
\item[Verbund (Join)] Verknüpfung von Tabellen aufgrund von
  Attribut"=Beziehungen
\item[Mengenoperation] Vereinigung, Differenz und Durchschnitt auf
  verschiedenen Relationen gleicher Struktur
\end{description}

\begin{bsp}
  Finde die Wohnorte aller Angestellten, die Programmierer sind. Dazu
  werden alle Tupel der Angestellten"=Relation selektiert, deren Beruf
  Programmierer ist. Daraufhin folgt eine Projektion auf die Spalte
  Wohnort. Das Ergebnis der Operation ist wieder eine Menge.

  Finde die Namen aller Angestellten, die am Projekt Foo
  mitarbeiten. Dazu werden die Relationen Angestellter und Mitarbeit
  miteinander verbunden. Dies geschieht, indem Tupel mit gleicher
  Angestelltennummer zusammengefasst werden. Auf dem Zwischenergebnis
  erfolgt eine Selektion der Tupel mit Projektnummer 27 und eine
  Projektion auf die Spalte Name. Andere Lösungen sind auch denkbar.
\end{bsp}

\subsection{Kriterien für Anfragesprachen}

In \cite{hesa03} sind auf Seite~225 verschiedene Kriterien
festgelegt. Dazu zählen:
\begin{description}
\item[Ad-hoc-Formulierung] Benutzer kann eine Anfrage ohne zugehöriges
  Programm formulieren.
\item[Mengenorientiert] Jede Operation arbeitet auf Mengen von Daten.
\item[Deskriptivität] Benutzer formuliert, was er haben will.
\item[Abgeschlossenheit] Ergebnis der Anfrage ist wieder eine Relation
  und kann als Eingabe verwendet werden.
\item[Adäquatheit] Alle Konstrukte des Datenmodells werden unterstützt.
\item[Orthogonalität] Sprachkonstrukte sind in ähnlichen Sprachen
  anwendbar. Orthogonalität setzt Abgeschlossenheit voraus.
\item[Optimierbarkeit] Sprache besteht aus wenigen Operationen, für
  die es Optimierungsregeln gibt. Die Eigenschaft wird durch eine
  formale Sprachdefinition sowie durch die Orthogonalität gefördert.
\item[Effizienz] Jede Operation ist effizient ausführbar.
\item[Sicherheit] Keine syntaktisch korrekte Anfrage darf in eine
  Endlosschleife führen oder ein unendliches Ergebnis liefern.
\item[Eingeschränktheit] Sprache darf keine vollständige
  Programmiersprache sein.
\item[Vollständigkeit] Sprache muss mindestens die Anfragen aus der
  Relationenalgebra ausdrücken können.
\end{description}

\subsection{Relationenalgebra}

Der Begriff der \highl{Relationenalgebra} stammt vom Begriff der Algebra aus
der Mathematik. Es ist eine nichtleere Menge mit Operationen, die auf
dem Wertebereich definiert sind. Übertragen auf das relationale Modell
heißt dass, dass die Werte die Relationen darstellen und die
Operationen sind die vorgestellten Basisoperationen.

\begin{bsp}
  Im folgenden betrachten wir die zwei untenstehenden
  Beispieltabellen. Diese sind \cite{hesa03} entnommen.

  \begin{table}[htb]
    \centering
    \begin{tabular}{|c|c|l|c|l|}
      \toprule
      Buch & \underline{Inventarnummer} & Titel & ISBN & Autor\\
      \midrule
      & 7613 & Dr.\,No & 3145 & James B\\
      & 8712 & ObjektDB & 6512 & Heuer\\
      & 5412 & Analysis I & 9823 & Bauer\\
      & 9131 & COBOL & 6192 & Würth\\
      \bottomrule
    \end{tabular}
    \caption{Relation Buch}
  \end{table}

  \begin{table}[htb]
    \centering
    \begin{tabular}{|c|c|l|}
      \toprule
      Ausleihe & \underline{Inventarnummer} & Name\\
      \midrule
      & 7613 & Meier\\
      & 8712 & Müller\\
      & 5412 & Schulze\\
      & 9131 & Meier\\
      \bottomrule
    \end{tabular}
    \caption{Relation Ausleihe}
  \end{table}
\end{bsp}

Nun wollen wir verschiedene Operationen diskutieren.

\paragraph{Projektion}

Üblicherweise wird die Projektion durch $\pi_{\text{Attr}} R$
bezeichnet. Dabei steht Attr für eine nichtleere Menge von Attributen
der Relation $R$. Die Projektion $\pi_{\text{Attr}} R$ wählt jene
Spalten von $R$ aus, die in Attr gegeben sind.

So besteht zum Beispiel $\pi_{\{\text{Name}\}} \text{Ausleihe}$ aus
Meier, Müller und Schulze. Wegen der Mengenoperation wurden die
Duplikate entfernt. Wenn das Attribut einen Schlüssel enthält, ist
hingegen keine Elimination möglich.

\paragraph{Selektion}

Die Selektion wird durch $\sigma_{F} R$ bezeichnet. Dabei steht $F$
für eine Selektionsformel. Die Operation $\sigma_{F}R$ wählt alle
Zeilen von $R$ aus, die der Bedingung $F$ genügen. Beispielsweise gibt
$\sigma_{\text{Inventarnummer}>8800} \text{Buch}$ die Zeile (9131,
COBOL, 6192, Würth) zurück. Man kann auch Attributwerte untereinander
vergleichen und logishe Verknüpfungen sind ebenso möglich.

\paragraph{Verbund (Join)}

Der Verbund wird durch $R\Join_{F} S$ bezeichnet. Dabei steht $F$
für eine Verbundbedingung. Der Verbund $R\Join_{F} S$ fügt die Tupel
der Relationen $R$ und $S$ zusammen, die der Bedingung $F$ genügen.

Mittels $\text{Buch}\Join_{\text{Inventarnummer} =
  \text{Inventarnummer}} \text{Ausleihe}$ fügt man beide Tabellen
ineinander. Die Gleichheitsbedingung wird als \highl{Equi-Join}
bezeichnet.

\paragraph{Vereinigung}

Die Vereinigung $R\cup S$ ist bei gleichen Relationsschemata
möglich. Bei unterschiedlichen Relationsschemata ist zu entscheiden,
ob die Anzahl der Attribute (Spaltenzahl) und der Wertebereich
kompatibel ist. In dem Fall kann die Voraussetzung für eine
Vereinigung geschaffen werden.

\paragraph{Durchschnitt}

Die Voraussetzungen für den Durchschnitt entsprechen denen der
Vereinigung. Wir schreiben $R\cap S$.

\paragraph{Differenz}

Die Differenz $R\setminus S$ enthält alle Tupel von $R$, die nicht in
$S$ vorkommen. Die Voraussetzung für die Anwendung entspricht der der
Vereinigung.

Es lassen sich weitere Basisoperationen aufzählen. Jedoch bilden die
oben aufgeführten  eine minimale Relationenalgebra. Das bedeutet, dass
das Weglassen einer Operation die Mächtigkeit reduziert. Hingegen
bringt ein Hinzufügen einer neuen Operation keine Steigerung der
Mächtigkeit.

Operationen lassen sich in äquivalente Operationen umformen. Das ist
jedoch nicht beliebig möglich. Es darf nur eine syntaktische
Transformation ohne Änderung der Semantik geben. Eine Auswahl
äquivalenter Umformungen ist:
\begin{enumerate}
\item $\sigma_{F_{1}} (\sigma_{F_{2}} R)\equiv \sigma_{F_{2}}
  (\sigma_{F_{1}} R)$
\item $\sigma_{F}R\equiv \sigma_{F_{1}} (\sigma_{F_{2}}R)$ mit
  $F=F_{1}\wedge F_{2}$
\item $\sigma_{F} (\pi_{\text{Attr}} R)\equiv \pi_{\text{Attr}}
  (\sigma_{F} R)$, wenn die Attribute von $F$ eine Teilmenge von Attr sind.
\item $S\cup R\equiv R\cup S$
\item $S\Join_{F}R\equiv R\Join_{F}S$
\item $(R\cup S)\cup T\equiv R\cup (S\cup T)$
\end{enumerate}

\subsection{Relationenkalkül}

Das Relationenkalkül besteht aus zwei Komponenten, dem Tupel- und dem
Domänenkalkül.  Beide sind recht ähnlich und können daher zusammen
betrachtet werden. Grundsätzlich wird dabei beschrieben, welche
Bedingungen (Prädikate) die Tupel der Ergebnisrelation erfüllen
müssen.

\begin{defini}
  Eine \highl{Tupelvariable} ist ein Tupel einer Relation. Sei die
  Tupelvariable $U$ der Relation $R$ zugeordnet und $A$ ein Attribut
  von $R$. Dann bezeichnet $U.A$ den Attributwert von $A$ in
  irgendeinem Tupel von $R$. Dies heißt auch
  \highl{Tupelkomponente}. Sind $x,y$ Konstanten oder
  Tupelkomponenten, so legt $x\theta y$ mit $\theta\in\{=, \neq, <,
  \leq, >, \geq\}$ eine \highl{Bedingung} fest.
\end{defini}

\begin{defini}[Formel]
  Eine \highl{Formel} wird durch folgende Konstruktionsvorschriften
  definiert:
  \begin{enumerate}
  \item Jede Bedingung ist eine Formel.
  \item Ist $f$ eine Formel, so auch $(f)$ und $\neg(f)$.
  \item Sind $f$ und $g$ Formeln, so auch $f\wedge g$ und $f\vee g$.
  \item Ist $f$ eine Formel und $T$ eine Tupelvariable in $f$, so sind
    auch $\exists T(f)$ und $\forall T(f)$ Formeln.
  \item Nur durch die obigen Vorschriften erzeugbaren Ausdrücke sind Formeln.
  \end{enumerate}
\end{defini}


\section{Structured Query Language}

Die Structured Query Language (SQL) ist eine Datenbanksprache zur
Definition, Abfrage und Manipulation von Daten. Es ist als Norm der
Reihe DIN ISO/IEC 9075 festgelegt. Die Bezeichnung der Sprache stammt
vom Vorgänger SEQUEL (für Structured English Query Language) ab. Das
Wort war eingetragenes Warenzeichen einer anderen Firma. Daher
erfolgte eine Umbenennung. Seit 1982 ist die Sprache genormt. Seither
gab es folgende Schritte:
\begin{itemize}
\item 1986 wird SQL1 als ANSI"=Standard verabschiedet
\item 1987 wird SQL1 von der ISO als Standard verabschiedet
\item 1992 wird SQL2 oder SQL-92 von der ISO als Standard verabschiedet
\item 2003 SQL3 oder SQL:1999
\item 2003 Standard SQL:2003 ISO/IEC 9075:2003 als Nachfolger von SQL3
\item 2006 Standard SQL:2006 ISO/IEC 9075-14:2006 Standardisierung im
  Zusammenhang mit XML
\item 2008 aktuelle Revision SQL:2008 ISO/IEC 9075:2008
\end{itemize}

\subsection{Datendefinition mit SQL}
\lstset{language=SQL}
Innerhalb von SQL sind Datendefinition und -manipulation
vereinheitlicht. Einige Anweisungen getrennt nach der jeweiligen Ebene
finden sich in \autoref{tab:dd-sql}.

\begin{table}[htb]
  \centering
  \begin{tabular}{l|l|l}
    \toprule
    \multicolumn{3}{c}{Ebenen}\\
    externe &  konzeptionelle & interne\\
    \midrule
    \lstinline-create view- & \lstinline-create table- &
    \lstinline-create index-\\
    \lstinline-drop view- & \lstinline-alter table- & \lstinline-alter index-\\
    & \lstinline-drop table- & \lstinline-drop index-\\
    & \lstinline-create domain- & \\
    & \lstinline-alter domain- & \\
    & \lstinline-drop domain- & \\
    \bottomrule
  \end{tabular}
  \caption{Überblick zu Datendefinitionsanweisungen}
  \label{tab:dd-sql}
\end{table}

\subsection{SQL-Anweisungen}

Im folgenden sollen einige SQL"=Anweisungen beispielhaft erwähnt und
erklärt werden.


\paragraph{\texttt{CREATE TABLE}}

Die Anweisung \lstinline-CREATE TABLE- erzeugt eine $k$"=spaltige
Tabelle. Gemäß untenstehender Syntax wird das Relationenschema über
spalteK/wertebereichK definiert.

\begin{lstlisting}
CREATE TABLE relationenschema
(spalte1 wertebereich1 [NOT NULL]
\ldots{}
spalteK wertebereichK [NOT NULL])
\end{lstlisting}

Als Datentypen existieren in der Regel Integer, Float, Character und
andere produktspezifische. Die obige Klausel \lstinline-NOT NULL-
verbietet das Auftreten von nicht definierten Werten.

Der aufmerksame Leser wird festgestellt haben, dass kein Schlüssel
zugewiesen wurde. Die SQL"=Norm erzwingt keinen Primärschlüssel. Daher
können Tabellen durchaus Duplikate aufweisen. Mit der Anweisung
\lstinline-PRIMARY KEY (spalteN)- wird ein Primärschlüssel zugewiesen
und mittels \lstinline-FOREIGN KEY (spalteN)- ein Fremdschlüssel.

Die Klausel \lstinline-default- erlaubt es einen Standardwert
anzugeben und mit \lstinline-check- werden Integritätsbedingungen
angegeben.

\paragraph{\texttt{CREATE DOMAIN}}

Diese Anweisung ermöglicht die Vereinbarung benutzerspezifischer
Wertebereiche. Ein Beispiel ist die Angabe eines Fachgebiets:
\begin{lstlisting}
CREATE DOMAIN Fachgebiet varchar (20)
  default 'Informatik'
CREATE TABLE buch
(invnr integer PRIMARY KEY,
Gebiet Fachgebiet,
titel varchar (30),
ISBN char (13),
Autor varchar (30))
\end{lstlisting}

\paragraph{\texttt{ALTER TABLE}}

Die Anweisung dient zum Hinzufügen neuer Attribute zu einer Tabelle
bzw. zum Löschen von Tabellenspalten. Falls es Probleme bei der
Anwendung gibt, ist zu beachten, dass dies erst Bestandteil von SQL2
war.

\todo[inline]{Weitere Anweisungen einfügen. Die weiteren
  SQL-Anweisungen werden eventuell später nachgetragen. Details bitte vorerst
  der Dokumentation entnehmen}


\clearpage
\appendix
\begin{thebibliography}{99}
\bibitem{sasahe07} \textsc{Gunter Saake}, \textsc{Kai-Uwe Sattler},
  \textsc{Andreas Heuer}: Datenbanken: Konzepte und
  Sprachen. mitp-Verlag, Bonn, 3.\,Auflage, 2007
\bibitem{hesa03} \textsc{Andreas Heuer}, \textsc{Gunter Saake},
  \textsc{Kai-Uwe Sattler}: Datenbanken kompakt: Einstieg, Datenbanken
  im Web, CGI, ASP, Content Management, Tuning. mitp-Verlag, Bonn,
  2.\,Auflage, 2003
\bibitem{lalo95} \textsc{Stefan Lang}, \textsc{Peter C.\,Lockemann}:
  Datenbankeinsatz. Springer-Verlag, Berlin, 1.\,Auflage, 1995
\bibitem{kikoe} \textsc{Werner Kießling}, \textsc{Gerhard Köstler}:
  Multimedia-Kurs Datenbanksysteme, m. CD-ROM. Springer-Verlag,
  Berlin, 1.\,Auflage, 1998
\bibitem{ne96} \textsc{Karl Neumann}: Datenbanktechnik für
  Anwender. Hanser Fachbuch, 1996
\bibitem{moda97} \textsc{Alfred Moos}, \textsc{Gerhard Daues}:
  Datenbank-Engineering: Analyse, Entwurf und Implementierung
  relationaler Datenbanken mit SQL. Vieweg Verlagsgesellschaft,
  2.\,Auflage, 1997
\bibitem{maun07} \textsc{Günter Matthiessen}, \textsc{Michael
    Unterstein}: Relationale Datenbanken und SQL. Addison"=Wesley,
  München, 4.\,Auflage, 2007
\bibitem{ja76}\textsc{Donald Andrew Jardine}: The ANSI/SPARC DBMS
  Model. North-Holland Pub.\,Co., Amsterdam, 1977
\end{thebibliography}

\clearpage
\pdfbookmark[0]{Index}{index}
% Behebt das Problem der vielen "`overfull \hbox"' im Index
% <news:3419172.ueajl5DJLB@mjk.komascript.de>
\setlength{\parfillskip}{0pt plus 1fil}
\printindex

\end{document}
