\input{kopfteil.ltx}
\usepackage{booktabs}
\usepackage{colortbl}
\usepackage{mathtools}   % Zur Definition von \abs und \norm

% Um sicherzustellen, dass jeder Betrag/jede Norm links und rechts die
% Striche bekommt, sind diese Befehle da. Damit kann man nicht die
% rechten Striche vergessen und es wird etwas übersichtlicher. Aus
% mathtools.pdf, z. B. \abs[\big]{\abs{a}-\abs{b}} \leq \abs{a+b}
\DeclarePairedDelimiter{\abs}{\lvert}{\rvert}
\DeclarePairedDelimiter{\norm}{\lVert}{\rVert}

\subtitle{Hashalgorithmen}

\begin{document}
\begin{frame}
  \titlepage{}
\end{frame}

\section{Hashfunktionen}


\begin{frame}
  \frametitle{Hashfunktion}
  \begin{definition}
    Sei $n\in\mathbb{N}$. Eine Abbildung
    $h\colon\mathbb{Z}_{2}^{\infty}\rightarrow \mathbb{Z}_{2}^{n}$
    heißt \emph{Hashfunktion}.
  \end{definition}
  \pause{}
  \begin{itemize}
  \item<+-> macht aus beliebig langer Nachricht eine Nachricht fester Länge
  \item<+-> injektiv?
  \item<+-> Beispiel
  \item<+-> Umsetzung des Schutzzieles Integrität (Was ist bei
    $h(m_{1})= h (m_{2})$?)
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Kollisionsresistenz}
  \begin{definition}
    Eine Hashfunktion heißt \emph{kollisionsresistent}, falls sich in
    vertretbarer Zeit kein $h(m_{1})=h (m_{2})$ für $m_{1}\neq m_{2}$
    finden lässt.
  \end{definition}
\end{frame}

\begin{frame}
  \frametitle{Kollisionsresistenz}
  \begin{description}
  \item[First preimage] Gegeben ist ein Hashwert $h(m_{1})$ und gesucht
    ist eine Nachricht $m_{2}$ mit $h(m_{1})=h (m_{2})$.
  \item[Second preimage] Gegeben ist eine Nachricht $m_{1}$ und  gesucht
    ist eine Nachricht $m_{2}$ mit $h(m_{1})=h (m_{2})$.
  \item[Prefix collision] Gegeben seien zwei Präfixe $p_{1}, p_{2}$
    und gesucht sind zwei Nachrichten $m_{1}, m_{2}$ mit $h (p_{1}
    ||m_{1}) =h (p_{2} ||m_{2})$.
  \item[Kollision] siehe oben
  \end{description}
\end{frame}

\begin{frame}
  \frametitle{Angriffe beim SHA-3-Wettbewerb}
\footnotesize{\begin{tabular}{|c|c|c|c|}
    \toprule
    \cellcolor{brown}Abacus &
    ARIRANG &
    \cellcolor{brown}AURORA&
    BLAKE \\
    \cellcolor{red}Blender & 
    Blue Midnight Wish&
    \cellcolor{red}Boole &
    Cheetah\\
    CHI &
    CRUNCH &
    \cellcolor{brown}CubeHash&
    \cellcolor{red}DCH\\
    \cellcolor{red}Dynamic SHA &
    \cellcolor{red}Dynamic SHA &
    ECHO&
    \cellcolor{brown}ECOH\\
    \cellcolor{yellow}Edon-R &
    \cellcolor{red}EnRUPT&
    \cellcolor{red}ESSENCE &
    FSB \\
    Fugue&
    Grøstl &
    Hamsi &
    \cellcolor{brown}HASH 2X\\
    \cellcolor{brown}JH &
    Keccak &
    \cellcolor{red}Khichdi-1&
    LANE \\
    Lesamnta &
    Luffa&
    \cellcolor{red}LUX &
    \cellcolor{yellow}Maraca \\
    \cellcolor{brown}MCSSHA-3&
    MD6&
    \cellcolor{brown}MeshHash&
    \cellcolor{red}NaSHA\\
    \cellcolor{red}NKS2D&
    \cellcolor{brown}Ponic&
    SANDstorm &
    \cellcolor{yellow}Sarmal\\
    \cellcolor{red}Sgàil&
    Shabal&
    \cellcolor{red}SHAMATA&
    SHAvite-3\\
    SIMD&
    Skein&
    \cellcolor{red}Spectral Hash&
    \cellcolor{red}StreamHash \\
    SWIFFTX&
    \cellcolor{red}Tangle&
    \cellcolor{red}TIB3&
    \cellcolor{yellow}Twister\\
    \cellcolor{yellow}Vortex&
    \cellcolor{red}WaMM&
    \cellcolor{red}Waterfall&
    ZK-Crypt \\
    \midrule
    \cellcolor{yellow}Preimage & \cellcolor{brown}2nd preimage &
    \cellcolor{red} Collision & kein Angriff\\
    \bottomrule
  \end{tabular}}
\end{frame}

\begin{frame}
  \frametitle{Hashalgorithmen in der Praxis}
  \begin{itemize}
  \item<+-> MD5
  \item<+-> SHA-1, SHA-224, SHA-256, SHA-384, SHA-512
  \end{itemize}
  \pause{}
  Daneben existieren Hashalgorithmen auf der Basis von Blockchiffren.
\end{frame}

\subsection{MAC}


\begin{frame}
  \frametitle{Message Authentication Code}
  \begin{definition}
    Ein \emph{Message Authentication Code (MAC)} ist eine
    Hashfunktion, die zusätzlich einen Schlüssel~$k$ verwendet.
  \end{definition}
  \pause{}
  \begin{itemize}
  \item<+-> kein Nachweis der Authentizität
  \item<+-> CBC-MAC
  \item<+-> MD5-MAC
  \end{itemize}
\end{frame}

\subsection{HMAC}


\begin{frame}
  \frametitle{Hash-Based MAC}
  Gegeben sei eine Hashfunktion~$h$ mit Blocklänge~$r$ und ein
  Schlüssel~$k$.
  \begin{enumerate}
  \item<+-> Wenn $\abs{k}<r$, fülle Schlüssel bis zur Länge~$r$ mit
    Nullen auf.
  \item<+-> Wenn $\abs{k}>r$, berechne $h(k)$ und gehe ggf. wieder zu 1.
  \end{enumerate}
  \pause{}
  Danach werden zwei Strings \texttt{ipad} und \texttt{opad}
  erzeugt. Der Wert von \texttt{ipad} entsteht durch $r$-malige
  Konkatenation des Bitstrings~00110110 und \texttt{opad} durch
  $r$-malige Konkatenation von 01011100.
  \pause{}

  Schließlich wird der HMAC-Wert der Nachricht~$m$ durch
  \begin{gather*}
    \text{HMAC} (m,k)= h (k\oplus\text{opad}, h (k\oplus\text{ipad},m))
  \end{gather*}
  berechnet.
\end{frame}

\section{Elektronische Signaturen}



\end{document}
