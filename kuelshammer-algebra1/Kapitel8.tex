\chapter{Polynome und Codes}
\begin{itemize}
	\item Ziel der Codierungstheorie:
	\begin{itemize}
		\item sichere Datenübertragung und -speicherung [Funkverkehr zu Satelliten, Mobilfunk, CD, DVD, ... ]
		\item automatische Erkennung und Korrektur von Übertragungsfehlern [Rauschen, Staub, Kratzer, Materialfehler, ...]
	\end{itemize}
	\item durch geeignete Codierung und Decodierung:
	\[\begin{array}{ccccccccc}
\text{Nachricht} & \rightarrow & \text{Codierer} & \rightarrow & \text{Kanal} & \rightarrow & \text{Decodierer} & \rightarrow & \text{Nachricht}\\
& & & & \uparrow & & & &\\
& & & & \text{Rauschen} & & & &
\end{array}\]
\end{itemize}

Dabei:
\begin{itemize}
	\item Nachricht = Vektor in $K^k$ $(K \text{ endlicher Körper, } \left|K\right| = q)$ [oft $K = \F_2$, aber: bei CD, DVD: $K = \F_256$]
	\item Codierung: injektive Abbildung\\
	$\underbrace{E}_{\text{Encode}} \colon K^k \mapsto K^n \ (n > k)$  [oft: $E$ linear]
	\item Decodierung: $D \colon K^n \mapsto K^k$ mit $D \circ E = id_{K^k}$
	\item Hilfreich \highl{Hamming!Abstand}{Hamming--Abstand} \randbem{Hamming: Pionier der Codierungstheorie} $d \colon K^n \times K^n \mapsto \R$ \randbem{$d$ Metrik}
	\[d(x, y) := \left|\left\{i \colon 1 \leq i \leq n, x_i \neq y_i\right\}\right| \text{ für } x = (x_1, \ldots, x_n), (y_1, \ldots, y_n) \in K^n\] misst Anzahl der Fehler:
	\begin{itemize}
		\item $d(x, y) \geq 0$, $d(x, y) = 0 \Leftrightarrow x = y$
		\item $d(x, y) = d(y, x)$
		\item $d(x, z) \leq d(x, y) + d(y, z)$ (Dreiecksungleichung)
	\end{itemize}
	\item \highl{Hamming!Gewicht}{Hamming--Gewicht}: $w \colon K^n \mapsto \R$,
	\[w(x) = \left|\left\{i \colon 1 \leq i \leq n, x_i \neq 0\right\}\right| \text{ für } x = (x_1, \ldots, x_n) \in K^n\]
	Dann: $d(x, y) = w(x - y)$
\end{itemize}

%%%%%%%%%%%%%%%%%%%
% Definition 8.1
%%%%%%%%%%%%%%%%%%%
\begin{defi}{defi:8.1}
Ein (linearer) Code der Länge $n$ ist ein Untervektorraum $C \subseteq K^n$. Man nennt $k := \dim C$ die Dimension von $C$. Außerdem heißt
\[\delta := \min{\left\{d(x, y) \colon x, y \in C, x \neq y\right\}} = \min{\left\{w(z) \colon 0 \neq z \in C\right\}}\]
\highl{Minimalabstand} (\highl{Minimalgewicht}) von $C$. Man spricht dann auch von einem $\left[n, k, \delta\right]$--Code.
\end{defi}

\emph{Idee:} $C$ ist das Bild von $E \colon K^k \mapsto K^n$. Ist $e \in E$ mit $2e < \delta$ so kann $C$ mindestens $e$ Fehler korrigieren. (Kreise von Radius $e$ um Codewörter schneiden sich nicht.)

Ein "`guter"' Code hat folgende Eigenschaften:
\begin{itemize}
	\item großer Minimalabstand ($\Rightarrow$ gute Korrekturmöglichkeit)
	\item $\underbrace{\text{große Dimension}}_{\text{möglichst viele Codewörter in } C}$ ($\Rightarrow$ kostengünstig, effizient)
\end{itemize}
Beide Ziele liegen in verschiedenen Richtungen (Kompromisse!).

%%%%%%%%%%%%%%%%%%%
% Bemerkung 8.1
%%%%%%%%%%%%%%%%%%%
\begin{bem}\label{bem:8.1}
Viele \randbem{Vorteil dieser Konstruktion, zu Codes als Untervektorraum: man muss nur $\varphi$ und $n$ speichern, keine Basis eines Untervektorraumes mit $k$ Elementen} in der Praxis auftretende Codes werden mit Hilfe von Polynomringen konstruiert. Dabei identifiziert man $K^n$ mit $K[X] / (X^n - 1)$ durch \[(a_0, a_1, \ldots, a_{n-1}) \leftrightarrow a_0 + a_1X + a_2X^2 + \ldots + a_{n-1}X^{n-1} + (X^n - 1)\]
Für jeden Teiler $\varphi$ von $X^n - 1$ gilt: $(X^n - 1) \subseteq (\varphi)$.\\
Daher ist $C := (\varphi) / (X^n - 1) := \left\{\alpha\varphi + (X^n - 1) \colon \alpha \in K[X]\right\}$ ein Untervektorraum von $K[X] / (X^n - 1)$. Man nennt $C$ den \highl{Zyklischer Code}{zyklischen Code} der Länge $n$ über $K$ mit \highl{Generatorpolynom} $\varphi$.
\end{bem}

%%%%%%%%%%%%%%%%%%%
% Satz 8.1
%%%%%%%%%%%%%%%%%%%
\begin{satz}\label{satz:8.1}
Sei $C := (\varphi) / (X^n - 1)$ wie oben und $l := \deg\varphi$, also $l \leq n$. Dann gilt: $\dim C = n - l$.
\end{satz}

%%%%%%%%%%%%%%%%%%%
% Beweis
%%%%%%%%%%%%%%%%%%%
\begin{beweis}
Schreibe $\varphi = a_0 + a_1X + \ldots + a_lX^l \ (a_0, \ldots, a_l \in K, a_l \neq 0)$.\\
Dann sind 
\[\begin{array}{rcllllll}
\varphi + (X^n - 1) & = & a_0 & + & a_1X + & & \ldots + a_lX^l & + (X^n - 1)\\
X\varphi + (X^n - 1) & = & & & a_0X + a_1X^2 + & & \ldots + a_lX^{l + 1} & + (X^n - 1)\\
& \vdots \\
X^{n - l - 1}\varphi + (X^n - 1) & = & & & & a_0X^{n - l - 1} + & \ldots + a_lX^{n - 1} & + (X^n - 1)
\end{array}\]
offenbar linear unabhängig in $C$.\\
Also: $\dim C \geq n - l$.\\
Wegen $\varphi\mid X^n - 1$ existiert ein $\psi \in K[X]$ mit $X^n - 1 = \varphi\psi$. Sei $\alpha \in (\varphi)$, etwas $\alpha = \beta\varphi$ mit $\beta \in K[X]$.\\
Division mit Rest: $\beta = \kappa\psi + \rho$ mit $\deg\rho < \deg\psi = n - l$.\\
Schreibe $\rho = r_0 + r_1X + \ldots + r_{n - l - 1}X^{n - l - 1} \ (r_i \in K)$.\\
Dann: \[
\begin{array}{lcl}
\alpha + (X^n - 1) & = & \beta\varphi + (X^n - 1) = \kappa\underbrace{\varphi\psi}_{= (X^n - 1)} + \rho\varphi + (X^n - 1)\\
& = & \rho\varphi + (X^n - 1)\\
& = & r_0\varphi + r_1X\varphi + \ldots + r_{n - l - 1}X^{n - l - 1}\varphi + (X^n - 1)
\end{array}\]
Daher bilden $\varphi + (X^n - 1), X\varphi + (X^n - 1), \ldots, X^{n - l - 1}\varphi + (X^n - 1)$ eine Basis von $C$.
\end{beweis}

%%%%%%%%%%%%%%%%%%%
% Beispiel 8.1
%%%%%%%%%%%%%%%%%%%
\begin{bsp}\label{bsp:8.1}
\begin{enumerate}[(a)]
	\item (\highl{Code!Ternärer Golay}{Ternärer Golay Code})\\
	$q = 3, n = 11, \varphi = X^5 + X^4 - X^3 + X^2 - 1 \in \F_3[X], C := (\varphi) / (X^{11} - 1)$. [Man kann zeigen, dass $\varphi$ ein irreduzibler Teiler von $X^{11} - 1$ ist.]\\
	Dann hat $C$ Länge $n = 11$ und Diemension $k = 6$.\\
	Indem \randbem{Minimalgewicht bei Polynomen: Anzahl von $0$ verschiedenen Koeffizienten.} man die $3^6 = 729$ Codewörter berechnet (Computer!), sieht man, dass $C$ das Minimalgewicht $\delta = 5$ hat. (Das geht auch mit etwas Theorie.)\\
	Daher schneiden sich Kreise mit Radius $2$ um Codewörter nicht. Jeder Kreis enthält: 
	\[1 + \underbrace{11 \cdot 2}_{\text{Vektoren mit Abstand } 1} + \underbrace{\binom{11}{2} \cdot 4}_{\text{Abstand } 2} = 243 = 3^5\]
	Vektoren. \randbem{Code kann 2 Fehler korrigieren.} Daher enthalten die Kreise vom Radius $2$ umd die $3^6$ Codewörter, insgesamt genau $3^6 \cdot 3^5 = 3^{11}$ verschiedene Vektoren, überdecken also ganz $\F_3^{11}$. Man spricht von einem \highl{Code!perfekter}{perfekten Code}.
	\item (\highl{Code!Binärer Golay}{Binärer Golay Code})\\
	$q = 2, n = 23, \varphi := X^{11} + X^{10} + X^6 + X^5 + X^4 + X^2 + 1 \in \F_2[X], C := (\varphi) / (X^n - 1)$. [Man kann zeigen, dass $\varphi$ ein irreduzibler Teiler von $X^{23} - 1$ ist.]\\
	Dann hat $C$ Länge $n = 23$ und Dimension $k = 12$.\\
	Indem man die $2^{12} = 4096$ Codewörter ausrechnet (Computer!), sieht man, dass $C$ Minimalgewicht $\delta = 7$ hat. (Das geht auch mit etwas Theorie.)\\
	Daher schneiden sich Kreise vom Radius $3$ um Codewörter nicht. Jeder Kreise enthält:
	\[1 + 23 + \binom{23}{2} + \binom{23}{3} = 2048 = 2^{11}\]
	Vektoren. Diese $2^{12}$ Kreise enthalten insgesamt $2^{12} \cdot 2^{11} = 2^{23}$ Vektoren, überdecken ganz $\F_2^{23}$. Man spricht wieder von einem perfekten Code.
\end{enumerate}
\end{bsp}

%%%%%%%%%%%%%%%%%%%
% Bemerkung 8.2
%%%%%%%%%%%%%%%%%%%
\begin{bem}\label{bem:8.2}
Die Golay-Codes sind sowohl für die Theorie als auch für die Praxis von großer Bedeutung. Man kann zeigen, dass sie im wesentlichen die beiden einzigen perfekten Codes sind, die mehr als einen Fehler korrigieren können.
\end{bem}