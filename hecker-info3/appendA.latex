
\begin{figure}
   $$ \input {appa_p1.latex} $$
   \caption{Liniensegmente mit Gleitgerade}
   \label{appa_p1}
\end{figure}

Der \textsc{Plane-Sweep}-Algorithmus ist eine äußerst bekannte
Methode zur Lösung von Mengenproblemen. Der primäre Gedanke
besteht darin, eine vertikale Gerade, die {\it Sweep\-line}, von
links nach rechts durch die Ebene zu schieben und dabei den
Schnitt der Geraden mit der Objektmenge zu beobachten. Es
ist ebenfalls möglich, statt einer vertikalen Sweepline eine
horizontale zu verwenden und diese von oben nach unten über die
Objekte zu führen. Einige Algorithmen benötigen mehrere Sweeps,
durchaus in unterschiedliche Richtungen, um gewonnene Daten aus
vorangegangenen Überstreichungen zu verarbeiten.

Dazu "`merkt"' sich die Sweepline entsprechend ihrer aktuellen
Position die horizontal schneidenden Segmente anhand deren
$y$-Koordinaten. Bei Erreichen eines vertikalen Elements
werden alle in der Sweepline vorhandenen $y$-Koordinaten
ermittelt, die im $y$-Intervall des vertikalen Segments
liegen.

Die Gleitgerade wird nicht stetig über die Objektmenge
geführt, überabzählbar viele Teststellen wären die Folge. 
Lediglich $x$-Koordinaten, an denen ein Ereignis
eintreten kann, werden in der Simulation berücksichtigt.

Im vorliegenden Fall sind das Anfangs- und End-$x$-Koordinaten von
horizontalen Elementen sowie die $x$-Koordinate 
vertikal verlaufender Strecken. Diese Werte bilden die Menge
der {\it event points}, sie kann häufig statisch implementiert werden.

Die Sweepline-Status-Struktur hingegen muß dynamisch sein, da sich
deren Umfang und Belegung an jedem event point ändern kann.

Zur Beschreibung des Verfahrens ist es erforderlich, die nachfolgende
Terminologie zu vereinbaren. Sie orientiert sich an der mathematischen
Schreibweise:

\begin{description}

\item[$h=(x_1,x_2,y)$:] horizontal verlaufendes Liniensegment mit dem
    Anfangspunkt $(x_1,y)$ und dem Endpunkt $(x_2,y)$
\item[$v=(x,y_1,y_2)$:] vertikal verlaufendes Liniensegment mit dem
    Anfangspunkt $(x,y_1)$ und dem Endpunkt $(x,y_2)$
\item[$t_i$ für $t=(x_1,\dots,x_n)$:] Zugriff auf die $i$-te Komponente des 
   Tupels $t$, also $t_i=x_i$
\item[$\pi_i(S)$:] Für eine Tupelmenge $S$ ist $\pi_i(S)$ die Projektion
   auf die $i$-te Komponente
\end{description} 

Der Algorithmus gestaltet sich dann in dieser Weise:

{\bf Algorithmus} \textsc{SegmentIntersectionPS (H,V)}\\
\{Eingabe ist eine Menge horizontaler Segmente H und eine Menge vertikaler
 Segmente V, berechne mit Plane-Sweep die Menge aller Paare $(h,v)$
mit $h{\in}H$ und $v{\in}V$ und $h$ schneidet $v$\}

\begin{enumerate}
\item
Sei \begin{displaymath}
  \begin{array}{rcl}
  S =&& \{(x_1, (x_1,x_2;y)) | (x_1,x_2,y)\in H\}\\
  &\cup& \{(x_2,(x_1,x_2,y)) | (x_1,x_2,y)\in H\}\\
  &\cup& \{(x,(x,y_1,y_2)) | (x,y_1,y_2)\in V\};
\end{array}
\end{displaymath}
($S$ ist also eine gemischte Menge von horizontalen und vertikalen Segmenten,
in der jedes horizontale Segment einmal anhand des linken und einmal
anhand des rechten Endpunkts dargestellt ist. Diese Menge beschreibt die
Sweep-Event-Struktur.)\\
Sortiere $S$ nach der ersten Komponente, also nach $x$-Koordinaten.

\item
Sei $Y$ die Menge horizontaler Segmente, deren $y$-Koordinate als
Schlüssel verwendet wird (Sweepline-Status-Struktur);\\
$Y:=\emptyset$;\\
durchlaufe $S$: das gerade erreichte Objekt ist
\begin{enumerate}
\item
linker Endpunkt eines horizontalen Segments $h=(x_1,x_2,y)$:\\
$Y := Y \cup \{(y,(x_1,x_2,y))\}$ (füge $h$ in $Y$ ein)
\item
rechter Endpunkt von $h=(x_1,x_2,y)$:\\
$Y := Y \backslash \{(y,(x_1,x_2,y))\}$ (entferne $h$ aus $Y$)
\item
ein vertikales Segment $v=(x,y_1,y_2)$:\\
$A :=$ 
$\pi_2 (\{w\in Y | w_0 \in [y_1,y_2] \})$;
 \hspace{1cm}  (finde alle Segmente in $Y$, deren
   $y$-Koordinate im $y$-Intervall von $v$ liegt)\\
gibt alle Paare in $A\times\{v\}$ aus
\end{enumerate}
\end{enumerate}
{\bf end} \textsc{SegmentIntersectionPS} 


