\RequirePackage[l2tabu,orthodox]{nag}
\documentclass[halfparskip,pointednumbers,smallheadings,headsepline,footsepline]{scrreprt}
\usepackage[ngerman]{babel}
\usepackage[T1]{fontenc}
\usepackage[latin1]{inputenc}
\usepackage{amsmath,amsthm,amssymb,xspace,url,svn,color,fixmath,pifont,hyperref,booktabs,tikz}
\usetikzlibrary{calc}

\theoremstyle{definition}

\newtheorem{defi}{Definition}
\theoremstyle{remark}
\newtheorem*{bsp}{Beispiel}

\newcommand*{\bR}{\ensuremath{\mathbb{R}}\xspace}
\newcommand*{\cO}{\ensuremath{\mathcal{O}}\xspace}

\let\epsilon\varepsilon
\let\phi\varphi
\let\rho\varrho
\let\kappa\varkappa

\let\emptyset\varnothing
\let\subset\subseteq
\let\subsetneq\subsetneqq

\newcommand*{\pmat}[1]{\ensuremath{\begin{pmatrix} #1 \end{pmatrix}}\xspace}
\newcommand*{\bmat}[1]{\ensuremath{\begin{bmatrix} #1 \end{bmatrix}}\xspace}
\newcommand*{\vmat}[1]{\ensuremath{\begin{vmatrix} #1 \end{vmatrix}}\xspace}
\newcommand*{\Bmat}[1]{\ensuremath{\begin{Bmatrix} #1 \end{Bmatrix}}\xspace}
\newcommand*{\Vmat}[1]{\ensuremath{\begin{Vmatrix} #1 \end{Vmatrix}}\xspace}
\newcommand*{\kpmat}[1]{\ensuremath{\left(\begin{smallmatrix} #1 \end{smallmatrix}\right)}\xspace}
\newcommand*{\kbmat}[1]{\ensuremath{\left[\begin{smallmatrix} #1 \end{smallmatrix}\right]}\xspace}
\newcommand*{\kBmat}[1]{\ensuremath{\left\{\begin{smallmatrix} #1 \end{smallmatrix}\right\}}\xspace}
\newcommand*{\kvmat}[1]{\ensuremath{\left|\begin{smallmatrix} #1 \end{smallmatrix}\right|}\xspace}
\newcommand*{\kVmat}[1]{\ensuremath{\left\|\begin{smallmatrix} #1 \end{smallmatrix}\right\|}\xspace}

\SVN $Revision$
\SVN $Date$
\SVN $LastChangedRevision$
\SVN $LastChangedDate$

\begin{document}
\pagestyle{headings}
\title{Schnelle iterative Löser großer schwach besetzter linearer Gleichungssysteme}
\author{Professor\,Dr.\,G. W. Zumbusch\\FSU Jena}
\date{}
\maketitle

\chapter*{Vorwort}

  Dieses Dokument wurde als Skript für die auf der Titelseite genannte
  Vorlesung erstellt und wird jetzt im Rahmen des Projekts "`Vorlesungsskripte
  der Fakultät für Mathematik und Informatik"' weiter betreut. Das Dokument
  wurde nach bestem Wissen und Gewissen angefertigt. Dennoch garantiert weder
  der auf der Titelseite genannte Dozent, die Personen, die an dem Dokument
  mitgewirkt haben, noch die Mitglieder des Projekts für dessen
  Fehlerfreiheit. Für etwaige Fehler und dessen Folgen wird von keiner der
  genannten Personen eine Haftung übernommen. Es steht jeder Person frei,
  dieses Dokument zu lesen, zu verändern oder auf anderen Medien verfügbar zu
  machen, solange ein Verweis auf die Internetadresse des Projekts
  \url{http://uni-skripte.lug-jena.de/} enthalten ist.

  Diese Ausgabe trägt die Versionsnummer~\SVNRevision{} und ist vom
  \SVNDate{}. Eine neue Ausgabe könnte auf der Webseite des Projekts
  verfügbar sein.

  Jeder ist dazu aufgerufen, Verbesserungen, Erweiterungen und
  Fehlerkorrekturen für das Skript einzureichen bzw. zu melden oder diese
  selbst einzupflegen -- einfach eine E-Mail an die Mailingliste
  \texttt{<uni-skripte@lug-jena.de>} senden. Weitere Informationen sind
  unter der oben genannten Internetadresse verfügbar.

  Hiermit möchten wir allen Personen, die an diesem Skript mitgewirkt haben,
  vielmals danken:
  \begin{itemize}
   \item Ivo Hedtke \texttt{<hedtke@math.uni-jena.de>} (2008/09)
  \end{itemize}


\tableofcontents

\chapter*{Literatur}

\begin{enumerate}
    \item \textsc{W. Hackbusch}: Iterative Lösung großer schwachbesetzter Gleichungssysteme. 1991.
	\item \textsc{A. Meister}: Numerik linearer Gleichungssysteme. Eine Einführung in moderne Verfahren. 2007.
\end{enumerate}

\chapter{Grundbegriffe}

Parallele Algorithmen und Parallelisierung von Iterationsverfahren

\paragraph{Warum?} \begin{itemize}
    \item Verfügbarkeit von Parallelrechnern (Dual-Core, \dots)
\item Physikalische Grenzen
\item Parallelität in vielen Anwendungen
\end{itemize}

\section{Modellproblem: Skalarprodukt von Vektoren}

Seien $x,y \in \bR^n$. Wir wollen berechnen: \[S = \langle x,y \rangle = \sum_{i=0}^{n-1}x_i y_i.\]

\paragraph{Parallelität?}
\begin{enumerate}
    \item Berechnung der $x_i y_i$ $\forall i$ unabhängig
\item Sei $P$ die Anzahl der Prozessoren ($n \gg P$). Die Indizes $\{0,\dots, n-1\}$ werden auf die Prozessoren verteilt: \[I_p \subset \{0,\dots,n-1\}.\] Jeder Prozessor berechnet eine Teilsumme: \[S_p = \sum_{i \in I_p} x_i y_i.\]
\item Gesamtsumme:
\begin{enumerate}
    \item sequentiell: $S = \sum_{p=0}^{P-1} S_p$ oder
\item parallel: (Beispiel $P=8)$\begin{align*}
S &= \underbrace{S_0 + S_1}_{S_{01}} + \underbrace{S_2 + S_3}_{S_{23}} + \underbrace{S_4 + S_5}_{S_{45}} + \underbrace{S_6 + S_7}_{S_{67}}\\
&= \underbrace{S_{01} + S_{23}}_{S_{0123}} + \underbrace{S_{45} + S_{67}}_{S_{4567}}\\
&= \underbrace{S_{0123} + S_{4567}}_{S_{01234567}}\\
&= S_{01234567} = S
\end{align*}
\end{enumerate}
Statt $7$ Schritten im sequentiellen Verfahren werden hier nur $3$ benötigt.
\end{enumerate}

Gesamtaufwand sequentiell: $\cO(n)$.

Aufwand in jedem parallelen Schritt:
\begin{enumerate}
    \item $\frac{n}{P}$
\item $\frac{n}{P}$
\item $\log P$
\end{enumerate}

Gesamtaufwand im parallelen Verfahren: $\cO\left(\frac{n}{P} + \log P\right)$. Für die Extremfälle haben wir:
\begin{itemize}
    \item $n \to \infty$: $\cO\left(\frac{n}{P}\right)$, eine Beschleunigung um den Faktor $P$
\item $n \approx P$: $\cO(\log N)$
\end{itemize}

\section{Kommunizierende sequentielle Prozesse}

\begin{defi}[Sequentieller Prozess]
Abstraktion, Ausführen eines sequentiellen Programms. Jederzeit klarer Zustand. Genau ein Befehlszähler (PC, Program Counter) und Variablen (Speicher, Register).
\end{defi}

\begin{defi}[Paralleles Programm]
Interagierende sequentielle Prozesse. Sinnvoll auf mehreren Prozessoren. Gegebenenfalls zyklisches Umschalten.
\end{defi}

\newpage\minisec{Vereinfachtes Muster eines parallelen Programms}

\begin{verbatim}
{
   globale Variablen

   thread<name>[Parameter]{
      lokale Variablen
      Anweisungen
   }

   thread<name>[...]{
      ...
   }

   ...
}
\end{verbatim}

\minisec{Modell mit statischen Prozessen}

Starte alle.  Paralleles Programm terminiert, wenn alle Prozesse terminieren.

Üblicherweise unterscheidet man zwischen:
\begin{itemize}
    \item Prozessen: Eigener Adressraum
\item Threads: Gemeinsamer Adressraum, billiger
\end{itemize}

\minisec{Darstellung des Skalarproduktes in verschiedenen Modellen}

\begin{bsp} Skalarprodukt mit $2$ Prozessen\\
\verb|{ N=8; real X[N], Y[N], s=0;|\\
\verb|   thread| $\pi_\mathtt{1}$ \verb|{ real t=0;|\\
\verb|      for i=0 ...| $\mathtt{\left(\frac{N}{2} -1\right)}$\\
\verb|         t = t + X[i]*Y[i];|\\
\verb|      s = s + t;}|\\
\verb|   thread| $\pi_\mathtt{2}$ \verb|{ real t=0;|\\
\verb|      for i=| $\mathtt{\frac{N}{2}}$ \verb|... N|\\
\verb|         t = t + X[i]*Y[i];|\\
\verb|      s = s + t;}|\\
\verb|}|

Es fehlt die Eingabe von \texttt{X} und \texttt{Y}. Ein Thema hier ist \textit{paralleles Lesen}. Fehler können beim \textit{parallelen Schreiben} auftreten. Was ist das Ergebnis beim parallelen Schreiben?

Problem ist die Zeile "`\verb|s=s+t|"'.  
\end{bsp}

\section{Der kritische Abschnitt (Detailbetrachtung von \texttt{s=s+t})}

(Die Zahlen in den Kreisen kennzeichnen Programmzeilen, auf die wir uns später wieder beziehen werden.)

\begin{tabbing}
\ding{202}\verb|  |\= \verb|ADDIERE  R1, R2 NACH R3| XXXXXXXXXXX \= \ding{202}\verb|  |\= \verb|ADDIERE  R1, R2 NACH R3|\kill
\verb|THREAD| $\pi_\mathtt{1}$ \> \> \verb|THREAD| $\pi_\mathtt{2}$\\
\ding{202}\>\verb|LADE     s      IN   R1| \> \ding{204}\>\verb|LADE     s      IN   R1|\\
\>\verb|LADE     t      IN   R2| \> \>\verb|LADE     t      IN   R2|\\
\>\verb|ADDIERE  R1, R2 NACH R3| \>\>\verb|ADDIERE  R1, R2 NACH R3|\\
\ding{203}\>\verb|SCHREIBE R3     NACH s| \> \ding{205}\>\verb|SCHREIBE R3     NACH s|\\
\end{tabbing}





Innerhalb eines Prozesses wird die Reihenfolge der Programmzeilen eingehalten.

CSP: Hintereinanderausführung in jedem Thread.
\begin{itemize}
    \item In Thread $\pi_1$ wird Zeile 1 zuerst und Zeile 4 zuletzt ausgeführt
\item Analog in Thread $\pi_2$
\end{itemize}

Aber wie sieht die relative Reihenfolge aus, wenn die Threads nicht Zeile für Zeile parallel laufen?

Beispiele:
\begin{center}
\begin{tabular}{ll}
\toprule
\textbf{Reihenfolge} & \textbf{Ergebnis}\\ \midrule
\ding{202} \ding{203} \ding{204} \ding{205} & $s=t_1 + t_2$\\
\ding{204} \ding{205} \ding{202} \ding{203} & $s= t_2 + t_2$ auch korrekt\\
\ding{202} \ding{204} \ding{203} \ding{205} & $s = t_2$ falsch\\
\ding{202} \ding{204} \ding{205} \ding{203} & $s=t_1$ falsch\\
\ding{204} \ding{202} \ding{203} \ding{205} & $s=t_2$ falsch\\
\ding{204} \ding{202} \ding{205} \ding{203} & $s=t_1$ falsch\\\bottomrule
\end{tabular}
\end{center}


Benötigen einen Mechanismus, sodass die beiden Prozessoren aufeinander Rücksicht nehmen.

\minisec{Lösung des Problems "`Kritische Abschnitte"' (critical region)}
Mit gegenseitigem Ausschluss (mutual exclusion = "`MUTEX"')
Schreibweise in CSP: Anweisung in eckige Klammern setzen: \verb|[s=s+t]|. Die Reihenfolge (auch im Konfliktfall) ist noch immer unbestimmt, diese brauchen wir auch nicht. Aber im Konfliktfall wird diese Operation nacheinander abgearbeitet.

Es wird so ausgeführt: [\ding{202} \ding{203}] [\ding{204} \ding{205}] oder [\ding{204} \ding{205}] [\ding{202} \ding{203}]

\section{Parametrisierte Form (single program -- multiple data, = "`SPMD"')}

Häufig eine variable Zahl von Prozessen. Wir wollen eine Aufteilung gleichartiger Operationen. Wir wollen ein Programm für alle.

\begin{bsp}
Skalarprodukt mit $P=$\texttt{Pr} Prozessoren

\verb|{ int N, Pr; real X[N], Y[N], s=0;|\\
\verb|   thread| $\pi$ \verb|(int p) {|\\
\verb|      real t = 0;|\\
\verb|      for i=| $\mathtt{N\cdot \frac{p}{Pr}}$ \verb|...| $\mathtt{\left( N \cdot \frac{p+1}{Pr} - 1 \right)}$\\
\verb|         t = t + X[i]*Y[i];|\\
\verb|      [s = s + t;]}   // Kritischer Abschnitt|\\
\verb|}|

Jeder Prozess wird meinem anderen $p$ gestartet. Das Programm macht daraus die Verteilung der Operationen.

Für diese Implementierung haben einen Aufwand von $\cO \left( \frac{N}{P} + P\right)$
\end{bsp}

\section{Verbesserung der Effizienz}

Der kritische Abschnitt läuft sequentiell ab.

Ziel ist es, den kritischen Abschnitt baumartig auszuführen, damit ein logarithmischer Aufwand entsteht. Auch ein Ziel ist es, dass der kritische Abschnitt nicht mehr kritisch ist.

\begin{figure}[t!]
\centering \begin{tikzpicture}
\draw[->] (-2,0) -- (-1,0) (-1.5,0) -- (-1.5,-6.5);
\draw (-1.5,-3) node[rotate=90,above] {Schritte};
\draw (-1.5,-1) node[right] {1.};
\draw (-1.5,-3) node[right] {2.};
\draw (-1.5,-5) node[right] {3.};
\draw (0,0) node[right] (a) {$S_0$};
\draw (1,0) node[right] (b) {$S_1$};
\draw (2,0) node[right] (c) {$S_2$};
\draw (3,0) node[right] (d) {$S_3$};
\draw (4,0) node[right] (e) {$S_4$};
\draw (5,0) node[right] (f) {$S_5$};
\draw (6,0) node[right] (g) {$S_6$};
\draw (7,0) node[right] (h) {$S_7$};
\draw (0,-2) node[right] (aa) {$S_0 + S_1$};
\draw (2,-2) node[right] (bb) {$S_2 + S_3$};
\draw (4,-2) node[right] (cc) {$S_4 + S_5$};
\draw (6,-2) node[right] (dd) {$S_6 + S_7$};
\draw (0,-4) node[right] (aaa) {$S_0 + S_1 + S_2 + S_3$};
\draw (4,-4) node[right] (bbb) {$S_4 + S_5 + S_6 + S_7$};
\draw (0,-6) node[right] (aaaa) {$S_0 + S_1 + S_2 + S_3+S_4 + S_5 + S_6 + S_7$};
\draw[->] (a.south west) -- (aa.north west);
\draw[->] (b.south west) -- ($(aa.north west)+(0.1,0)$);
\draw[->] (c.south west) -- (bb.north west);
\draw[->] (d.south west) -- ($(bb.north west)+(0.1,0)$);
\draw[->] (e.south west) -- (cc.north west);
\draw[->] (f.south west) -- ($(cc.north west)+(0.1,0)$);
\draw[->] (g.south west) -- (dd.north west);
\draw[->] (h.south west) -- ($(dd.north west)+(0.1,0)$);
\draw[->] (aa.south west) -- (aaa.north west);
\draw[->] (bb.south west) -- ($(aaa.north west)+(0.1,0)$);
\draw[->] (cc.south west) -- (bbb.north west);
\draw[->] (dd.south west) -- ($(bbb.north west)+(0.1,0)$);
\draw[->] (aaa.south west) -- (aaaa.north west);
\draw[->] (bbb.south west) -- ($(aaaa.north west)+(0.1,0)$);
\draw (0,-.5) node[right,fill=black!20] {\tiny \sffamily 000};
\draw (1,-.5) node[right,fill=black!20] {\tiny \sffamily 001};
\draw (2,-.5) node[right,fill=black!20] {\tiny \sffamily 010};
\draw (3,-.5) node[right,fill=black!20] {\tiny \sffamily 011};
\draw (4,-.5) node[right,fill=black!20] {\tiny \sffamily 100};
\draw (5,-.5) node[right,fill=black!20] {\tiny \sffamily 101};
\draw (6,-.5) node[right,fill=black!20] {\tiny \sffamily 110};
\draw (7,-.5) node[right,fill=black!20] {\tiny \sffamily 110};
\draw (0,-2.5) node[right,fill=black!20] {\tiny \sffamily 000};
\draw (2,-2.5) node[right,fill=black!20] {\tiny \sffamily 010};
\draw (4,-2.5) node[right,fill=black!20] {\tiny \sffamily 100};
\draw (6,-2.5) node[right,fill=black!20] {\tiny \sffamily 110};
\draw (0,-4.5) node[right,fill=black!20] {\tiny \sffamily 000};
\draw (4,-4.5) node[right,fill=black!20] {\tiny \sffamily 100};
\draw (0,-6.5) node[right,fill=black!20] {\tiny \sffamily 000};
\end{tikzpicture}
\caption{Schema zu "`Skalarprodukt Baumkombination"'. \newline \tiny Die Pfeile kennzeichnen Warteabhängigkeiten zwischen Threads. Die Zahlen in den grauen Kästen sind die Binärdarstellungen der Zahl $p$ des aktivin Threads $p$.}

\vspace{5mm}

\hrule
\end{figure}

Wir brauchen eine globale Variable für Zwischenergebnisse \verb|S[p]| und für die Terminierung $\verb|flag[p]|.$

Sei \texttt{Pr}$=P= 2^d$. Im Schritt $i \in \{0, \dots, d-1\}$ addiert
\begin{center}
Thread "`$l=\dots \underbrace{0\dots\dots 0}_{i+1 \text{ Nullen} }$"'
\end{center}
mit
\begin{center}
Thread "`$r=\dots 1 \underbrace{0\dots\dots 0}_{i \text{ Nullen}}$"'
\end{center}
(die vorderen Zifferen -- die "`\dots"' -- müssen gleich sein), der danach terminiert.

\minisec{Skalarprodukt Baumkombination}
\verb|{ int N, d, Pr=| $\mathtt{2^d}$ \verb|; real X[N], y[N], s[Pr]=0;|\\
\verb|  boolean flag[Pr] = false; // Initialisierung vor Start des|\\
\verb|                           // ersten Threads|\\
\verb|   thread | $\pi$ \verb|(int p){|\\
\verb|      for i=| $\mathtt{N\cdot\frac{p}{Pr}}$ \verb|...| $\mathtt{\left( N\cdot\frac{p+1}{Pr} - 1\right)}$\\
\verb|         S[p] = S[p] + X[i]*Y[i];|\\
\verb|      for i = 0,...,d-1|\\
\verb|         l = (p >> (i+1)) << (i+1); // lösche (i+1) Bits|\\
\verb|         r = l +| $\mathtt{2^i}$ \verb|;|\\
\verb|         if (p==r)|\\
\verb|            flag[p]=true; end;|\\
\verb|         if (p==l)|\\
\verb|            while (flag[r] == false) // BUSY WAIT|\\
\verb|               S[p] = S[p] + S[r];}|\\
\verb|}|

Ergebnis liegt am Ende in \verb|S[0]|. Alternativ zum Busy Wait kann man Synchronisation des OS verwenden.




\end{document}
