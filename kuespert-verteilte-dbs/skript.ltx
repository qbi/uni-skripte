% ToDo:
% * LaTeX ist nicht so besonders gut im Setzen von Stichwortlisten. Daher
%   sollte alles als Text geschrieben werden
%
% Einige zusätzliche Informationen für rubber
% rubber: makeidx.tool      xindy
% rubber: makeidx.language  german-din
%
% scrreprt trifft am Besten die Bedürfnisse eines Skripts, das ganze wird
% zweiseitig (twoside), d.h. es wird zwischen linker und rechter Seite
% unterschieden, und wir verwenden zwischen den Absätzen einen Abstand
% von einer halben Zeile (halfparskip) und dafür keinen Absatzeinzug,
% wobei die letzte Zeile eines Absatzes zu min. 1/4 leer ist.

\RequirePackage[l2tabu,orthodox]{nag}  % nag überprüft den Text auf veraltete
                   % Befehle oder solche, die man nicht in LaTeX verwenden
                   % soll -- l2tabu-Checker in LaTeX

\documentclass[english,ngerman,draft,parskip=half*]{scrreprt}

\usepackage{ifthen}
\usepackage{index}
% \usepackage[final]{graphicx}  % Für Grafiken
\usepackage{xcolor}
\usepackage[draft=false,colorlinks,bookmarksnumbered,linkcolor=blue,breaklinks]{hyperref}

\usepackage[latin1]{inputenc}
\usepackage{babel}
% \usepackage{nicefrac}
% \usepackage{tabularx}

\usepackage{lmodern}		% Latin Modern
% \usepackage{type1ec}           % cm-super
\usepackage[T1]{fontenc}        % T1-Schriften notwendig für PDFs
\usepackage{textcomp}           % wird benötigt, damit der \textbullet
                                % für itemize in lmodern gefunden wird.

\usepackage[intlimits,leqno]{amsmath}
\usepackage[all,warning]{onlyamsmath}  % warnt bei Verwendung von nicht
                                       % amsmath-Umgebungen z.\,B. $$...$$
\usepackage{amssymb}     % wird für \R, \C,... gebraucht
\usepackage{fixmath}     % ISO-konforme griech. Buchstaben

\usepackage{paralist}    % besseres enumerate und itemize und neue
                         % compactenum/compactitem; s. texdoc paralist

\usepackage{svn}         % Zum Auswerten und ordentlichen Darstellen der
                         % SVN-Schlüsselwörter (s. vor \begin{document})
                         % dafür muss in SVN noch das Flag svn:keywords
                         % auf "LastChangedRevision LastChangedDate"
                         % gesetzt werden
% \usepackage{ifpdf}       % Erkennung, ob PDF generiert wird; nützlich zur
                         % Unterscheidung bei Grafiken \input{XYZ.pdf_t}
\usepackage{fixltx2e}
\usepackage[final]{microtype} % Verbesserung der Typographie
\usepackage{acronym}
\usepackage[weather]{ifsym}
\usepackage{wasysym}

% Zwischen Unter- und Unterunterabschnitten sollte nicht unterschieden
% werden.
\renewcommand*{\subsectionautorefname}{Abschnitt}
\renewcommand*{\subsubsectionautorefname}{Abschnitt}

\pagestyle{headings}

% Wenn irgendwo Unklarheiten zum Inhalt im Skript auftreten, können sie
% einfach mit \help{Ich verstehe das nicht} hervorgehoben werden. Dies
% macht es leichter sie alle zu finden und auch ganz einfach
% auszublenden, indem man den Befehl einfach leer definiert
\newcommand*{\help}[1]{\textcolor{green}{help: #1}}

% \todo ist das gleiche wie \help nur für offene Aufgaben
\newcommand*{\todo}[1]{\textcolor{red}{todo: #1}}

% Um wichtige Begriffe im Text überall gleich vorzuheben (gleiches
% Markup), sollte dieser Befehl verwendet werden. Das Argument wird
% automatisch als Indexeintrag verwendet. Dieser kann aber auch als
% optionales Argument selbst bestimmt werden.
\newcommand*{\highl}[2][]{\textbf{\boldmath{#2}}%
  \ifthenelse{\equal{#1}{}}{\index{#2}}{\index{#1}}%
}

% Befehl für die Darstellung der Gliederungsüberschriften im Index
\newcommand*{\lettergroup}[1]{\minisec{#1}}

\newcounter{prechap}
\newcommand*{\predefchap}[1]{%
  \stepcounter{prechap}%
  \expandafter\newcommand \csname prechap\roman{prechap}\endcsname{#1}%
  \section*{\arabic{prechap}~#1}}
\newcommand*{\nextchapter}{%
  \expandafter\chapter{\csname prechap\roman{chapter}\endcsname}}

\newcommand*{\betonung}[1]{\textsc{#1}}

\newenvironment*{sqlblock}{}{}
\newcommand*{\sql}[1]{#1}
\newcommand*{\sqlattr}[1]{#1}
\newcommand*{\sqlrel}[1]{\uppercase{#1}}
\newcommand*{\sqlschl}[1]{#1}
\newcommand*{\sqlreldef}[3]{\sqlrel{#1}(\sqlschl{#2}, \sqlattr{#3})}

\newenvironment*{procontra}{\begin{itemize}}{\end{itemize}}
% \newcommand*{\pro}{\item[$+$]}
% \newcommand*{\semipro}{\item[($+$)]}
% \newcommand*{\contra}{\item[$-$]}
% \newcommand*{\semicontra}{\item[($-$)]}
% \newcommand*{\pro}{\item[\leftthumbsup]}         % aus dingbat
% \newcommand*{\contra}{\item[\leftthumbsdown]}    % aus dingbat
% \newcommand*{\pro}{\item[\smiley]}               % aus wasysym
% \newcommand*{\contra}{\item[\frownie]}           % aus wasysym
\newcommand*{\pro}{\item[\Sun]}                  % aus [weather]ifsym
\newcommand*{\semipro}{\item[\SunCloud]}         % aus [weather]ifsym
\newcommand*{\contra}{\item[\RainCloud]}         % aus [weather]ifsym
\newcommand*{\semicontra}{\item[\Cloud]}         % aus [weather]ifsym

\makeindex

\SVN $LastChangedRevision$
\SVN $LastChangedDate$

\begin{document}

\title{Verteilte Datenbanksystemen und Client"~/""Server"=Systeme}
\author{Prof.\,Dr.\,Klaus Küspert}
\date{Semester: SS 200X, WS 200X/0Y}
\maketitle

\clearpage
\section*{Nutzungsbedingungen und Danksagungen}

{\itshape
  Dieses Dokument wurde als Skript für die auf der
  Titelseite genannte Vorlesung erstellt und wird jetzt im Rahmen des
  Projekts
  "`\href{http://uni-skripte.lug-jena.de/}
  {Vorlesungsskripte der Fakultät für Mathematik}
  \href{http://uni-skripte.lug-jena.de/}{und Informatik}"'
  weiter betreut. Das
  Dokument wurde nach bestem Wissen und Gewissen angefertigt. Dennoch
  garantiert weder der auf der Titelseite genannte Dozent, die Personen,
  die an dem Dokument mitgewirkt haben, noch die
  Mitglieder des Projekts für dessen Fehlerfreiheit. Für etwaige Fehler
  und dessen Folgen wird von keiner der genannten Personen eine Haftung
  übernommen. Es steht jeder Person frei, dieses Dokument zu lesen, zu
  verändern oder auf anderen Medien verfügbar zu machen, solange ein
  Verweis auf die Internetadresse des Projekts
  \url{http://uni-skripte.lug-jena.de/}
  enthalten ist.

  Diese Ausgabe trägt die Versionsnummer~\SVNLastChangedRevision{} und ist vom
  \SVNDate{}. Eine neue Ausgabe könnte auf der Webseite des Projekts verfügbar
  sein.

  Jeder ist dazu aufgerufen, Verbesserungen, Erweiterungen und
  Fehlerkorrekturen für das Skript einzureichen bzw. zu melden oder diese
  selbst einzupflegen -- einfach eine E-Mail an die
  \href{mailto:uni-skripte@lug-jena.de}{Mailingliste
  \nolinkurl{<uni-skripte@lug-jena.de>}} senden. Weitere Informationen
  sind unter der oben genannten Internetadresse verfügbar.

  Hiermit möchten wir allen Personen, die an diesem Skript mitgewirkt
  haben, vielmals danken:
  \begin{itemize}
   \item \href{mailto:joerg@alea.gnuu.de}{Jörg Sommer
    \nolinkurl{<joerg@alea.gnuu.de>}} (2007)
  \end{itemize}
}

\clearpage
\pdfbookmark[0]{Inhaltsverzeichnis}{inhaltsverzeichnis}
\tableofcontents

\addchap{Geplante Vorlesungsgliederung/\texorpdfstring{"""~}{-}struktur}

\predefchap{Einführung/""Motivation/""Historie}

Wann und aus welchen Überlegungen heraus/""mit welcher Zielsetzung entstanden
verteilte Datenbanksystemen und Client"~/""Server"=Systeme? Welche "`Formen"'
gibt es grob hinsichtlisch solcher Systeme und wie sind diese zu
charakterisieren/""abzugrenzen? $\rightarrow$ Begriffe, Pros und Cons

\predefchap{Datenspeicherung, \texorpdfstring{"~}{-}verteilung,
  \texorpdfstring{"~}{-}partitionierung (für globale
  Relationen in verteilten Datenbanksystemen)}

\emph{Partitionierungs}begriff und \emph{Allokations}begriff,
Partitionierungsformen (\emph{Wie} kann man Daten \emph{partitionieren} und
Betrachtung einer Relation bzw. "`darüber hinaus"'? Welche
\emph{Anforderungen} müssen Partitionierungen erfüllen? Wie bestimmt man
geeignete Partionierungen?) \ldots{} Quantifizierungsbestrebungen!

\predefchap{Schema"=Architekturen verteilter Datenbanksysteme}

\begin{itemize}
 \item Ausgehend von bekannter ANSI/""SPARC"=Architektur (3~Ebenen)
  $\rightarrow$ wie sehen Architekturen verteilter Datenbanksystemen aus?

 \item Unterscheidung u.\,a. zwischen \emph{lokalen} Schemata und
  \emph{globalen} Schemata auf konzeptueller Ebene, Partitionierungseben,
  Allokationsebene $\rightarrow$ Vielfalt von Möglichkeiten (Orthogonalität?)
  deutet sich an

 \item Darstelllung, Klassifikation, Bewertung
\end{itemize}

\predefchap{Anfragebearbeitung in verteilten Datenbanksystemen}

\begin{itemize}
 \item \emph{Basis:} Wissen zu
  Relationenalgebra/""Äquivalenzumformungen/""Query Optimization aus DBS~1
  (insb.)

 \item What's new?
  \begin{itemize}
   \item Globale Anfragen $\rightarrow$ lokale Anfragen wegen Verteilung
    (Zerlegung)
   \item \emph{Übertragungs}kosten/-dauer als zusätzlicher Faktor
   \item Join-Thematik bei verteilten Datenbanksystemen
   \item \emph{Partitionierung}/""\emph{Allokation} $\rightarrow$ (noch) mehr
    "`Stellschrauben"' bzw. \emph{vergrößerter Parameterraum} für den Query
    Optimizer!
  \end{itemize}
\end{itemize}

\predefchap{Transaktionen in verteilten Datenbanksystemen}

\begin{itemize}
 \item \emph{Basis:} Bekannte Transaktionseigenschaften (\ac{ACID}),  Schedule,
  Serialisierbarkeit, \ldots{}

 \item What's new?
  \begin{itemize}
   \item \emph{Globale} Transaktionen $\rightarrow$ (lokale)
    \emph{Teil}transaktionen
   \item Sicherstellen von \ac{ACID} auch bei verteilter Transaktionsausfführung
    $\rightarrow$ \emph{Zwei"=Phasen"=Commit"=Protokoll} (two"~phase commit,
    2PC): Abläufe und Realisierung"~/""Optimierungsfragen
  \end{itemize}
\end{itemize}

\predefchap{Synchronisation in verteilten Datenbanksystemen}

\begin{itemize}
 \item \emph{Basis:} Synchronisation"~/""Sperrthematik aus DBS~1,
  Zwei"=Phasen"=Sperrprotokoll (two"~phase locking, 2PL), \ac{OCC},
  Deadlock"=Thematik

 \item What's new?
  \begin{itemize}
   \item \emph{Verteilungs}implikationen globale Sperrtabelle versus lokale
    (dezentrale) Sperrtabellen

   \item \emph{Deadlock}"=Erkennung und "~Auflösung in Anbetracht von
    Verteilung und globalen Anfragen (\foreignlanguage{english}{Distributed
    Deadlock Detection})
  \end{itemize}
\end{itemize}

\predefchap{Replikationsverfahren}

\begin{itemize}
 \item \emph{Basis:} ?? "`\foreignlanguage{english}{Replication considered
  harmful}"'? $\rightarrow$ im nicht verteilten (zentralistischen) Fall

  Replikation = bewußt, überlegt herbeigeführte Datenredundanz

 \item Replikations\emph{verfahen} und u.\,a. Performance- und
  Verfügbarkeitsaspekte hiervon
\end{itemize}

\ldots{}

\addchap{Inhaltliche Bezüge zu Forschungsthemen am Lehrstuhl}

\begin{itemize}
 \item \emph{Partitionierung} von Daten (bei \emph{zentralisierten}
  Datenbanksystemen)! SAP"~Projekte J.\,Nowitzky 1997--2001/02 Partitionierung
  zur Unterstützung der Datanarchivierung sowie der Performance"=Steigerung
  (u.\,a.) in Data Warehouses (Partitionierungsausschluss, Nutzung von
  Parallelität) $\rightarrow$ Partitionierunsgedanke ist von verteilten
  Datenbanksystemen in zentralisierte "`zurückgewandert"'!

 \item \emph{Replikation} von Daten (bei \emph{mobilen} Datenbanksystemen)
  Forschungsthema Ch.~Gollmick 2000--\ldots{} \emph{Mobile Datenbanken
  enthalten fast ausschließlich nur replizierte Daten!!} Größere
  Variabilität/""Dynamik als bei verteilten Datenbanksystemen durch
  Lokationsabhängigkeit u.\,a.
\end{itemize}

\begin{thebibliography}{9}
 \bibitem{dadam} Dadam, Peter: "`Verteilte Datenbanken und
  Client/""Server"=Systeme -- Grundlagen, Konzepte und Realisierungen"',
  Springer Berlin, Heidelberg, 1996

 \bibitem{ceri} Ceri, Pelagatti, 1984

 \bibitem{lang} Lang, Lockemann, 1995
\end{thebibliography}

\nextchapter

\begin{itemize}
 \item Forschung zu \emph{verteilten Datenbanksystemen} begann bereits
  \emph{ab Mitte der 70er Jahre} $\rightarrow$ nur knapp zeitversetzt also zur
  Forschung an relationaler Datenbanktechnologie überhaupt (Codd~1970)!
  \ldots{} 5~Jahre ca.

 \item Berühmte \emph{frühe Projekte} und Prototypen/""Systeme:
  \begin{itemize}
   \item \emph{System~R*} (verteiltes System~R, IBM San Jose)
   \item \emph{Distributed Ingres} (Stonebraker, UC Berkeley)
   \item VDN ("`Verteilte Datenbanken Nixdorf"') gemeinsam mit TU~Berlin
    (R.\,Munz) $\rightarrow$ \ldots{} $\rightarrow$ Adabas~D (Software~AG)
    bzw. SAP~DB heute Open Source \url{http://www.sapdb.org}
   \item PORTEL (Uni Stuttgart)
  \end{itemize}
  \ldots{}

  $\Rightarrow$ haben Eingang in heutige DBMS"=Produkte gefunden!!

 \item \emph{Auslösende Momente für die Forschung} (zu jener Zeit):
  \todo{Bild: Pfeile nach links und rechts, links: Trend zur Dezentralisierung
    (I), über den Pfeil "`primär"' schreiben und Pfeil kräftiger, rechts:
    Trend zu Integration (II)}

  \begin{enumerate}[I.]
   \item Dezentralisierung
    \begin{itemize}
     \item \emph{Betriebswirtschaftliche} Dezentralisierung (Teileinheiten,
      Regionalzentren, Geschäftsstellen, \ldots{}) verbunden mit
      IT"~Dezentralisierung und Verarbeitungskapazität "`vor Ort"'.

     \item 70er/80er Jahre: Großrechner (auch) vor Ort; Bsp.: \emph{Großbanken
      mit Regionalstruktur}

     \item "`Ist für die Dresdner Bank \betonung{die} zentrale relationale
      Datenbank in Frankfurt die bessere Lösung oder eine Verteilung über die
      Standorte Hamburg/""Düsseldorf/""Frankfurt/\ldots{}??"'

      (Natürlich) nicht trivial beantwortbar, sondern $f(\dotso)$:
      \begin{itemize}
       \item \emph{Workload"=Charakteristika} lokale versus globale Anteile
        \begin{gather*}
          \xleftarrow{\displaystyle\text{rein global}\hspace{2cm}} \text{???}
             \xrightarrow{\hspace{2cm}\displaystyle\text{rein lokal}}
        \end{gather*}

        In der Extrempositionen würde man keine verteilte Datenbank einsetzen,
        aber dazwischen vielleicht?

       \item \emph{Leistungscharakteristika} des eingesetzten bzw,
        vorgesehenen verteilten Datenbanksystems: Wie gut kommt es mit
        verteilten Anfragen klar? (Optimizer!), Wie gut mit verteilenten
        Datenbankänderungen (Tranksaktionsverwaltung) etc.?

       \item \emph{Administrationsaspekte}: Mit Administration im verteilten
        Fall verbundene Mehraufwendungen?

       \item \emph{Verfügbarkeitsfragen} (Availability)
      \end{itemize}

      \ldots{} neue Möglichkeiten, neue Fragestellungen
    \end{itemize}

   \item Integration
    \begin{itemize}
     \item Einerseits als "`Gegenbewegung"' zur Dezentralisierung, Ausschlagen
      des Pendels in andere Richtung (Industrietrends)

     \item Aber auch unabhängig davon zu sehen: Durch Forderung von
      \emph{integrierter Auswertbarkeit} (dezentral, unabhängig entstandene
      Datenbestände)

      Durch \emph{Firmenzusammenschlüsse/"""~kooperationen} (mit Einfluss auf
      IT, etwa Hypo- und Vereinsbank), Daimler und Chrysler, \ldots{}

      $\rightarrow$ \emph{bottom"~up}"~Herangehensweise im Gegensatz zu
      \emph{top"~down} bei Dezentralisierung
    \end{itemize}
  \end{enumerate}
\end{itemize}

\section{Problemstellungen bei Dezentralisierung}

Vom zentralen Datenhaltungsansatz zum verteilten.

Forderungen/""Ziele:
\begin{itemize}
 \item (Weiterhin) \emph{Singel"=System"=Imag} (Verteilungstransparenz):
  Existierende Anwendungen sollen von der erfolgten Dezentralisierung
  möglichst nichts merken (Aspekt der Datenunabhängigkeit, der
  \help{Soll das hier auch eine Datenmodellunabhängigkeit sein, so wie im
    nächsten Abschnitt}
  Ortsunabhängigkeit der Anwendungsprogramme als zusätzliche Forderung).

  1~Rechnerknoten $\rightarrow$ $n$~Rechnerknoten: Anwendungen auf beliebigen
  Rechnerknoten laufend sollen auf Daten(teil)bestände auf beliebigen
  Rechnerknoten transparent zugreifen können inklusive (natürlich)
  Gewährleistung von Transaktionseigenschaften (\ac{ACID}) $\rightarrow$
  Idealvorstellung

 \item \emph{Performance}"=Steigerung und ggf. auch Steigerung der
  \emph{Verfügbarkeit} (Availability). Wodurch??
  \begin{itemize}
   \item Hoher Anteil von \emph{lokalen} Anfragen hilfreich für Performance
   \item \emph{Replikation} von Daten hilfreich/""nötig für Verfügbarkeit
    (sonst eher gegenläufige Verfügbarkeitsveränderung zu erwarten \ldots{})

    Vorteile beim Lesen, Nachteile beim Ändern
  \end{itemize}
\end{itemize}

\section{Problemstellungen bei Integration}

Von autonomen Datenhaltungslösungen (Einzelsysteme, "`Insellösungen"') zur --
zumindest logisch -- integrierten Lösung.

Forderungen/""Ziele/""Probleme:
\begin{itemize}
 \item Problemumfang stark abhängig von initial vorliegender Heterogenität
  (der Ausgangslösungen):
  \begin{itemize}
   \item verschiedene Datenmodelle (relational, hierarchisch, netzwerk,
    Dateien, \ldots{})
   \item gleiches Datenmodell (etwas relational), aber verschiedene
    DBMS"=Versteller (Produkte)
   \item gleiches Datenmodell und gleiche Produkte, aber verschiedene Schemata
    strukturell/""semantisch
  \end{itemize}

 \item \emph{Singel"=System"=Image} für neuentwickelte, auf der integrierten
  Datenhaltungslösung beruhende Anwendungen: Orts- und
  Datenmodellunabhängigkeit idealerweise (z.\,B. einheitlich relationale
  Siche auf "`alles und über alles"')

 \item (Weiterhin) Ablauffähigkeit für existierende (Alt"~)""Anwendungen auf
  jeweils lokaler Datenhaltung (über bisherige Schnittstellen) $\rightarrow$
  Beibehaltung der \emph{Autonomie} und \emph{Performance} idealerweise

  nichttrivial!!
\end{itemize}

\section{Formen und Charakteristika verteilter Informationssysteme}
\label{sec:formen-der-verteilung}

\subsection{Räumliche Aspekte der Verteilung}

\subsubsection{geographisch verteiltes Informationssystem}

(klassisch auslösende Vorstellung bei verteilten Datenbanksystemen). Realität?

\begin{itemize}
 \item \emph{Große Distanz} zwischen den Rechnerknoten
 \item wide area networt
 \item \emph{Relativ teure, \textnormal{störanfällige} Verbindungen} ggf.
  Verfügbarkeitsprobleme möglich $\rightarrow$ \emph{Kommunikationskosten}
  spielen wesentliche Rolle

 \item Hilfreich hier: \emph{Möglichst viel lokale Autonomie der Teilsysteme}
  mit entsprechenden Workload"=Charakteristika

 \item Beispiel: Verteilte Datenhaltung weltweit über
  Produktionsstätten/""Geschäftsstellen eines Unternehmens hinweg
  (Nebenbemerkung: \emph{Orthogonal} zur Erörterung Integration vs.
  Dezentralisierung \help{das fehlt auf meiner Kopie})
\end{itemize}

\subsubsection{lokal verteiltes Informationssystem}

(nicht der Klassiker unbedingt, aber heute oft bedeutender/""eher anzutreffen
als geographisch verteilt)

\begin{itemize}
 \item \emph{geringe Distanz} zwischen den Rechnerknoten
 \item local area network
 \item \emph{Relativ schnelle, \textnormal{wenig störanfellige} Verbindung},
  hohe Verfügbarkeit

 \item Beispiel\cite{dadam}: \todo{Bild}

 \item Kommunikation(skosten) auch hier natürlich ein Thema, aber weitaus
  geringere Bedeutung als bei geographisch verteilten Systemen $\rightarrow$
  Autonomie der Teilsysteme deshalb nicht so wesentlicher Faktor

 \item Gründe für lokal verteilte Lösungen:
  \begin{itemize}
   \item historisch gewachsen, nachfolgende Integration
   \item Performance"=Verteile (vielleicht \ldots{})!
   \item Skalierbarkeitsvorteile (wenn im obigen Beispiel Anwendung $n+1$
    hinzukommt)!
   \item Verfügbarkeitsvorteile (bei Replikation)!
  \end{itemize}
\end{itemize}

\subsection{Realisierungsebenen verteilter Informationssysteme}

"`wo ist die Verteilung implementiert?"'
\todo{Bild: Dreiteilung vDBMS, Anwendungen, Middleware}

\subsubsection{verteiltes DBMS}
Transparenz
\todo{Bild}

\subsubsection{Realisierung der Verteilung in den Anwendungen}
\todo{Bild}

\subsubsection{Realisierung der Verteilung in Middleware (Zusatzschicht)}

Transparenz \todo{Bild}

Bewertung:
\begin{itemize}
 \item vDBMS: "`reine Lehre"'
 \item in Anwendung: problematisch
 \item Middleware: \help{das fehlt auf meiner Kopie}
\end{itemize}

\subsection{Realisierungsformen verteilter DBMS}

und ihre Abgrenzung/""Einordnung (umfasst auch solche Fälle, die nicht im
"`engeren Sinne"' zu verteilten DBS zählen)

M.\,a.\,W.: Welche (wichtigen) Möglichkeiten gibt es, mehr als einen Rechner
(mehr als einen Prozess) zur DBMS"=Verarbeitung einzusetzen?
\begin{enumerate}
 \item Shared everything: gemeinsamer Hauptspeicher, gemeinsame Platten
 \item Shared disk: nur gemeinsame Platten
 \item Shared nothing: nicht gemeinsam
\end{enumerate}

$\rightarrow$ Klassifikation nach Grad der gemeinsamen Nutzung von Resourcen
\ldots{} Grad der Kopplung (eng \ldots{} lose)

\subsubsection{Shared-Everything-Architektur}

\todo{Bild}

\begin{itemize}
 \item Unterstützt von übelichen DBMS à la Oracle, DB2, \ldots{}
 \item Größte Nähe zum klassischen Ein"~Rechner-Ein"~Prozessor"=Szenarium
 \item \emph{Skalierbarkeit} über Zahl der Prozessoren
 \item Probleme/""Grenzen:
  \begin{itemize}
   \item Konflikte/""Engpässe bei zunehmender Zahl parallel (auf gleichen
    Hauptspeicher) zugreifender Prozessoren!
   \item Cache"=Koheränzprobleme!
   \item \emph{wenig} Nutzen bzgl. Verfügbarkeit (Availability)!
  \end{itemize}
\end{itemize}

\subsubsection{Shared"=Disk"=Architektur}

\todo{Bild}
\begin{itemize}
 \item \emph{Komplette Rechner} wirken zusammen bei der DB"~Verteilung
 \item Jeder einzelne Rechner darf mehrere CPUs (à la Fall a) oben) aufweisen
  $\rightarrow$ Skaliebarkeit nun auf zwei Ebenen (Ausbau einzelner Rechner
  und Ausbau des Rechner"=Clusters)!
 \item großer Vorteil: von allen Rechnern alle Daten prinzipell erreichbar
 \item Argumente für Einsatz:
  \begin{itemize}
   \item Skalierbarkeit
   \item Hohe benötigte Gesamtverarbeitungsleistung
   \item Verfügbarkeit (Availability)
  \end{itemize}
\end{itemize}

\paragraph{Zur Verfügbarkeitsthematik:}
\begin{itemize}
 \item Hauptgrund für Einsatz von Shared"=Disk"=Architektur in der Praxis
  (sagt (nicht nur) SAP)
 \item Recher-Cluster kann -- mit reduzierter Performance -- weiterbetrieben
  werden auch bei Vorhandensein von nur noch $n-1$, $n-2$, \ldots{} Rechnern
  \begin{itemize}
   \item "`Absturz"' einzelner Rechner
   \item Wartung einzelner Rechner
   \item auch ggf. Hinzufügen weiterer Rechner zum Cluster im laufenden
    Betrieb! $\rightarrow$ $n+1$, $n+2$, \ldots{}
  \end{itemize}

 \item zu lösenden Probleme in dem Zusammenhang:
  \begin{itemize}
   \item Bei Absturz Betroffensein auf diesem Rechner laufender Transaktionen
    (\emph{A}CI\emph{D}) $\rightarrow$ Wiederholung dieser (nur dieser)
    Transaktion auf $n-1$ übriggebliebenen Rechnern
   \item Lastverteilung (Load Balancing) anzupassen an veränderte
    Konfiguration ($n-1$)
  \end{itemize}
\end{itemize}

\paragraph{Zur Produktwelt}
(Mindestens) zwei sehr bekannte Produktlösungen für Shared"=Disk"=Architektur:
Oracle Parallel Server (OPS) -- heißt heute Oracle Real Application Cluster
(RAC) -- und IBM DB2 für Parallel Sysplex Mainframe!

\subparagraph{Eigenschaften der Oracle-Lösung}
\begin{itemize}
 \item Shared"=Disk"=Ansatz orthogonal zu Betriebssystemplattform (Unix,
  Mainframe, \ldots{})
 \item Oracle im Highend"=Bereich (Mainframe) wenig verbreitet
\end{itemize}

\subparagraph{Eigenschaften der DB2"~Lösung}
\begin{itemize}
 \item Mainframe-DB2 (z/OS, OS/390) only
 \item Hardware"~/""Betriebssystemunterstützung für Kommunikation ($n+1$.
  Rechner nur dafür)
\end{itemize}

\paragraph{Allgemein zu lösende Probleme beim Shared"=Disk"=Ansatz} (nur
Problem, hier keine Lösungen)

Oder: Warum nicht einfach "`normales"' DBMS verwendbar in
Shared"=Disk"=Architektur?

\begin{itemize}
 \item Load balancing $\rightarrow$ Lastverteilung über $n$~Rechner
  (Datenbanklast),

  Affinity"=Based"=Routing (separate Systempuffer, Erzeilung von
  Lokalitätsverhalten, Kenntnis von Transaktionstyp, aber: einzelne Rechner
  trotzdem nicht zum Engpass werden lassen)

 \item \emph{Konsistenzhaltung} Datenbanksystempuffer bei Datenänderungen
  (DB"~Seite~$i$ kann sich gleichzeitig in mehreren Systempuffern befinden),
  Verwaltungsproblem $\rightarrow$ buffer coherancy
 \item \emph{Sperrproblematik} bei (jetzt) Vorhandensein mehrerer
  Sperrtabellen $\rightarrow$ rechnerübergreifende Deadlocks \ldots{}
 \item Logging/""Recovery \ldots{}
\end{itemize}

Beforscht seit 20~Jahren, Produkte auch fast so lang.

\paragraph{Probleme/""Entsprechungen hiervon auch "`oberhalb"' des DBMS}

Worum's geht? Anwendungebene hat u.\,U. vergleichbare Probleme zu lösen wie
oben. Betrachte SAP System R/3 (mySAP.com) -- 3"~tier architecture:
\begin{itemize}
 \item Präsentationsebene (Presentation Server)
 \item Anwendungsebene (Application Server)
 \item Datenbankebene (Database Server)
\end{itemize}
$\rightarrow$ Database Server kann Shared"=Disk"=Ansatz nutzen (z.\,B. DB2
Parallel Sysplex)
\begin{itemize}[$\rightarrow$]
 \item Skalierbarkeit, Performance, Verfügbarkeit
 \item transparent aus Anwendungssicht
\end{itemize}

Problem: Gleiche Argumentation (Skalierbarkeit, Performance, Verfügbarkeit)
auch auf Anwendungsebene $\rightarrow$ $n$ Application Server teilen sich
Arbeit, puffern Daten, benötigen Load Balancing und Affinität, haben
Konsistenzerhaltungsproblem. -- Berühmtes Beispiel, dass DB"~Probleme und
"~Lösungen auch auf höherer Ebene wieder auftauchen.

\subsubsection{Shared"=Nothing"=Architektur}
\todo{Bild}

\begin{itemize}
 \item "`Richtiges"' vDBMS (wärend a) und b) nicht in jene Schublade gehören,
  sondern eigene Schublade bilden (insb. b))

 \item Hochgeschwindigkeitskommunikation bei lokaler Verteilung (LAN"~basierte
  Kommunikation bspw.) $\rightarrow$ Ansatz gewähle für
  Hochleistungstransaktionsverarbeitung und/oder Verfügbarkeit

 \item Architekturell kein Unterschied zu geographischer
  Verteilung/\glq{}langsamer\grq{} Kommunikation
\end{itemize}

\paragraph{Föderierte, verteilte Datenbanksysteme}
\begin{itemize}
 \item Ansatz vor allem gebräuchlich bei \emph{nachträglicher} Integration
  bereits \emph{existierender}, bislang dezentral organisierter
  Informationssysteme
 \item inwiefern Föderation? \emph{Abgabe einiger}, aber \emph{nicht aller}
  Zuständigkeiten/""Kompetenzen an eine übergeordnete Instanz
 \item So auch beim föderierten, verteilten Ansatz: Existierende
  Informationssystem bringen nicht alle ihre (bisherigen, lokalen) Daten in
  globales Verbund ein, sondern nur jene, an denen ein globales Interesse
  besteht/""wo man sich bzgl. des Einbringens verständigt hat $\rightarrow$
  \emph{lokale} Daten (wie zuvor) und -- neu -- \emph{globale} Daten (die
  \emph{lokal} gespeichert, aber \emph{global} verfügbar sind)

 \item \emph{(Teil"~)""Autonomie der dezentralenen Systeme}, ihre lokalen
  Daten betreffend und -- nur eingeschränkt -- die globalen
\end{itemize}

\paragraph{Schemaintegration bei föderierten, verteilten Datenbanksystemen}
\todo{Bild}

Beobachtungen/""Bemerkungen:
\begin{itemize}
 \item Bei Festlegung des globalen Schemas wird entschieden, welche Teile der
  lokalen Schemata \emph{global sichtbar} sein sollen $\rightarrow$ siehe im
  obigen Beispiel etwas $\text{Teile}_{1}$ (aus $\text{L"~DB}_{1}$) komplett,
  $\text{Pers}_{2}$ (aus $\text{L"~DB}_{2}$) teilweise, Lief (aus
  $\text{L"~DB}_{3}$) gar nicht (d.\,h. Lief bleibt rein in lokaler
  Zuständigkeit, kein Einbringen in globalen Verbund)

 \item Lokale Ausführungsautonomie wird somit nur teilweie aufgegeben
  $\rightarrow$ Föderationsgedanke
 \item Vertiefung: Stefan Conrad, Föderierte Datenbanksysteme: Konzepte der
  Datenintegration. Springer"=Verlag, Berlin, 1997
\end{itemize}

\paragraph{Probleme beim föderierten Ansatz u.\,a. (bereits kurz angesprochen)}
\begin{itemize}
 \item Umfang der Abgabe lokaler Autonomie; betrifft nicht nur à la Bsp. oben
  Datenumfang (Tabelle komplett, teilweise oder gar nicht), sinder natürlich
  auch Rechte: Darf globales Ebene nur lesen oder gar viel mehr (Schema
  ändern?)?

 \item Probleme bei inhomogenen lokalen Schemata; Dateien, hierarchisch,
  Netzwerk, relation
 \item Anfrageoptionierung bei globalen Queries
 \item Globale Transaktionen \ldots{}
 \item Aber: Praktisch \emph{hochrelevantes} und interessantes Thema; erste
  Produktlösungen à la \emph{IBM Data Joiner}, verschieden
  \emph{Gateway-Lösungen} (die nicht in Reinkultur Föderationsgedanken
  umsetzen), \ldots{}
\end{itemize}

\nextchapter

Inhaltsübersicht:
\begin{itemize}
 \item Formen verteiler Speicherung
 \item Zerlegungsmöglichkeiten (globaler Relationen) und physische
  Speicherung: Partitionierung und Allokation
 \item Partitionierungsformen
 \item Bestimmung geeigneter Partitionen
 \item Physische Verteilung der Daten (Allokation)
\end{itemize}

\section{Vorbemerkungen}

Ziele:
\begin{itemize}
 \item \emph{Datenverteilung} auf logischer Ebene (Partitionierung) und auf
  physischer Ebene (Allokation)
 \item ggf. unter Einführung von kontrollierter (!) Redundanz (Datenreplikation)
 \item möglichst \betonung{transparent} realisiert aus Benutzerperspektive
\end{itemize}
(Gründe für jenen "`Aufstand"' wie bereits angesprochen:
Erhoffte/""angestrebte Performance"=Vorteile, Verfügbarkeitsvorteile, evtl.
Autonomievorteile; Erfordernisse nachträglicher Integration (Verteilung
existiert \ldots{}))

\subsection{Formen verteilter Speicherung (bereits angesprochen)}

\begin{itemize}
 \item Aufteilung an sich zusammengehöriger Daten und Speicherung dort, wo am
  häufigsten benötigt (Partitionierung globaler Relationen) $\rightarrow$
  \emph{Homogenität}

 \item \emph{Heterogenität}: Unterschiedliche Repräsentation von Daten
  derselben Art an verschiedenen Knoten:
  \begin{itemize}
   \item strukturelle Heterogenität: gleiche Bedeutung, aber verschieden
    strukturiert
   \item semantische Heterogenität: gleiche Bezeichnung, aber
    unterschiedlicher Bedeutungsinhalt
  \end{itemize}
  (semantische Heterogenität ist der schlimmere, hinterhältigere Fall (schwer
  zu erkennen und i.\,d.\,R. auch schwerer per Automatismus zu
  beseitigen/""durch Abbildung zu berücksichtigen))

 \item \emph{Redundanz}: Replikation zwecks Performance oder Verfügbarkeit
\end{itemize}

\section{Partitionierung und Allokation}
\begin{description}
 \item[Partitionierung:] (Prädikative) Beschreibung der Verteilung von Daten
  auf logischer Ebene (Tabellenebene) $\rightarrow$ 1.~Verteilungsschritt

 \item[Allokation:] Festlegung des Speicherorts für die Partitionen auf
  physischer Ebene (Knoten, Table Spaces, \ldots{}) $\rightarrow$
  2.~Verteilungsschritt
\end{description}

\subsection{Fälle und Zusammenspiel von Partitionierung und Allokation}
\todo{Bild}

\subsubsection{Bemerkungen/""Beobachtungen}
\begin{itemize}
 \item Relation~$R1$ wurde horizontal partitioniert
 \item Partitionierung erfolgte vollständig (nichts wurde "`vergessen"', blieb
  übrig)
 \item Partitionierung erfolgte in disjunkte Teile, d.\,h. Partitionen
  überlappen nicht (Konsequenz aus Vollständigkeit und Disjunktheit: Jedes
  Tupel von $R1$ ist genau einer Partition zugeordnet)

  Bei nichtdisjunkten Teilen -- überlappenden Partitionierungsprädikaten --
  läge "`versteckte Redundanz"' vor (N.\,B.: Einige Produkte (Informix)
  erlauben überlappende Partitionierungsprädikate, andere (Oracle) tun's nicht.)
 \item Es wurden fünf Partitionen drei Knoten physisch zugeordnet (im
  2.~Schritt). Partition $P_{12}$ und $P_{13}$ wurden dabei jeweils mehrfach
  gespeichert, an verschiedene Knoten $\rightarrow$ Redundante Allokation
\end{itemize}

\subsubsection{Einschub} vgl. auch Vorlesung Archivierung in Datenbanksystemen
\label{sec:vorl-arch}

Partitionierung ggf. auch sinnvoll bei Vorhandensein nur \betonung{eines}
Knotens! (auch das erlauben DB2, Oracle, Informix, \ldots{})!

Warum/""Wie?
\begin{itemize}
 \item \emph{Table Space} übernimmt "`Rolle des Knotens"', d.\,h. Allokation
  der Partition zu (verschiedenen) Table Spaces auf u.\,U. verschiedenen
  Externspeichern (in Wahrheit wird ohnehin erst Table Space zugeordnet, auch
  in obiger Abbildung, nicht nur einfach direkt Knoten)
\end{itemize}

Nutzen?
\begin{itemize}
 \item \emph{Parallele Suche} auf verschiedenen Partitionen/""Table Spaces
  (Parallel Query Option) \emph{kann} Performance-Vorteil bieten
 \item Ausblenden von Partitionen/""Einschränken der Suche auf bestimmte
  Partitionen, \emph{kann} Performance-Vorteil bieten
 \item \sql{DROP PARTITION} i.\,d.\,R. \emph{viel} schneller als \sql{DELETE},
  \sql{DELETE}, \ldots{}
 \item Administrationsvorteile
\end{itemize}

\hfill \dotfill{} Ende des Einschubs \dotfill{} \hfill

\begin{itemize}
 \item Begriff Fragment wird teils anstelle von Partition verwendet/""synonym
  $\rightarrow$ Informix bspw. (fragment, fragmentation) $\rightarrow$ hier in
  Vorlesung eher vermieden
 \item Wir nehmen disjunkte Partitionierung an, schließen als "`versteckte
  Redundanz"' aus!
\end{itemize}

\subsection{Horizantale Partitionierung}
\label{sec:hori-part}

\begin{itemize}
 \item Aufteilung einer globalen Relation~$R$ in Teilrelationen
  $R_{1},R_{2},\dotsc, R_{p}$ (mit gleichen Relationsschema), so dass gilt:
  \begin{gather*}
    R = \bigcup_{1,\dotsc,p} R_{i}
  \end{gather*}
  (Vollständigkeit steckt somit in der Definition bereits drin, Disjunktheit
  wäre zusätzlich zu spezifizieren $\forall 1\leq i,j\leq p \wedge i\ne
  j\colon R_{i}\cap R_{j}=\emptyset$)

 \item Es werden stets ganze Tupel verteilt
 \item Hinweis (DBMS"=Implementierungsperspektive): Teilrelationen aus
  Benutzersicht transparent (idealerweise), aus Systemsicht kann eine
  Teilrelation (intern) wie eine "`normale"' Relation gehandhabt werden
  (vereinfacht Implementierung des Partitionierungskonzepts, keine
  Sonderbehandlung von Teilrelationen bzw. Sonderbehandlung hält sich in
  Grenzen).

  Bsp.: Statistiken fpr Teilrelationen wie für Relationen (einfache,
  genaue(re) Query Optimization), Sperrgranula Teilrelation etc.
\end{itemize}

\subsubsection{Partitionierungsbeispiele}

Schema:
\begin{sqlblock}
  \sqlreldef{ANGEST}{PersNr}{AngName, Gehalt, AbtNr, Anschrift}\\
  \sqlreldef{ABT}{AbtNr}{AbtName, Bereich, MgrPersNr, Budget}\\
  \sqlreldef{Teile}{TeileNr}{TeileBez, LiefNr, Preis}\\
  \sqlreldef{Lagerort}{TeileNr}{LagerNr}\\
  \sqlreldef{Lieferant}{LiefNr}{LiefName, Stadt}
\end{sqlblock}

\begin{enumerate}
 \item Intervall"~/""Bereichspartitionierung nach Primärschlüssel
  \begin{sqlblock}
    \sqlrel{Teile}$_{1}$ = SL$_{0\leq\sqlattr{TeileNr}<300}$ \sqlrel{Teile}\\
    \sqlrel{Teile}$_{2}$ = SL$_{300\leq\sqlattr{TeileNr}<500}$ \sqlrel{Teile}\\
    \sqlrel{Teile}$_{3}$ = SL$_{500\leq\sqlattr{TeileNr}<\infty}$ \sqlrel{Teile}
  \end{sqlblock}
  Vollständigkeit und Disjunktheit gegeben?

 \item (Bereichs"~)""Partitionierung nach beliebigen Attribut
  \begin{sqlblock}
    \sqlrel{Lieferant}$_{1}$ = SL$_{\sqlattr{Stadt}='\text{Hamburg}'}$ \sqlrel{Lieferant}\\
    \sqlrel{Lieferant}$_{2}$ = SL$_{\sqlattr{Stadt}='\text{Jena}'}$ \sqlrel{Lieferant}\\
    \sqlrel{Lieferant}$_{3}$ = SL$_{\sqlattr{Stadt}\ne'\text{Hamburg}'\wedge
      \sqlattr{Stadt}\ne'\text{Jena}'}$ \sqlrel{Lieferant}
  \end{sqlblock}
  Disjunktheit und Vollständigkeit? $\rightarrow$ \sqlrel{Lieferant}$_{3}$
  übernimmt hier Rolle der Restpartition
\end{enumerate}

\subsubsection{Bemerkungen/""Verallgemeinerungen dazu:}
\begin{itemize}
 \item Bereichspartitionierung wichtiger (Spezial"~)""Fall der
  Partitionierungsdefinition $\rightarrow$ in diesem Abschnitt ausschließlich
  betrachtet

 \item Gibt's noch einfachere Möglichkeiten einer Bereichsdefinition,
  betrachtet etwas am Bsp.~a? Was wird minimal gebrauchst? "`\sqlattr{TeileNr};
  300, 500"' also Partitionsattribut und Bereichsobergrenzen (außer bei
  letztem Bereich) $\rightarrow$ i.\,w. Oracle"=Ansatz für Definition von
  Bereichspartitionierung
\end{itemize}

\subsubsection{Vor- und Nachteile eines solchen "`minimalistischen"' Ansatz'?}

\begin{itemize}
 \item Disjunktheit und Vollständigkeit bei der Partitionierung automatisch
  gegeben, es kann nicht vergessen werden oder versehentlich überlappen
 \item Kompakte Katalogbeschreibung (Metadaten) fpr die Partitionen
  $\rightarrow$ Speicher- und Effizienzvorteile (NB.: Oracle erlaubt
  \emph{Zehntausende} von Partitionen für eine Tabelle! Die dann natürlich
  nicht alle auf getrennte Knoten/""Table Spaces gelegt werden.)
 \item Effiziente Bestimmung der betroffenen Partitionen beim \sql{INSERT}
  oder \sql{update} (\sql{update} kann "`Umpositionierung"' von Tupeln
  erfordern) $\rightarrow$ bei Zehntausenden von Partitionen und
  "`beliebiger"' Bereichspartitionierung (à la Informix) ist
  Partitionsbestimmung aufwändig
\end{itemize}

\subsection{Abgeleitete horizontale Partitionierung}

Bisher betrachtet: Zerlegungsinformation für eine Relation~$X$ in dieser
Relation selbst enthalten (Primärschlüssel der Relation, anderes Attribut der
Relation, \ldots{}) $\rightarrow$ über Partitionierung (welches Tupel kommt in
welche Partition?) konnte lokal entschieden werden, rein unter Betrachtung
dieser Relation~$X$.

Abgeleitete horizontale Partitionierung: Zerlegungsinformation für eine
Relation~$X$ muss aus einer anderen Relation~$Y$ abgeleitet werden (weil das
für die Zerlegung relevante Attribut sich in $Y$ befindet; Relation~$X$ und
$Y$ stehen in Beziehung zueinander.)

Betrachtet am Beispiel:
\begin{sqlblock}
  \sqlreldef{Teile}{TeileNr}{TeileBez, LiefNr, Preis}\\
  \sqlreldef{Lagerort}{TeileNr}{LagerNr}
\end{sqlblock}
\sqlrel{Teile} soll entsprechend dem Lagerort der Teile partitioniert werden
(d.\,h. gemäß dem Attribut \sqlattr{LagerNr} in der Relation
\sqlrel{Lagerort}) $\rightarrow$ nicht mehr lokal entscheidbar (lokaler Blick)

Bildliche Darstellung

\noindent
\begin{minipage}{.6\linewidth}
  \centering
  \sqlrel{Teile} (virtuelle, globale Relation)\\
  \begin{tabular}{@{\vdots\quad}*{2}{c@{\quad\vdots\quad}}c@{\quad\vdots}}
    \multicolumn{3}{@{}c@{}}{\dotfill}\\
    \sqlattr{TeileNr}& \sqlattr{TeileBez}& \ldots{} \\
    \multicolumn{3}{@{}c@{}}{\dotfill}\\
    35181& Schraube M8x3& \ldots{} \\
    38799& Mutter M8& \ldots{} \\
    37244& Mutter M7& \ldots{} \\
    42351& Bolzen B33& \ldots{} \\
    43749& Schraube M4x6& \ldots{} \\
    44812& Bolzen B27& \ldots{} \\
    45438& Schraube M3,5x5& \ldots{} \\
    \vdots& \vdots & \vdots\\
    \multicolumn{3}{@{}c@{}}{\dotfill}
  \end{tabular}
\end{minipage}%
\begin{minipage}{.4\linewidth}
  \centering
  \sqlrel{Lagerort}\\
  \begin{tabular}{|c|c|}
    \hline
    \sqlattr{TeileNr}& \sqlattr{LagerNr}\\
    35181& 3\\
    38799& 1\\
    37244& 3\\
    42351& 2\\
    43749& 2\\
    44812& 1\\
    45438& 1\\
    \hline
  \end{tabular}
\end{minipage}

\begin{tabular}{ccc}
  \begin{tabular}[t]{|c|c|c|}
    \hline
    \sqlattr{TeileNr}& \sqlattr{TeileBez}& \ldots{} \\
    \hline
    38799& Mutter M8& \ldots{} \\
    44812& Bolzen B27& \ldots{} \\
    45438& Schraube M3,5x5& \ldots{} \\
    \vdots& \vdots & \vdots\\
    \hline
  \end{tabular}
     &
  \begin{tabular}[t]{|c|c|c|}
    \hline
    \sqlattr{TeileNr}& \sqlattr{TeileBez}& \ldots{} \\
    \hline
    42351& Bolzen B33& \ldots{} \\
    43749& Schraube M4x6& \ldots{} \\
    \vdots& \vdots & \vdots\\
    \hline
  \end{tabular}
     &
  \begin{tabular}[t]{|c|c|c|}
    \hline
    \sqlattr{TeileNr}& \sqlattr{TeileBez}& \ldots{} \\
    \hline
    35181& Schraube M8x3& \ldots{} \\
    37244& Mutter M7& \ldots{} \\
    \vdots& \vdots & \vdots\\
    \hline
  \end{tabular}\\
  \sqlrel{Teile}$_{1}$ ($\sqlattr{LagerNr}=1$)&
  \sqlrel{Teile}$_{2}$ ($\sqlattr{LagerNr}=2$)&
  \sqlrel{Teile}$_{3}$ ($\sqlattr{LagerNr}=3$)
\end{tabular}
\todo{Hier fehlen die Pfeile zwischen den Relationen}

\subsubsection{Bemerkungen zur abgeleiteten horizontalen Partitionierung}

Wann "`funktioniert"' dieser Ansatz? (welche Bedingung muss erfüllt sein?)
Wurde obiges Beispiel willkürlich gewählt? Beziehung zwischen den betrachteten
Relationen~$X$ und $Y$ wesentlich, d.\,h. am Beispiel, für ein Teil muss ein
eindeutiger Lagerort existierren $\rightarrow$ hier gegeben wegen der Annahme,
dass zu jedem \sqlrel{Teile}"~Tupel \emph{genau ein} korrespondierendes
\sqlrel{Lagerort}"~Tupel existiert.

Verallgemeinerbar?

Referentielle Integritätsbedingung existiert
\todo{Bild}
partitioniert wird Relation~\sqlrel{X} nach Attribut~\sqlattr{D} in
Relation~\sqlrel{Y}

für jeden \sqlrel{X}"~Tupel existiert ein eindeutiger \sqlattr{D}"~Wert (in der
Relation~\sqlrel{Y})

Formale Beschreibung der Partitionierung (via Algebra"=Sprachausdruck):
Benutze (der kompakten Schreibweise wegen) \emph{Semi"=Join"=Operator}
\sql{R SJ$_{F}$ S := PJ$_{\{\text{Attr}(R)}\}$(R JN$_{F}$ S)}, d.\,h.
Semi-Join ist eine Join, wo nur die Attribute des einen Join"=Operanten
(Relation) im Join"=Ergebnis auftauchen (der zweite Operant wird nur zur
Auswertung der Join"=Bedingung~$F$ herangezogen/""betrachtet) $\rightarrow$
wichtiger Spezialfall des Joins.

Auf unser Beispiel angewandt:
\begin{sqlblock}
  \sqlrel{Teile}$_{1}$ = \sqlrel{Teile} NSJ (SL $_{\sqlattr{LagerNr}=1}$
    \sqlrel{Lagerort})\\
  \sqlrel{Teile}$_{2}$ = \sqlrel{Teile} NSJ (SL $_{\sqlattr{LagerNr}=2}$
    \sqlrel{Lagerort})\\
  \sqlrel{Teile}$_{3}$ = \sqlrel{Teile} NSJ (SL $_{\sqlattr{LagerNr}=3}$
    \sqlrel{Lagerort})
\end{sqlblock}
mit \sql{NSJ} als Natural"=Semi"=Join.

\subsection{Alternativen zur Bereichspartitionierung}

Bisher (horizontale) Bereichspartitionierung diskutiert, am Beispiel aus
\autoref{sec:hori-part}

\todo{Bild}

Von DBMS"=Produkten darüber hinaus teils angeboten:
\begin{enumerate}
 \item \emph{Hash"=Partitionierung}
  \begin{itemize}
   \item Sei \sqlattr{A}~Attribut von Relation~\sqlrel{X} und seien
    $a_{i}$~Attributwerte von \sqlattr{A}, so wird die Partition eines
    Tupels~$t$ über $h(a_{i})$ mit der Hashfunktion~$h$ bestimmt.
   \item $n$~Partitionen für Relation~\sqlrel{X} $\rightarrow$ $h$ bildet ab
    in Wertebereich $[0,\dotsc,n-1]$
   \item $h$ kann systembereitgestellt sein oder vom Benutzer/""Administrator
    ggf. auf \sqlrel{X} zugeschnitten ($h_{\sqlrel{X}}$)
  \end{itemize}

  Vorteile/""Nachteile?
  \begin{procontra}
   \pro (Angestrebt) Gleichmäßige Verteilung von Tupeln über Partitionen, was
    durch Bereichspartitionierung i.\,d.\,R. nicht erreicht werden
    kann und soll.

   \contra Zerstörung inhaltlicher Zusammenhangseigenschaften (die einzelne
    Partition enthält "`heterogene Daten"')
  \end{procontra}
  $\rightarrow$ Anwendung weniger bei (geographisch) verteilten Datenbanken,
  sondern im \emph{zentralisierten Fall}, zur Ausnutzung von Parallelität
  (vgl. \autoref{sec:vorl-arch})

 \item \emph{Round"=Robin"=Partitionierung}
  \begin{itemize}
   \item Verteilung der Tupel jeweils bei Einfügung "`reihum"' auf die
    Partitionen, also nicht werteabhängig!
  \end{itemize}

  \begin{procontra}
   \pro Gleichmäßige Verteilung von Tupeln
   \pro Billig beim Insert, keine Metadaten etc benötigt
   \contra Zerstörung inhaltlicher Zusammenhangseigenschaften
   \contra Partition eines Tupels (bei Suche) nicht bestimmbar
  \end{procontra}
  $\rightarrow$ Anwendung wie bei Hashtabelle

 \item \emph{Random"=Partitionierung}
  \begin{itemize}
   \item Zufällige Verteilung der Tupel auf die Partition, also nicht
    werteabhängig
  \end{itemize}

  $\rightarrow$ entspricht den Pros und Cons der
  Round-Robin"=Partitionierung, auch hinsichtlich des Anwendungsbereichs
\end{enumerate}

Zusammengefasst:
\todo{Bild: Baum: "`horizontale Partitionierung"' $\rightarrow$
  "`werteabhängig"' ($\rightarrow$ "`Bereichspartitionierung"' +
  "`Hashpartitionierung"') + "`werteunabhängig"' ($\rightarrow$ Round"=Robin +
  Random), unter Bereichspart: "`für (geografisch) verteilte Datenbanken,
  unter die anderen eine Klammer mit "'für \glq{}sonstige\grq{}
  Anwendungsbereiche (lokal verteilt \ldots{} vgl. \autoref{sec:formen-der-verteilung})}

\subsection{Vertikale Partitionierung}

\todo{Bild}

\begin{itemize}
 \item Realisierung über \emph{Projektionen} (im Unterschied zur
  \emph{Selektion} im \autoref{sec:hori-part})
  \begin{sqlblock}
    \sqlrel{R}$_{1}$ := PJ$_{\{\sqlattr{PS, A, B, C}\}}$ \sqlrel{R}\\
    \sqlrel{R}$_{2}$ := PJ$_{\{\sqlattr{PS, D, E}\}}$ \sqlrel{R}
  \end{sqlblock}

 \item "`Wiederherstellen"' der globalen Relation ("`Sicht"') durch
  \emph{Natural"=Join} über die Partitionen
 \item Hier angenommen: \emph{Disjunkte} Attributmenden zur
  Redundanzvermeidung; kein "`Muss"' jedoch \help{da geht es bei mir auf der
  Folie nicht weiter}

 \item Ebenfalls angenommen: \emph{Primärschlüssel} als Bestandteil jeder
  Partition (gestattet einfaches "`Wiederherstellen"' der globalen Relation
  über Natural"=Join) kein "`Muss"' jedoch \help{jedoch was? Mitten im Satz
  aufhören ist nicht nett}

  [NB.: Falls Partitionen bei vertikaler Partitionierung \emph{nicht} den
  Primärschlüssel enthalten sollen (etwa um auch diese Redundanz zu
  vermeiden), so muss auf Verlustfreiheit der Zerlegung geachtet werden (vgl.
  formale Grundlagen hierzu etwas in \cite[S.~49ff.]{dadam}): Originalrelation
  lässt sich durch natürlichen Verbund der Teilrelation (Partitionen)
  wiederhersellen, ohne dass Tupel "`verlorengegangen"' oder hinzugekommen
  sind hierbei $\rightarrow$ \emph{nicht} jede Zerlegung einer Relation ist
  verlustfrei in diesem Sinne! (ist eigentlich auch Aspekt der
  Normalformlehre/""bei Normalisierung zu beachten, haben wir in DB~2 aber
  ignoriert)]

 \item Vertikale Partitionierung auch aus klassischen, zentralisieren
  Datenbanksystemen bekannt und (implizit) benutzt: \emph{"`Abspaltung"' von
  Large"=Object"=Attributen} (\acsp{LOB}, \acsp{CLOB}, \acsp{BLOB}, \ldots{})
  mit Ablage i.\,d.\,R. in separaten Table Space (aus
  implementierungstechnischen Gründen (Resttupel passt in eine Datenbankseite)
  und Performance-Gründen) $\rightarrow$ Vermischung von Partitionierung und
  Allokation
\end{itemize}

\subsection{Gemischte Partitionierung}

Kombination der bisher vorgestellten Partitionierungsarten, also vertikal und
(vor allem) horizontale Bereichspartitionierung.

Beispiel:
\begin{sqlblock}
  \sqlreldef{angest}{PersNr}{AngName, Gehalt, AbtNr, Anschrift}\\
  \sqlrel{angest}\textsubscript{vertraulich} := PJ$_{\{\sqlattr{PersNr,
    Gehalt}\}}$ \sqlrel{ANest}\\
  \sqlrel{angest}\textsubscript{öffentlich$_{1}$} :=
    SL$_{\sqlattr{AbtNr}<300}$ PJ$_{\{\sqlattr{PersNr, AngName, AbtNr,
    Anschrift}\}}$ \sqlrel{ANest}\\
  \sqlrel{angest}\textsubscript{öffentlich$_{2}$} :=
    SL$_{\sqlattr{AbtNr}\geq300}$ PJ$_{\{\sqlattr{PersNr, AngName, AbtNr,
    Anschrift}\}}$ \sqlrel{ANest}
\end{sqlblock}

Ergebnis graphisch veranschaulicht: \todo{Bild} (hier nicht zu
erkennen/""dargestellt: Schlüssel \sqlattr{PersNr} in allen Partitionsschemata
enthalten $\rightarrow$ sonst Probleme mit Zuordnung zu entsprechenden Tupeln
der globalen Relation, Duplikateleminierung (wobei wir ja wissen, dass
Duplikateleminierung "`in Realität"' (\ac{SQL}) nicht automatisch stattfindet im
Gegensatz zur Relationenalgebra))

\section{Physische Verteilung der Daten -- Allokation}

Aspekte, die hierbei zu betrachten sind: Effizienz und Verfügbarkeit

\begin{itemize}
 \item Effizienz: Verteilung der Daten (auf Rechnerknoten, Table Spaces,
  \ldots{}) so, dass Verarbeitungskosten (für Anfragen, Änderungen, \ldots{})
  möglichst gering sind.

  Bemerkungen hierzu/""Probleme hierbei:
  \begin{itemize}
   \item Was steht im Vordergrund, was ist zu berücksichtigen?
    \begin{enumerate}
     \item\label{enu:eff-gesk} \emph{Gesamtverarbeitungskosten} für eine gegebene Last (Workload)
      --~Durchsatz als Optimierungsziel~-- und/oder
     \item\label{enu:eff-grenz} vorgegebene \emph{Obergrenzen} für die Kosten (Dauer) bestimmter
      einzelner Lastbestandteile
    \end{enumerate}
    $\rightarrow$ meist spielt beides eine Rolle

   \item Beispeil:
    \begin{itemize}
     \item \autoref{enu:eff-gesk} Materialbuchungen, nachts, Batch"=Betrieb: nur
      Gesamtverarbeitungskosten relevant
     \item \autoref{enu:eff-gesk}+\autoref{enu:eff-grenz} Kontenbuchungen,
      tags, Dialog"=Betrieb: Gesamtverarbeitungskosten relevant
      ("`Resourcenverbrauch"') und keine Einzelbuchung soll länger als drei
      Sekunden dauern (möglichst)
     \item \autoref{enu:eff-grenz} Maschinensteuerung, Realzeit"=Betrieb: nur Zeitobergrenzen relevant
      ("`harte"' Obergrenzen.)
    \end{itemize}

   \item Problem hierbei?
    \begin{itemize}
     \item Nur \autoref{enu:eff-gesk} allein gibt es kaum, d.\,h. DB"~Entwurf
      (inkl. Verteilung/""Allokation) muss meist auch
      \autoref{enu:eff-gesk}+\autoref{enu:eff-grenz} berücksichtigen

      [Nebenbemerkung/""Einschub: Außer man legt \emph{separate}, redundante
      Datenbank an für jeweilige spezifische Lastcharakteristika +
      Anforderungen wie etwas für Date Warehouseing der Fall]

     \item \autoref{enu:eff-grenz} lieben die Datenbänkler überhaupt nicht,
      DBMS erlauben, insb. im Mehrbenutzerbetrieb, kein garantiertes Einhalten
      \emph{harter} Zeitschranken für die Dauer von DB"~Anweisungen
      $\rightarrow$ Locking
    \end{itemize}
  \end{itemize}

  Was geht in Kosten alles ein?
  \begin{itemize}
   \item Lokale Verarbeitungskosten (I/O, CPU) auf einzelnen Knoten
   \item Übertragungskosten
  \end{itemize}

 \item \emph{Verfügbarkeit}
  \begin{itemize}
   \item Durch Redundanz (Datenreplikation) $\rightarrow$ bei der Allokation!
   \item \help{das fehlt auf meiner Kopie} Zusatzforderung, dass
    Performance"=Einbuße bei Ausfall einzelner Knoten "`noch tolerierbar"' ist
    (etwa, in dem Replikate \emph{nicht beliebig} (anderen) Knoten zugeordnet
    werden, sondern solchen \emph{in der Nähe} oder solchen mit
    \emph{ähnlichen Charakteristika} (Mainfraim vs. PC))
  \end{itemize}
\end{itemize}

Es ist prinzipell möglich, ein \emph{mathematisches Modell} aufzustellen, zur
\betonung{Bestimmung einer optimalen Allokation} \cite[S.~76ff.]{dadam}
$\rightarrow$ praktisch irrelevant, wegen erforderlicher exakter Angaben zur
DB, (vor allem) zur Lastbeschreibung, zu den Verarbeitungskosten, zu den
Übertragungskosten etc. (detaillierte Lastbeschreibung ist \betonung{immer}
ein Problem, muss bis auf Tupelebene, Verteilung über Partitionen etc.
heruntergehen $\rightarrow$ Angaben liegen nicht vor, können nur abgeschätzt
werden \help{das fehlt auf meiner Kopie} nicht stabil)

\nextchapter

\section{Grundlagen/""Abgrenzung}

\begin{itemize}
 \item bekannt: Drei-Schema-Architektur nach ANSI/SPARC: externes Schema,
  konzeptuelles Schema, internes Schema

  \todo{Bild einfügen}

  Ziele vor allem (DBS~1 \ldots{}) physische und logische Datenunabhängigkeit!
  Relationale DBMS realisieren physische in hohem Maße, logische in maßen
  (View"=Update"=Problem; Umgang mit Materializes Views noch in den Anfängen
  (letztere in DB2/Oracle erst seit wenigen Jahren verfügbar))

  Zusätzliche Forderungen (Ziele) der Schema-Architektur in vDBMS:
  \begin{itemize}
   \item Verteilungsunabhängigkeit: Anwendungsprogramm sieht die Verteilung
    der Daten, inklusive der Partitionierung und Allokation, nicht. Ebenso
    wenig die Replikation. $\Rightarrow$ Änderungen möglich (durch
    Datenbankadministrator), ohne Anwendungsprogramm anpassen zu müssen!

   \item Datenmodellunabhängigkeit: Anwendungsprogramm kann in einer
    (einheitlichen) Anfragesprache operieren, unabhängig davon, auf welchem
    Knoten die Daten abgelegt sind. Wann tritt dieses Problem/""diese
    Forderung auf?

    \todo{Bild einfügen}
    $\Rightarrow$ globales Schema + DB"~Sprache soll "`verstecken"':
    \begin{itemize}
     \item Unterschiedliche lokale Datenmodelle, Anfragesprachen, strukturelle
      + semantische Heterogenitäten
     \item Partitionierung
     \item Replikation
     \item Allokation
    \end{itemize}

    Für Datenbankadministrator/""Query Processor erforderlich sind:
    \begin{itemize}
     \item Informationen über Partitionierung, Allokation, Replikation,
      Kopien"=Aktualisierungs"=Strategie (wann, welche Reichenfolge, \ldots{})
    \end{itemize}
  \end{itemize}
\end{itemize}

Fallunterscheidung im Folgenden:
\todo{Bild einfügen}

\section{Homogene, präintegrierte Datenbanksysteme}
\label{sec:hom-pr-int}

Charakteristika: Datenbanksystem, das von vornherein als verteiltes
Datenbanksystem (anstelle eines zentralen Datenbanksystems) realisiert wird
$\rightarrow$ Grüne"=Wiese"=Ansatz
\begin{itemize}[$\rightarrow$]
 \item Keine Altlasten (Anwendungsprogramme, die bislang (auf lokalen
  Datenbeständen) laufen und weiterhin laufen sollen)
 \item (Top"~Down"~)""Datenbankentwurf: (E/R $\rightarrow$) globale Relationen
  $\rightarrow$ Partitionen $\rightarrow$ Allokation
 \item Homogene lokale Schemata (auch keine strukturellen/""semantischen
  Heterogenitäten)
\end{itemize}
$\rightarrow$ einfachster und friedlichster Fall

\subsection{Schema"=Grobarchitektur bei homogenen, präintegrierten
  Datenbanksystemen}

\todo{Bild einfügen: AP $\rightarrow$ globale externe Schemata $\rightarrow$
  globales Schema (GKS, GPS, GAS) $\rightarrow$ lokales konzeptuelles Schema
  $\rightarrow$ lokales internes Schema}

\begin{itemize}
 \item \ac{GKS} realisiert globale Außensicht
 \item \ac{GPS} beschreibt die Partitionierung der Relationen des \ac{GKS}
 \item \ac{GAS} beschreibt die physische Platzierung der Partitionen (also die
  Allokation)
\end{itemize}

Was jeweils zu den verschiedenen Schemata dazugehört:
\begin{itemize}
 \item \ac{GKS}: Globaler Katalog
  \begin{sqlblock}
    \sqlreldef{ABT}{AbtNr}{AbtName, Bereich, MgrPersNr, Budget}
  \end{sqlblock}

 \item \ac{GPS}: Globales Partitionierungsschema
  \begin{center}
    \begin{tabular}{|c|c|}
      \hline
      \multicolumn{2}{|c|}{Globale Relationen}\\
      \hline
      Globale Relation& Defintion\\
      \hline
      \sqlrel{ABT}& \sql{\sqlrel{ABT1} UN \sqlrel{ABT2}}\\
      \vdots& \vdots
    \end{tabular}

    \begin{tabular}{|c|c|c|c|}
      \hline
      \multicolumn{4}{|c|}{Partitionen}\\
      \hline
      Partition& Attribute& Globale Relation& Selektionsprädikat\\
      \hline
      \sqlrel{Abt1}& \sqlschl{AbtNr}, \sqlattr{AbtName, Bereich, MgrPersNr,
         Budget}& \sqlrel{ABT}& \sql{\sqlattr{AbtNr}$\leq300$}\\
      \sqlrel{Abt2}& \sqlschl{AbtNr}, \sqlattr{AbtName, Bereich, MgrPersNr,
         Budget}& \sqlrel{ABT}& \sql{\sqlattr{AbtNr}$>300$}\\
      \vdots& \vdots& \vdots& \vdots
    \end{tabular}
  \end{center}

 \item \ac{GAS} Globales Allokationsschema
  \begin{center}
    \begin{tabular}{|*{4}{c|}}
      \hline
      \multicolumn{4}{|c|}{Allokationen}\\
      \hline
      Partition& Lokaler Name& Primärkopie& \ldots{} \\
      \hline
      \sqlrel{abt1}& \sqlrel{Abteilung@Knoten\_A}& Knoten\_A& \ldots{} \\
      \sqlrel{abt2}& \sqlrel{Abteilung@Knoten\_C}& Knoten\_C& \ldots{} \\
      \vdots& \vdots& \vdots& \vdots
    \end{tabular}
  \end{center}

 \item lokales konzeptuelles Schema:
  \begin{center}
    \begin{tabular}{ccc}
      \sql{\sqlrel{Abteilung}(\ldots{})}& & \sql{\sqlrel{Abteilung}(\ldots{})}\\
      \vdots& & \vdots\\
      Knoten~A& Knoten~B& Knoten~C
    \end{tabular}
  \end{center}
\end{itemize}

Hinweise:
\begin{itemize}
 \item Vereinfachte Darstelllung in obiger Abbildung, speziell Partitionen
  würden im Katalog \glq{}real\grq{} sicher anders dargestellt werden
  (Schemainformation, bei horizontaler Partitionierung, nur einmal -- bei
  globaler Relation --, dafür Algebraausdrücke zur Ableitung der Partitionen
  hieraus)
 \item worauf muss der Optimizer Bezug nehmen beider Übersetzung einer
  (globalen) Anfrage aus $AP_{Gi}$?
  \begin{itemize}
   \item Globales Schema (\ac{GKS}, \ac{GPS}, \ac{GAS})
   \item lokalen Schemata (\ac{LKS}"~x, \ac{LIS}"~x) nur dort liegen die
    Informationen über die lokale Speicherung (physische Realisierung,
    Datenverteilung auf Table Spaces, Indexe, Performance"=Charakteristika bei
    leistungsmäßig unterschiedlichen Knoten (CPU"~Geschwindingkeit, Caches,
    Plattencharakteristika) $\rightarrow$ benötigt für Performance"=Vorhersage
    (Kostenschätzung)) vor
  \end{itemize}
\end{itemize}

\section{Heterogene, präintegrierte Systeme}
\label{sec:het-pr-int}

Charateristika:
\begin{itemize}
 \item von vornherein als verteiltes System (getrennte Datenverwaltung)
  konzipiert
 \item heterogene lokale Systeme zugrundeliegend
\end{itemize}

Warum handelt man sich solche Probleme (Heterogenität!) \glq{}freiwillig\grq{}
ein/geht diesen Weg? $\rightarrow$ Systeme, wo unterschiedliche
(Teil"~)""Aufgabestellungen innerhalb eines Gesamtsystems berücksichtigt
werden müssen!

Beispiel: \todo{Bild einfügen: CAD"~System mit Verwaltungsinformationen in
einer DB und Geometriedaten in einer anderen DB}

Gründe für diesen Ansatz:
\begin{enumerate}
 \item\label{enu:het-pr-int-grund1} historisch Gewachsen, etwa aus erweiterten
  Anforderungen an ein CAD"~System heraus, zusätzliche Berücksichtigung
  betriebswirtschaftlicher Anforderungen (Produktdaten, nicht technisch)

 \item\label{enu:het-pr-int-grund2} System"~/""Datenaufteilung aus
  Performance"=Überlegungen (Polygondaten u.\,U. kosteneffizienter direkt in
  Dateien abgelegt als über Umweg über DBMS, auch in Ermangelung adäquater
  DBMS"=Modelle- und "~Speicherkonstrukte $\rightarrow$ Objektrelationalität
  als Lösung? $\rightarrow$ eNF\texttwosuperior{}"~artige Strukturen in
  heutigen relationalen Produkten nur rudimentär vorhanden und mit
  nichtadäquater Speicherung (\acp{LOB}, Side Tables))

 \item System"~/""Datenaufteilung aus Modularisierungsüberlegungen (alles,
  auch "`Spezialfälle"', wirklich in einem großem DBMS realisieren oder
  modular abtrennen) [Bsp.: DB2 Text Extender hat (Text"~)""Index und
  Indexverwaltung "`außerhalb"'. Gründe? \autoref{enu:het-pr-int-grund1},
  \autoref{enu:het-pr-int-grund2}]
\end{enumerate}

\subsection{Exkurs: DB2 Text Extender}

\todo{Bild einfügen}

\begin{itemize}
 \item Leichte Variation des obigen Ansatz: obige Sicht (Anwendung) "`spricht
  nicht direkt"' mit zwei Datenhaltungssystemen, sondern -- in erweiterter
  Sprache (\ac{UDF}"~Verwendung!) -- nur mit einem, dem DBMS (welches die
  "`Verzweigung"' in das andere System unter der Decke erledigt)

 \item Texte in \acp{CLOB} in den DB"~Tabellen (vertikal Partitioniert!),
  Textindexe separat in Dateien

 \item Wie funktioniert Textsuche?
  \begin{itemize}
   \item Per \ac{UDF}"~Verwendung in \ac{SQL}"~\ac{SFW}"~Ausdruck
    \sql{CONTAINS (\ldots{})} mit Textspalte + Text Search Expression
   \item DBMS kennt/""analysiert Text Search Expression nicht! (Syntax,
    Semantik)
   \item \ac{UDF} reicht Text Search Expression durch (verzweigt) an separate
    Komponente Search Manager, dieser liefert Trefferliste zurück
  \end{itemize}

 \item Wie funktioniert Texteinfügung/"""~änderung/"""~löschung? Wo liegt das
  Problem? Aktualisierung des separat liegenden Textindex!!
  \begin{itemize}
   \item Trigger"=Verwendung
    (\sql{Insert}"~/""\sql{Update}"~/""\sql{Delete}"~Trigger)
   \item Trigger rufen antsprechende Prozeduren auf, die in Search Manager
    (Index Maintenance) verzweigen und dort Indexaktualisierungen vornehmen
  \end{itemize}

 \item Was \betonung{ist} der Text Extender (\help{Hier kann ich was auf
  meiner Kopie nicht lesen} ein DB2 Extender allgemein)?
  \begin{itemize}
   \item Vordefinierte \acp{UDF}
   \item Vordefinierte Trigger
   \item Administrations"~/""Installationshilfmittel (Skripte)
   \item Separater Search Manager
  \end{itemize}
  Alles paketiert = Extender

  (gleiches Prinzip bei Oracle Cartridges und Informix Data Blades)
  (andere bekannte Extender: Image Extender, Spatial Extender)
\end{itemize}

Vor- und Nachteile des Text"=Extender"=Ansatz'/""Separierung?
\begin{procontra}
 \pro "`Einfache"' und schnelle Integration verhandener Systeme -- DBMS
  einerseits, Information"=Retrival"=System andererseits -- unter teilweiser
  Beibehaltung der separaten Datenverwaltung

 \pro Modularisierung; keine Erweiterung des DBMS nötig um Spezialindex (Text)
  $\rightarrow$ keine Vermischung von allgemeiner DBMS"=Funktionalität
  ("`universell nutzbarer"' Funktionen) und Spezialfunktionalität eines
  bestimmten Anwendungsbereichs (hier: Text)

 \semipro kein DBMS"=Overhead (Schichtenmodell \ldots{}) für Textindex

 \contra Textindex außerhalb der Datenbank; problematisch in Bezug auf
  Transaktionseigenschaften (\ac{ACID}), Locking, \ldots{} $\rightarrow$
  Wiederanlauf im Fehlerfall (Crash, Externspeicherversagen, \ldots{})
  skriptgestützt

 \semicontra Schutzaspekt (gewisse Daten -- Textindex -- nicht unter
  DBMS"=Kontrolle/"""~autorisierung) $\rightarrow$ in der Praxis durch
  speziellen DB"~Server gelöst

 \contra Problem bei Anfrageoptimierung, \ac{UDF} als Black Box (extern!) aus
  Sicht des Optimizers; Selektivitätsabschätzung bei Textsuchprädikaten
  $\rightarrow$ Defaults, Optimizer Hints
\end{procontra}

Resümee (dito \cite[S.~95]{dadam}): Vollständig integrierter Ansatz wäre
vielleicht "`schöner"', eher der reinen Lehre entspechend, aber Tendenz geht
eher zur Modularisierung, Andocken separater Datenhaltungs- und
Spezialbausteine, aber unter einheitlicher Oberfläche (\ac{SQL} + \ac{UDF})
$\rightarrow$ gegen die eierlegende Wollmilchsau

\hfill\dotfill{} Ende des Exkurs' \dotfill{}\hfill

Schemaarchitektur: Bei Ansatz à la \autoref{sec:het-pr-int} Schemaarchitektur
im Prinzip à la \autoref{sec:hom-pr-int}, aber mit möglicherweise aufwendigem
Mapping (Schema- und Sprachtransformationen zur Überbrückung der Heterogenität)

\section{Postintegrierte Systeme}

(Unterscheidung zwischen Homogenität und Heterogenität erst weiter unten)

Ausgangspunkt allgemein: Nachträgliche Integration vorhandener Datenbanken zu
einer verteilten Datenbank.

Problem: Bisherige, lokal operierende Anwendungen können nicht einfach -- oder
überhaupt nicht -- auf neues, globales Schema umgestellt werden ("`auf Ebene
des globalen Schemas angehoben werden"') $\rightarrow$ ggf. schrittweise
Umstellung (Anhebung), aber Aufwand, Performance"=Nachteile

Sichtweise der lokalen Anwendungen: "`Stülpt rüber, was Ihr wollt, aber lasst
uns in Ruhe/""unverändert weiter leben."' $\rightarrow$ hinsichtlich der
Funktionalität, möglichst auch der Performance!

Mögliche Herangehensweisen:
\begin{enumerate}
 \item voll integrierte lokale Datenbanken, alle lokalen Daten werden nur
  global zur Verfügung gestellt

  \todo{Bild einfügen}

  Vorgehensweise:
  \begin{enumerate}
   \item Festlegung von KS"~neu, den neuen einheitlichen (globalen)
    konzeptuellen Schemas
   \item Transformationsanpassungen "`nach unten"', von KS"~neu auf die
    vorhandenen internen Schemata IS-$i$ bzw. Modifikation des IS-$i$
   \item Transformationsanpassungen "`nach oben"', Abbildungsanpassungen zur
    "`Simulation"' der bisherigen $ES_{ij}$ auf dem neuen konzeptuellen Schema
  \end{enumerate}

  Bemerkungen/""Bewertung:
  \begin{procontra}
   \pro Anwendungen bleiben \emph{unbeeinfluss}, bekommen weiterhin ihre
    externen Schemata $ES_{ij}$ dargeboten. ToDo: Anpassung der
    View"=Definitionen!

   \pro Anpassungen der internen Schemata, wenn nötig, unkritisch
    (Datenunabhängigkeit, wie immer \ldots{})

   \contra Performance"=Probleme, wenn die bisherigen $ES_{ij}$ u.\,U.
    aufwendig "`simuliert"' werden müssen, um -- auch auf dem neuen
    konzeptuellen Schema KS"~neu -- den Anwendungen ihre alte Umgebung
    "`vorgaukeln"' zu können!!
  \end{procontra}

  Wann machen sich solche Performance"=Probleme besonders bemerkbar
  (beispielsweise)? Bei großer Heterogenität der Ausgangssysteme, der KS-$i$,
  der IS-$i$!!

  Beispiele für große Heterogenität:
  \begin{itemize}
   \item Ausgangssysteme teils hierarchisch (\ac{IMS}), teils relational (KS-1,
    KS-2). KS"~neu relational $\rightarrow$ aufwendige Abbildungen, um für
    Anwendungen "`hierarchisch \glq{}on top of\grq{} rational"' zu simulieren

    (ähnliches Problem auch bei Datenbankmigration: es gibt Ansätze (Praxis!),
    um nach erfolgter Daten\emph{bank}migration (Bestand hierarchisch
    $\rightarrow$ relational) bisherigen Altanwendungen weiter die Existenz der
    hierarchisch Datenbank "`vorzugaukeln"': Umsetzung (Runtime"=Abbildung) von
    \ac{DL/1}"~Calls auf \ac{SQL}"~Sprachanweisungen, performancemäßiges
    Desaster!! aber es läuft \ldots{})

   \item Ausgangssysteme sind bereits relational (KS-$i$), dito KS"~neu:
    Ursprungstabelle (in KS-1 etwa) nun aber in vielleicht viel
    umfangreicherer KS"~neu "`versteckt"' oder -- schlimmer -- dort aufgeteilt
    über mehrere Tabellen etc

   \item Umstellungsproblem: Übergang von KS-$i$ auf KS"~neu müsste zu
    \emph{einem} Zeitpunkt geschehen ("`big bang"'), alle
    Anpassungen/""Modifikationen $ES_{ij}$"~KS"~neu entsprechend verfügbar:
    keine schrittweise Migration in neue, integrierte Welt möglich
    $\rightarrow$ kaum praktisch durchführbar
  \end{itemize}

 \item partiell integrierte lokale Datenbanken
  \begin{itemize}
   \item nicht alle lokalen Daten (aus KS-$i$) werden global zur Verfügung
    gestellt (in KS"~neu)
   \item lokale Anwendungen dürfen weiterhin direkt auf lokalen Daten
    operieren (ohne Umweg über KS"~neu, sozusagen "`nativ"' ohne "`Simulation"')
  \end{itemize}

  Was ist \betonung{neu} vor allem? $\rightarrow$ \ac{LRS} = Exportschemata

  \todo{Bild von Folie 73 einfügen}

  Zwei Aufgaben/""Ziele bei der \ac{LRS}"~Verwendung:
  \begin{enumerate}
   \item Legt fest, welcher Ausschnitt der lokalen Datenbank global zur
    Verfügung gestellt werden soll (im einfachsten Fall, welche lokalen
    Relationen "`globalisiert"' werden sollen, aber auch feinere Abstufungen
    strukturell/""werteabhängig möglich)
   \item Führt Vereinheitlichung durch: Unterschiedliche lokale strukturelle
    Formen und Semantiken werden datenbankweit (knotenübergreifend),
    einheitlich dargestellt! (Export berücksichtigt globel Vorgaben bzgl.
    Struktur und Semantik)
  \end{enumerate}
  $\rightarrow$ Homogenisierung der (Darstellung der) lokalen Schemata!!

  $\rightarrow$ Annäherung -- durch jenen Zwischenschritt -- an Situation
  (Integrationsaufgabe) im präintegrierten homogenen Fall oben, erkauft durch
  u.\,U. sehr aufwendige (rechenintensive) Transformationsregeln,
  Update"=Probleme, \ldots{}

  Weitere Hinweise/""Bemerkungen zum neuen Vorgehen:
  \begin{itemize}
   \item "`Langer Weg"' (sechs Kanten im obigen Graphen) zwischen $AP_{Gi}$
    (globaler Anwendung) und Datenbestand, performancerelevant (s.\,o.) und mit
    möglicherweise funktionalen Auswirkungen (Einschränkungen, Update"=Problematik)
   \item \ac{LES} unverändert, lokale Anwendungen ($AP_{Ai}, AP_{Bj}$) dito
   \item Lokale Exportschemata, lokale externe Schemata müssen natürlich nicht
    disjunkt sein: ggf. kann gleicher Datenausschnitt global (mit global
    angepasster Struktur und Semantik) und (weiterhin) lokal (zum "`Schutz"'
    der vorhandenen Anwendungen/""Weiternutzung) zur Verfügung gestellt werden

    $\rightarrow$ Disjunktheit macht Dinge jedoch einfacher, vor allem bei
    Schemarevolution (also wenn die global und die lokal genutzten Ausschnitte
    nicht überlappen)
  \end{itemize}
\end{enumerate}

\subsection{Schemintegration}

Aufgabe: Definition eines "`integrierenden"' globalen Schemas ausgehend von
lokalen (konzeptuellen) Schemata, die unabhängig voneinander entstanden sind:
\begin{itemize}
 \item verschiedene Attributnamen (für gleiche Information)
 \item verschiedene Wertebereiche
 \item verschiedene strukturelle Repräsentation (Tabellenverteilung, \ac{LOB}
  vs. Side Table etc.)
 \item verschiedene Schlüsselsemantiken/""Wertevergabe, Primärschlüssel,
  Schlüsselkandidaten, Fremdschlüssel betreffend
 \item verschiedene Integritätsbedingungen
 \item Widersprüche zwischen den Daten an verschiedenen Knoten
\end{itemize}
$\Rightarrow$ \betonung{nicht triviales} Problem
\begin{itemize}
 \item taucht ähnlich auch z.\,B. bei Data Warehousing auf (also nicht
  \glq{}exotisch\grq{})
 \item Vorgehensmodell für Schemaintegration gefordert
\end{itemize}

\subsubsection{4"~Phasen"=Vorgehensmodell für die Schemaintegration}

Präintegration, Vergleichsphase, Vereinheitlichungsphase, Restrukturierungs-
und Zusammenfassungsphase

\begin{enumerate}
 \item Präintegration
  \begin{itemize}
   \item Bestimmen/""Festlegen der zu integrierenden Schemaausschnitte (in
    E/R"~Terminologie: Edity"=Typen, Beziehungstypen, \ldots{})
   \item Festlegen der Vorgehensweise: binäre oder $n$"~stellige Integration
    (Mehrschritt vs. Einzelschrittverfahren)

    \todo{Bild einfügen}

    Pros und Cons:
    \begin{itemize}
     \item Binäre Integration:
      \begin{itemize}
       \item erlaubt Vorgehen in kleinen Schritten (Arbeitseinheiten)
       \item Führt nicht (oder nicht einfach) zum globalen Optimum: Frühe,
        lokalgetroffenen Entwurfs-(Integrations"~)""Entscheidungen in
        Schritt~$i$ erweisen sich u.\,U. in Schritt $j\gg i$ als ungünstig
        $\rightarrow$ Nacharbeiten, Revidieren u.\,U.
      \end{itemize}

     \item $n$"~stellige Integration
      \begin{itemize}
       \item Komplexität des "`großen Schritts"'
       \item Dann sinnvoll, wenn Ausgangsschemata $S_{i}$ \emph{stark
        voneinander abweiche} (um sich erst einmal bzgl. des globalen
        Zielschemas "`zusammenzuraufen"' und nicht einfach
        "`kleinkleinloszuwurschteln"', wie bei binärer Integration die Gefahr
        besteht bei lokaler, "`kurzsichtiger"' Betrachtungsweise)
      \end{itemize}
    \end{itemize}
    $\rightarrow$ eventuell Verwendung von binärer und $n$"~stelliger Integration
  \end{itemize}

 \item Vergleichsphase
  Vor allem: Auflösung von \emph{Namens-} und \emph{Strukturkonflikten} (für
  die jeweils aktuell betrachteten Ausgangsschemata $S_{i}$)

  Homonym- und Synonymproblem, Beispiel dafür \todo{Bild einfügen: E/R"~Schema}
  Homonym: \betonung{Ein} Begriff mit \betonung{verschiedenen} Bedeutungen,
  Synonym: \betonung{Verschieden} Begriffe für \betonung{einen} Sachverhalt

  Was kann beim Erkennen von Homonymen und Synonymen helfen? $\rightarrow$
  Betrachtung von Attributen, zugehörigen Beziehungstypen \ldots{} allgemein
  des "`Kontexts"'

  (im obigen Beispiel für Homonyme: Die beiden Entity"=Typen Ausstattung
  besitzen mit hoher Wahrscheinlichkeit verschiedene Attributmengen bzgl.
  Anzahl, Attributnamen $\rightarrow$ deutet auf Homonyme hin) $\rightarrow$
  aber Vorsicht: Homonymproblem kann sich natürlich auf Ebene der Attribute
  fortsetzen, d.\,h. (einige) Attribute heißen links und rechts möglicherweise
  gleich, aber besitzen verschiedene Bedeutungen!

  Tückisch bzgl. Synonymen: Kunde und Klient (im oben Beispiel für Synonyme)
  werden mit hoher Wahrscheinlichkeit verschiedene Attributmengen aufweisen,
  d.\,h. sie haben unterschiedliche (Schema"~)""Entwicklungen durchemacht
  (d.\,h. Synonyme "`natürlich"' nicht immer sofort als solche erkennbar)

  \paragraph{Weitere Inhalte der Vergleichsphase:}
  \begin{itemize}
   \item "`Verhältnis"' der $S_{i}$ zueinander:
    \begin{itemize}
     \item äquivalent?
     \item überlappend?
     \item disjunkt?
     \item enthalten ($S_{i}$ in $S_{j}$)?
    \end{itemize}

   \item Konfliktarten auf Strukturebene (Schema):
    \begin{itemize}
     \item Typkonflikte (Modellierung als Attribut oder Entity-Typ)
      \help{fällt auch "`virtuelles (berechnetes) vs. echtes Attribut"' mit in
        diese Kategorie?}
     \item Beziehungskonflikte (1:n oder n:m)
     \item Schlüsselkonflikte (unterschiedliche Primärschlüssel)
     \item Verhaltenskonflikte (kaskadiertes Löschen oder "`manuelles"'
      Löschen)
    \end{itemize}

   \item Konflikte auf Instanzebene (Ausprägung, Daten)
    \begin{itemize}
     \item Ambiguitätsprobleme
      \begin{itemize}
       \item Mehrfachspeicherung derselben Entities -- mit unterschiedlichem
        Schlüsselwert -- in verschiedenen lokalen Datenbanken
       \item Verwendung desselben Schlüsselwerts für verschiedene Entities (in
        verschiedenen lokalen Datenbanken)

        \todo{Tabelle einfügen}
      \end{itemize}
    \end{itemize}

   \item Funktionale Konflikte: Nicht alle (potentiell möglichen) Operationen
    gegen das globale Datenmodell lassen sich in semantisch äquivalente
    Operationen gegen die lokalen Datenmodelle umsetzten. Problem woher
    bekannt? $\rightarrow$ View"=Update"=Problematik

    Lösung? Reduzierter Funktionsumfang auf globaler Ebene, etwas nur lesender
    Zugriff auf Teile des Bestands [Beliebige Operationen wird man auf
    globaler Ebene ohnehin nicht zulassen wollen/""können, etwa \ac{DDL}?]
  \end{itemize}

 \item Vereinheitlichungsphase: Konfliktauflösungs, d.\,h.
  "`(Fehler"~)""Behandlung"' für die in der zweiten Phase erkannten Konflikte
  und Probleme, u.\,a.:
  \begin{itemize}
   \item \emph{Namenskonflikte}: Auflösbar durch geeignete \emph{Umbenennung}
    (bzw. geeigenete Abbildungen, dess es erfolgt natürlich \emph{kein}
    Eingriff in die vorhandenen \emph{lokalen} Schemata/""Datenbanken); etwa
    Namenserweiterungen bei Homonymen (Attributname)

   \item \emph{Strukturkonflikte}: \emph{Umformungen} etwa zwischen
    Entity"=Typen und Attributen (Abbildungen!), etwa wenn ein (lokales)
    Attribut global als Entity-Typ gesehen werden soll etc. (oder in mehreren
    Tabellen gespeicherte Daten einer lokalen Datenbank global als "`nested
    table"' (NF\texttwosuperior{}"~artig) $\rightarrow$ Probleme à la
    View"=Update"=Problematik $\rightarrow$ nur lesender Zugriff)

   \item Ambiguitätsprobleme (auf Instanzebene): (Schlüsselproblematik (Was
    sind globale Schlüssel?) im Zusammenhang mit Integration)

    Lösungsvarianten: Einführung neuer, global einheitlicher Schlüssel oder
    globale Verwendung von erweiterten lokalen Schlüsseln
    \begin{enumerate}
     \item Einführung neuer, global einheitlicher Schlüssel
      \todo{Tabelle einfügen}

      Bemerkungen hierzu:
      \begin{itemize}
       \item Hier Schlüssel"=Umsetzungsteil integriert in globale Tabelle
        (separate, "`reine"' Schlüssel"=Umsetzungstablle wäre auch denkbar)
       \item Umsetzungsteil sollte "`verborgen"' werden vor globalen
        Anwendungen (letzten beiden Spalten von \sqlrel{GlobLiefTab})
       \item Problematisch (natürlich) bei Änderungen aller Art:
        \begin{enumerate}
         \item ABC"~Firma wird -- durch globale Anwendung -- umbenannt in
          ABZeh-Firma $\rightarrow$ Änderung entsprechend auf Knoten~A und B
         \item ABTse"=Firma wird -- durch globale Anwendung -- neu eingefügt:
          Wohin damit? Auf Knoten A oder B oder beide?
         \item Lokale Anwendung auf Knoten~A benennt ABC"~Firma um in
          ABChe"=Firma: Fortan zwei separate Tupel -- ABC"~Firma und
          ABChe"=Firma -- auf globaler Ebene? \lightning{}\lightning{}

          (kein "`neues"' Problem (durch Integration hinzugekommen), sondern
          ohnehin durch redundante Datenspeicherung A/B gegeben)
        \end{enumerate}
      \end{itemize}

     \item globale Verwendung von erweiterten lokalen Schlüsseln
      \todo{Tabelle einfügen}

      Bemerkungen hierzu:
      \begin{itemize}
       \item \emph{Ortstransparenz} aufgeweicht (Knoten-ID auf globaler Ebene
        sichtbar)
       \item Eigentlich gar keine separate Umsetzungstabelle (wärend sie im
        vorherigen Fall zumindest in Frage käme) $\rightarrow$ nur (virtuelle)
        Schlüsselerweiterung (im vorherigen Fall muss Umsetzungstabelle
        physisch existieren)
       \item Mehr Tupel als im vorherigen Fall $\rightarrow$ aber ja nur
        virtuell
       \item Änderungsprobleme?
      \end{itemize}
    \end{enumerate}
  \end{itemize}

 \item Restrukturierungs- und Zusammenfassungsphase
  \begin{itemize}
   \item Endgültige Festlegung des \emph{globalen} konzeptuellen Schemas
    $\rightarrow$ bestimmt Vorgaben für die lokalen Repräsentationsschemata
    \begin{itemize}
     \item Was muss in den jeweiligen \ac{LRS} enthalten sein?
      (Ausschnittsbildeung?)
     \item Was muss durch die jeweiligen \ac{LRS} an Vereinheitlicung
      geschehen?
    \end{itemize}

   \item Festlegung der \emph{Abbildungen} ("`Implementierung"' derselben),
    durch \ac{SQL}"~Sprachausdrücke

   \item Ziele hierbei:
    \begin{itemize}
     \item Vollständigkeit (globales Schema enthält alle -- gewünschten --
      Informationen aller Teilschemata)
     \item Minimalität/""Redundanzfreiheit
     \item Vollständigkeit
    \end{itemize}
  \end{itemize}
\end{enumerate}

\subsubsection{Zusammenfassung hiervon (Thema Schemaintegration)}

\begin{itemize}
 \item \emph{Aufwendiger}, mehrstufiger Prozess bei postintegriertem Ansatz
  \todo{Verweis auf den Abschnitt einfügen}

 \item Nur \emph{teilweise} automatisierbar (etwas \emph{Vergleichsphase} (2)
  durch Werkzeuge unterstützbar bzw. bei Vorhandensein eines globalen Data
  Dictionary (globaler Datenkatalog) im Unternehmen; dieser existiert u.\,U.
  in Teilen schon unabhängig davon, ob Integration angestrebt wird)

 \item Betrifft Schema- und Datenebene (Instanzen)

 \item \emph{Integritätsbedingungen} der lokalen Systeme zu berücksichtigen
  ("`globale Integritätsbedingungen"' ableiten?) bzw. -- schlimmer noch --
  Integritätsbedingungen, die in lokalen Anwendungen verborgen sind

 \item \betonung{Nichtsdestotrotz}: Beschrittener Weg!
\end{itemize}

\nextchapter

\section{Allgemeines/""Grundlagen}

Bekanntes aus DBS~1/2 u.\,a.:
\begin{itemize}
 \item Algebraausdrücke als formale Grundlage der internen Darstellung von
  (\ac{SLQ}-)""Sprachanweisungen sowie als
  Ausführungs"~/""Optimierungsgrundlage (vgl. insb. DBS~1 Kapitel~6.3)
 \item Reale Repräsentation hiervon in DBMS: Operatorbäume/""Query"=Graphen
  $\rightarrow$ Ausführungsplan
 \item Auf dieser Basis: Äquivalenztransformationen der Algebraausdrücke
  (berühmte 26~Regeln aus DS~1) $\rightarrow$ Query Rewrite (durch das
  DBMS/""den Optimizer)
 \item Rule-base Optimization vs. cost"=based Optimization
 \item heutige DBMS"=Produkte arbeiten alle (?) mit cost"=based Optimization
 \item Grundlage/""Kostenmaß? Geschätzte (vorhergesagte) Ausführungskosten auf
  Basis von I/O"~Kosten (Anzahl der I/O"~Operationen) (plus CPU"~Kosten)
 \item "`Datenbasis"' des Optimizers: Datenbankkatalog = Schemadaten +
  Statistikdaten; beides ja "`Daten über Daten"', also Metadaten
 \item Probleme der Optimierung:
  \begin{itemize}
   \item Statistikdaten nie in allen Fällen detailiert genug bzw. aktuell
    genug für eine "`perfekte"' Kostenvorhersage bzw. auch nicht umfassend
    genug (Beispiele!), auch weil natürlich \# Statistikdaten $\ll$ \# Daten
    sein soll! (und nicht umgekehrt ;-)
  \end{itemize}

 \item "`Vorhersagen sind schwierig, insbesondere wenn sie die Zukunft
  betreffen"' \ldots{}
  \begin{itemize}
   \item (genaue) I/O"~Kostenvorhersage (Pufferung, Caching,
    "`Buffer-Hit-Ratio"') \ldots{} vor allem bei
    \begin{itemize}
     \item Mehrbenutzerbetrieb (parallele Anfragen)
     \item Multi"=Query"=Fall (serielle Anfragen)
    \end{itemize}
   \item (genaue) CPU"~Kostenvorhersage (Pfadlängenberechnung durch Optimizer?
    \lightning{}) quasi unmöglich $\rightarrow$ Ersatzmaße, etwa Anzahl
    bestimmter Subsystemaufrufe im DBMS (berechneter Wert)
  \end{itemize}

 \item Vorhersageaufwand (Kosten für die Optimierung) Lösungen:
  \begin{itemize}
   \item Verwendung (Benutzer, \emph{Administrator}!) verschiedener
    Optimization Levels (à la DB2)
   \item keine vollständige Enumeration (kein komplettes Durchrechnen aller
    möglichen (äquivalenten) Ausführungspläne, sondern "`intelligents
    Abschneiden"' mit bekannten Techniken der heuristischen Optimierung)
  \end{itemize}
\end{itemize}

Resümee: \betonung{Alle} genannten Probleme (klassischer, zentralisierter
DBMS) treten \betonung{natürlich} auch im verteilten Fall auf und diese sogar
\betonung{verschärft}/mit zusätzlichen Lösungsanforderungen!

$\rightarrow$ Forderung nach Bestimmung \betonung{des} "`global optimalen"'
Ausführungsplans wird relaxiert wegen zu hohen Brechnungsaufwands, zu
erwartenden zu genauen Eingabedaten für die Berechnung (denn: Lösungsraum bei
Optimierung in verteilten Datenbanksystemen ist nochmal wesentlich größer als
bei zentralisierten (Beispiel?), Problem der Datengenauigkeit (Statistiken)
ist verschärft (wegen eventueller Heterogenität der Knoten-DBS, Autonomie,
\ldots{}), Übertragungskosten, \ldots{})

Unterscheidung zwischen globaler Optimierung und lokaler Optimierung.

Vorgehen "`im Großen"'
\begin{itemize}
 \item Analyse und Zerlegung einer globalen Anfrage (die also Daten an
  mehreren Knoten tangiert) in lokale Anfragen, Versuch dabei insbesondere,
  Zwischenergebnisse bzw. zu übertragende Tupelmengen möglichst klein zu
  halten (Heuristik! Hängt in wahrheit natürlich von Übertragungsraten und
  "~geschwindigkeit ab, Verhältnis zwischen Übertragungsgeschwindigkeit
  einerseits und I/O- und CPU"~Geschwindigkeit andererseits)

 \item Lokale Anfragen werden lokal ("`vor Ort"') optimiert (und natürlich
  ausgeführt)

  $\rightarrow$ Es gibt i.\,d.\,R. nicht \betonung{den} globalen Optimizer,
  der in seine Kalkulation alle, auch lokal vorliegene Informationen
  einzubeziehen versucht ("`Herkules"=Aufgabe"')

 \item Erkennen überflüssiger Teilaufgaben im verteilten Fall noch wichtiger
  als im zentralen!! (warum?)
\end{itemize}

\section{Transformation von globalen Anfragen in lokale}

Situation: Relation~\sqlrel{R} existiert nicht physisch "`am Stück"', sondern
nur virtuell: Teile der Relation (Partitionen) liegen physisch auf
verschiedenen Knoten der teilten Datenbank

Anfrage wird nun gegen \sqlrel{R} gestellt (impliziert also eine globale
Anfrage)

Möglichkeiten der Anfrageausführung (prinzipiell):
\begin{itemize}
 \item mit Materialisierung von \sqlrel{R}
  \begin{procontra}
   \pro einfach zu implementieren
   \semicontra (meist) zu kostspielig (insbesondere wenn für Anfrageausführung
    gar nicht "`ganz \sqlrel{R}"' gebraucht wird)
  \end{procontra}

 \item ohne Materialisierung von \sqlrel{R}
  \begin{procontra}
   \contra erfordert Transformation der globalen Anfrage in lokale
    ausführbare Teilanfragen
   \semipro \help{Das kann ich bei mir nicht lesen}
  \end{procontra}
\end{itemize}

Voraussetzungen für Anfragetransformationen:
\begin{itemize}
 \item Formales Regelwerk für Transformationen $\rightarrow$
  Äquivalenztransformationen vorhanden
 \item Formale Beschreibung (algebraische Spezifikation) der Abbildungen
  zwsichen globaler Relation auf Partitionen
\end{itemize}
$\rightarrow$ gestattet dann insgesamt algebraische Substitution

Beispiel: Relation \sqlrel{Teile} sei partitioniert
\begin{sqlblock}
  \sqlrel{Teile}$_{1}$ = SL$_{0\leq\sqlattr{TeileNr}<300}$ \sqlrel{Teile}\\
  \sqlrel{Teile}$_{2}$ = SL$_{300\leq\sqlattr{TeileNr}<500}$ \sqlrel{Teile}\\
  \sqlrel{Teile}$_{3}$ = SL$_{500\leq\sqlattr{TeileNr}<\infty}$ \sqlrel{Teile}
\end{sqlblock}
$\rightarrow$ \sql{\sqlrel{Teile} := \sqlrel{Teile}$_{1}$ UN
\sqlrel{Teile}$_{2}$ UN \sqlrel{Teile}$_{3}$}

Anfrage: \sql{Q1 := SL$_{\sqlattr{Preis}>700}$ \sqlrel{Teile}}

Mögliche Herangehensweise:
\begin{itemize}
 \item Einsetzen: \sql{Q1' := SL$_{\sqlattr{Preis}>700}$ (\sqlrel{Teile}$_{1}$
  UN \sqlrel{Teile}$_{2}$ UN \sqlrel{Teile}$_{3}$)}

 \item Ausmultiplizieren (Regel aus der Menge der zulässigen
  Äquivalenztransformationen) \sql{Q1'' := SL$_{\sqlattr{Preis}>700}$
  \sqlrel{Teile}$_{1}$ UN SL$_{\sqlattr{Preis}>700}$ \sqlrel{Teile}$_{2}$
  UN SL$_{\sqlattr{Preis}>700}$ \sqlrel{Teile}$_{3}$}
\end{itemize}

In \emph{Operatorbaumschreibweise} (und damit nahe an tatsächlicher interner
Repräsentation im DBMS Query Processor): \todo{Bild einfügen}

Bemerkungen hierzu:
\begin{itemize}
 \item \sql{Q1'} und \sql{Q1''} beziehen sich nicht mehr auf (virtuelle)
  Relation \sqlrel{Teile}, sondern auf Basis"=Relationen (Partitionen)
  \sqlrel{Teile}$_{1,2,3}$ $\rightarrow$ physische Relationen
  ("`Relationsteile"')
 \item \sql{Q1'} und \sql{Q1''} enthalten -- verteilte Datenbank! --
  Freiheitgrade:
  \begin{itemize}
   \item Wo (an welchem Knoten) werdei die Vereinigungsoperationen ausgeführt?
   \item Wo (an welchem Knoten) die Selektionen?
  \end{itemize}
\end{itemize}

Für den Ausführungsplan müssen derartige Festlegungen getroffen werden mit
eventuell folgendem Ergebnis: \todo{Bild einfügen}

\betonung{Ob} es so gemacht wird, entscheidet der globale Optimizer
(berücksichtigt, wie erwähnt, Übertragungskosten (vielleicht sind Verbindungen
B"~A, C"~A, D"~A unterschiedlich schnell?), Knotenleistungscharakteristika etc.)

Frage: Könnte es eventuell noch "`ganz anders"' gehen? Benötigt man wirklich
die Knoten B,C,D alle? $\rightarrow$ nur, wenn alle drei wirklich potentiell
zum Ergebnis beitragen können

\appendix
\clearpage
\begin{acronym}
  \acro{OCC}{Optimistic Concurency Control}
  \acro{LOB}{Large Object}
  \acro{CLOB}{Character Large Object}
  \acro{BLOB}{Binary Large Object}
  \acro{GKS}{Globales konzeptuelles Schema}
  \acro{GPS}{Globales Partitionierungsschema}
  \acro{GAS}{Globales Allokationsschema}
  \acro{LKS}{Lokales konzeptuelles Schema}
  \acro{LIS}{Lokales internes Schema}
  \acro{UDF}{User Defined Function}
  \acro{SQL}{Structured Query Language}
  \acro{SFW}{\sql{Select}"~\sql{From}"~\sql{Where} \acroextra{Klausel im \ac{SQL}}}
  \acro{ACID}{Atomarity, Consistency, Isolation, Durability
    \acroextra{\betonung{die} Eigenschaft von Transaktionen}}
  \acro{IMS}{Information Managment System\acroextra{Datenbank von IBM}}
  \acro{DL/1}{Data Language/One \acroextra{\ac{DML} für \ac{IMS}}}
  \acro{DML}{Data Modelling Language}
  \acro{LRS}{Lokale Repräsentationsschemata}
  \acro{LES}{Lokale externe Schemata}
  \acro{DDL}{Data Definition Language}
\end{acronym}

\clearpage
\pdfbookmark[0]{Index}{index}
\printindex

\end{document}
